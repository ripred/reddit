{
  "approved_at_utc": null,
  "subreddit": "Arduino_AI",
  "selftext": "",
  "user_reports": [],
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "MicroChess Update: Money for Nothing..",
  "link_flair_richtext": [],
  "subreddit_name_prefixed": "r/Arduino_AI",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": null,
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_125f4lu",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 1.0,
  "author_flair_background_color": null,
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": null,
  "is_original_content": false,
  "author_fullname": "t2_adfkq",
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": null,
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "default",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [],
  "gildings": {},
  "content_categories": null,
  "is_self": false,
  "mod_note": null,
  "crosspost_parent_list": [
    {
      "approved_at_utc": null,
      "subreddit": "arduino",
      "selftext": "This is the 4th post in a series about writing a chess engine for the Arduino platform. Here are [the first](https://www.reddit.com/r/arduino/comments/11q4916/so_you_want_to_build_a_chess_engine/?utm_source=share&amp;utm_medium=web2x&amp;context=3), [second](https://www.reddit.com/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/?utm_source=share&amp;utm_medium=web2x&amp;context=3) and [third](https://www.reddit.com/r/arduino/comments/123f5q3/microchess_move_evaluation_function/?utm_source=share&amp;utm_medium=web2x&amp;context=3) posts.\n\nThis is a quick update about some of the data structure and algorithmic changes that I am making as I clean up the program and implement the minimax algorithm. I came up with this structure yesterday and it works extremely well in terms of the speed improvements and the reduction of the RAM requirements of the program.\n\nThroughout the code there are a lot of places where we need to convert from the board index (0-63) and the row and column that the location represents using one or more of these formulas:\n\n        // convert a column and row into a board index\n        index = col + row * 8;\n    \n        // convert a board index to the column\n        col = index % 8;\n        // or \n        col = index &amp; 7;\n    \n        // convert a board index to the row\n        col = index / 8;\n        // or \n        col = (index &gt;&gt; 3) &amp; 7;\n\nSo the code is full of places where all 3 variables (`index`, `col`, and `row`) are needed just in order to calculate these values. This also takes up extra stack space or executes calculations that I wish I didn't have to pay for in terms of the memory used and the additional runtime execution. So I came up with this data structure:\n\n    /**\n     * @brief conv1_t struct represents a single chess piece location in 8 bits.\n     * \n     * The struct cleverly packs the data for a chess piece location into 2 bytes. It\n     * uses a union of two structures to allow for easy access to the data in two\n     * different formats. The first structure, pt, is a bitfield that is laid out as\n     * \u2020 follows:\n     * \n     *   0   1   2   3   4   5   6   7   8   9\n     * +---+---+---+---+---+---+---+---+---+------+\n     * |    col    |    row    |   type    | side |\n     * +---+---+---+---+---+---+---+---+---+------+\n     * \n     * The second structure, ndx, is laid out as follows:\n     * \n     *   0   1   2   3   4   5   6   7   8   9\n     * +---+---+---+---+---+---+---+---+---+------+\n     * |          index        |   type    | side |\n     * +---+---+---+---+---+---+---+---+---+------+\n     * \n     * The idea behind the design is that the col and row fields are easily accessed\n     * when scanning the chess board in row-major order, while the index field is\n     * easily accessed when looping over an array of pieces. Additionally, assigning\n     * to the col, row, or index fields automatically / magically performs the\n     * calculations `index = col + row * 8` and `col = ndx % 8, row = index / 8`\n     * implicitly, thanks to the clever use of the union and the resulting alignment\n     * of the bitfields!\n     * \n     * Let me say that again: The math and conversion between the (col,row)\n     * pairs and the 0 - 63 index automatically happens without having to apply\n     * the `index = col + row * 8`, `col = index % 8`, or the `row = index / 8`\n     * expressions! To understand this realize that dividing by 8 or multiplying by\n     * 8 is the same operation as shifting a value 3 bits up or down. By aligning\n     * the bitfields the way we are, we are forcing the 3 bits that store the row\n     * to implicitly be 3 bits to the left of the col bitfield when viewed from\n     * perspective of the ndx.index field! Man I love programming haha, and binary\n     * numbers are cool!\n     * \n     * The struct provides a set of getter and setter methods to safely access the\n     * bit fields, as well as constructors to initialize the values of the fields.\n     * \n     * Forcing all access to go through the the setters and getters is not just \n     * there to ensure that the fields cannot be accessed except through the \n     * methods; they serve a higher purpose. All bitfields should be able to be\n     * accessed in two\u00a7 bitwise assembly instructions: A shift operation (&lt;&lt; or &gt;&gt;)\n     * and a masking AND instruction. By providing these accessors we guarantee \n     * that all code produced by the compiler will use two assembly instructions per\n     * access worst-case when accessing any of these fields. Without this it is\n     * possible for the compiler to generate some inefficient code such as loading\n     * the entire structure into memory just to perform an operation on one of the\n     * fields and then throwing the temporary stack object away.\n     * \n     * \u2020 The actual layout with respect to the order of the fields in memory is\n     * up to the compiler based on the processor architecture. The intent and\n     * optimal storage is still achieved however regardless of the order in\n     * physical memory.\n     * \n     * \u00a7 actually to be technically accurate, worst-case it could take 4\n     * instructions if the value was split across byte boundaries in memory\n     * requiring access to two separate memory locations.\n     */\n    struct conv1_t {\n    private:\n    \n        union {\n            struct {\n                uint8_t     col : 3,    ///&lt; The column value of the position.\n                            row : 3,    ///&lt; The row value of the position.\n                           type : 3,    ///&lt; The type of piece (pawn, knight, etc.) at the position.\n                           side : 1;    ///&lt; The side (white or black) of the piece at the position.\n            } pt;                       ///&lt; A struct used to compactly store the values and to access \n                                        ///  the member fields of the union in a type-safe manner.\n            struct {\n                uint8_t   index : 6,    ///&lt; The index of the position in the board array.\n                           type : 3,    ///&lt; The type of piece (pawn, knight, etc.) at the position.\n                           side : 1;    ///&lt; The side (white or black) of the piece at the position.\n            } ndx;                      ///&lt; A struct used to compactly store the values and to access \n                                        ///  the member fields of the union in a type-safe manner.\n        } u;                            ///&lt; A union used to store the position information in two \n                                        ///  different ways, for different use cases.\n    public:\n    \n        conv1_t() : u{ 0, 0, Empty, Black } {}\n    \n        conv1_t(uint8_t index) {\n            u.ndx.index = index;\n            u.ndx.type = Empty;\n            u.ndx.side = Black;\n        }\n    \n        conv1_t(uint8_t index, uint8_t type, uint8_t side) {\n            u.ndx.index = index;\n            u.ndx.type = type;\n            u.ndx.side = side;\n        }\n    \n        conv1_t(uint8_t col, uint8_t row) : u{ col, row, Empty, Black } {}\n    \n        /**\n        * @brief Setters for the structure.\n        * \n        */\n        void set_index(uint8_t value) { u.ndx.index = value; }\n        void set_col(uint8_t value) { u.pt.col = value; }\n        void set_row(uint8_t value) { u.pt.row = value; }\n        void set_type(uint8_t value) { u.pt.type = u.ndx.type = value; }\n        void set_side(uint8_t value) { u.pt.side = u.ndx.side = value; }\n    \n        /**\n        * @brief Getters for the structure.\n        * \n        */\n        uint8_t get_index() const { return u.ndx.index; }\n        uint8_t get_col() const { return u.pt.col; }\n        uint8_t get_row() const { return u.pt.row; }\n        uint8_t get_type() const { return u.pt.type; }\n        uint8_t get_side() const { return u.pt.side; }\n    \n    };  // conv1_t\n    \n    \n    /**\n     * @brief Struct representing a chess move.\n     * \n     * The struct contains two `conv1_t` members, `from` and `to`, representing the\n     * starting and ending positions of the move, respectively.\n     */\n    struct conv2_t {\n    private:\n        conv1_t   from, to;\n    \n    public:\n    \n        conv2_t() : from(), to() {}\n        conv2_t(uint8_t from_index, uint8_t to_index)\n            : from(from_index), to(to_index) {}\n        conv2_t(uint8_t from_col, uint8_t from_row, uint8_t to_col, uint8_t to_row)\n            : from(from_col, from_row), to(to_col, to_row) {}\n        conv2_t(const conv1_t&amp; from_, const conv1_t&amp; to_)\n            : from(from_), to(to_) {}\n    \n        void set_from_index(uint8_t value) { from.set_index(value); }\n        void set_from_col(uint8_t value) { from.set_col(value); }\n        void set_from_row(uint8_t value) { from.set_row(value); }\n        void set_from_type(uint8_t value) { from.set_type(value); }\n        void set_from_side(uint8_t value) { from.set_side(value); }\n    \n        void set_to_index(uint8_t value) { to.set_index(value); }\n        void set_to_col(uint8_t value) { to.set_col(value); }\n        void set_to_row(uint8_t value) { to.set_row(value); }\n        void set_to_type(uint8_t value) { to.set_type(value); }\n        void set_to_side(uint8_t value) { to.set_side(value); }\n    \n        uint8_t get_from_index() const { return from.get_index(); }\n        uint8_t get_from_col() const { return from.get_col(); }\n        uint8_t get_from_row() const { return from.get_row(); }\n        uint8_t get_from_type() const { return from.get_type(); }\n        uint8_t get_from_side() const { return from.get_side(); }\n    \n        uint8_t get_to_index() const { return to.get_index(); }\n        uint8_t get_to_col() const { return to.get_col(); }\n        uint8_t get_to_row() const { return to.get_row(); }\n        uint8_t get_to_type() const { return to.get_type(); }\n        uint8_t get_to_side() const { return to.get_side(); }\n    \n    };  // conv2_t\n\nAll the Best!\n\n`ripred`",
      "author_fullname": "t2_adfkq",
      "saved": false,
      "mod_reason_title": null,
      "gilded": 0,
      "clicked": false,
      "title": "MicroChess Update: Money for Nothing..",
      "link_flair_richtext": [],
      "subreddit_name_prefixed": "r/arduino",
      "hidden": false,
      "pwls": 6,
      "link_flair_css_class": null,
      "downs": 0,
      "thumbnail_height": null,
      "top_awarded_type": null,
      "hide_score": false,
      "name": "t3_125ezne",
      "quarantine": false,
      "link_flair_text_color": "dark",
      "upvote_ratio": 0.5,
      "author_flair_background_color": "#00a6a5",
      "subreddit_type": "public",
      "ups": 0,
      "total_awards_received": 0,
      "media_embed": {},
      "thumbnail_width": null,
      "author_flair_template_id": "5cb3c302-0ef5-11ed-b9fd-aab9a872a9c2",
      "is_original_content": false,
      "user_reports": [],
      "secure_media": null,
      "is_reddit_media_domain": false,
      "is_meta": false,
      "category": null,
      "secure_media_embed": {},
      "link_flair_text": null,
      "can_mod_post": false,
      "score": 0,
      "approved_by": null,
      "is_created_from_ads_ui": false,
      "author_premium": false,
      "thumbnail": "self",
      "edited": 1680083137.0,
      "author_flair_css_class": null,
      "author_flair_richtext": [
        {
          "a": ":400K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/apsbyvbwmfe91_t5_2qknj/400K"
        },
        {
          "a": ":Arduino_500k:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/o5qzzwwkvk5a1_t5_2qknj/Arduino_500k"
        },
        {
          "a": ":600K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/z23hxjk4hpeb1_t5_2qknj/600K"
        },
        {
          "a": ":640K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/g9r24xjaydqc1_t5_2qknj/640K"
        },
        {
          "e": "text",
          "t": " My other dev board is a Porsche"
        }
      ],
      "gildings": {},
      "content_categories": null,
      "is_self": true,
      "mod_note": null,
      "created": 1680070319.0,
      "link_flair_type": "text",
      "wls": 6,
      "removed_by_category": null,
      "banned_by": null,
      "author_flair_type": "richtext",
      "domain": "self.arduino",
      "allow_live_comments": false,
      "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This is the 4th post in a series about writing a chess engine for the Arduino platform. Here are &lt;a href=\"https://www.reddit.com/r/arduino/comments/11q4916/so_you_want_to_build_a_chess_engine/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;the first&lt;/a&gt;, &lt;a href=\"https://www.reddit.com/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;second&lt;/a&gt; and &lt;a href=\"https://www.reddit.com/r/arduino/comments/123f5q3/microchess_move_evaluation_function/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;third&lt;/a&gt; posts.&lt;/p&gt;\n\n&lt;p&gt;This is a quick update about some of the data structure and algorithmic changes that I am making as I clean up the program and implement the minimax algorithm. I came up with this structure yesterday and it works extremely well in terms of the speed improvements and the reduction of the RAM requirements of the program.&lt;/p&gt;\n\n&lt;p&gt;Throughout the code there are a lot of places where we need to convert from the board index (0-63) and the row and column that the location represents using one or more of these formulas:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    // convert a column and row into a board index\n    index = col + row * 8;\n\n    // convert a board index to the column\n    col = index % 8;\n    // or \n    col = index &amp;amp; 7;\n\n    // convert a board index to the row\n    col = index / 8;\n    // or \n    col = (index &amp;gt;&amp;gt; 3) &amp;amp; 7;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So the code is full of places where all 3 variables (&lt;code&gt;index&lt;/code&gt;, &lt;code&gt;col&lt;/code&gt;, and &lt;code&gt;row&lt;/code&gt;) are needed just in order to calculate these values. This also takes up extra stack space or executes calculations that I wish I didn&amp;#39;t have to pay for in terms of the memory used and the additional runtime execution. So I came up with this data structure:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/**\n * @brief conv1_t struct represents a single chess piece location in 8 bits.\n * \n * The struct cleverly packs the data for a chess piece location into 2 bytes. It\n * uses a union of two structures to allow for easy access to the data in two\n * different formats. The first structure, pt, is a bitfield that is laid out as\n * \u2020 follows:\n * \n *   0   1   2   3   4   5   6   7   8   9\n * +---+---+---+---+---+---+---+---+---+------+\n * |    col    |    row    |   type    | side |\n * +---+---+---+---+---+---+---+---+---+------+\n * \n * The second structure, ndx, is laid out as follows:\n * \n *   0   1   2   3   4   5   6   7   8   9\n * +---+---+---+---+---+---+---+---+---+------+\n * |          index        |   type    | side |\n * +---+---+---+---+---+---+---+---+---+------+\n * \n * The idea behind the design is that the col and row fields are easily accessed\n * when scanning the chess board in row-major order, while the index field is\n * easily accessed when looping over an array of pieces. Additionally, assigning\n * to the col, row, or index fields automatically / magically performs the\n * calculations `index = col + row * 8` and `col = ndx % 8, row = index / 8`\n * implicitly, thanks to the clever use of the union and the resulting alignment\n * of the bitfields!\n * \n * Let me say that again: The math and conversion between the (col,row)\n * pairs and the 0 - 63 index automatically happens without having to apply\n * the `index = col + row * 8`, `col = index % 8`, or the `row = index / 8`\n * expressions! To understand this realize that dividing by 8 or multiplying by\n * 8 is the same operation as shifting a value 3 bits up or down. By aligning\n * the bitfields the way we are, we are forcing the 3 bits that store the row\n * to implicitly be 3 bits to the left of the col bitfield when viewed from\n * perspective of the ndx.index field! Man I love programming haha, and binary\n * numbers are cool!\n * \n * The struct provides a set of getter and setter methods to safely access the\n * bit fields, as well as constructors to initialize the values of the fields.\n * \n * Forcing all access to go through the the setters and getters is not just \n * there to ensure that the fields cannot be accessed except through the \n * methods; they serve a higher purpose. All bitfields should be able to be\n * accessed in two\u00a7 bitwise assembly instructions: A shift operation (&amp;lt;&amp;lt; or &amp;gt;&amp;gt;)\n * and a masking AND instruction. By providing these accessors we guarantee \n * that all code produced by the compiler will use two assembly instructions per\n * access worst-case when accessing any of these fields. Without this it is\n * possible for the compiler to generate some inefficient code such as loading\n * the entire structure into memory just to perform an operation on one of the\n * fields and then throwing the temporary stack object away.\n * \n * \u2020 The actual layout with respect to the order of the fields in memory is\n * up to the compiler based on the processor architecture. The intent and\n * optimal storage is still achieved however regardless of the order in\n * physical memory.\n * \n * \u00a7 actually to be technically accurate, worst-case it could take 4\n * instructions if the value was split across byte boundaries in memory\n * requiring access to two separate memory locations.\n */\nstruct conv1_t {\nprivate:\n\n    union {\n        struct {\n            uint8_t     col : 3,    ///&amp;lt; The column value of the position.\n                        row : 3,    ///&amp;lt; The row value of the position.\n                       type : 3,    ///&amp;lt; The type of piece (pawn, knight, etc.) at the position.\n                       side : 1;    ///&amp;lt; The side (white or black) of the piece at the position.\n        } pt;                       ///&amp;lt; A struct used to compactly store the values and to access \n                                    ///  the member fields of the union in a type-safe manner.\n        struct {\n            uint8_t   index : 6,    ///&amp;lt; The index of the position in the board array.\n                       type : 3,    ///&amp;lt; The type of piece (pawn, knight, etc.) at the position.\n                       side : 1;    ///&amp;lt; The side (white or black) of the piece at the position.\n        } ndx;                      ///&amp;lt; A struct used to compactly store the values and to access \n                                    ///  the member fields of the union in a type-safe manner.\n    } u;                            ///&amp;lt; A union used to store the position information in two \n                                    ///  different ways, for different use cases.\npublic:\n\n    conv1_t() : u{ 0, 0, Empty, Black } {}\n\n    conv1_t(uint8_t index) {\n        u.ndx.index = index;\n        u.ndx.type = Empty;\n        u.ndx.side = Black;\n    }\n\n    conv1_t(uint8_t index, uint8_t type, uint8_t side) {\n        u.ndx.index = index;\n        u.ndx.type = type;\n        u.ndx.side = side;\n    }\n\n    conv1_t(uint8_t col, uint8_t row) : u{ col, row, Empty, Black } {}\n\n    /**\n    * @brief Setters for the structure.\n    * \n    */\n    void set_index(uint8_t value) { u.ndx.index = value; }\n    void set_col(uint8_t value) { u.pt.col = value; }\n    void set_row(uint8_t value) { u.pt.row = value; }\n    void set_type(uint8_t value) { u.pt.type = u.ndx.type = value; }\n    void set_side(uint8_t value) { u.pt.side = u.ndx.side = value; }\n\n    /**\n    * @brief Getters for the structure.\n    * \n    */\n    uint8_t get_index() const { return u.ndx.index; }\n    uint8_t get_col() const { return u.pt.col; }\n    uint8_t get_row() const { return u.pt.row; }\n    uint8_t get_type() const { return u.pt.type; }\n    uint8_t get_side() const { return u.pt.side; }\n\n};  // conv1_t\n\n\n/**\n * @brief Struct representing a chess move.\n * \n * The struct contains two `conv1_t` members, `from` and `to`, representing the\n * starting and ending positions of the move, respectively.\n */\nstruct conv2_t {\nprivate:\n    conv1_t   from, to;\n\npublic:\n\n    conv2_t() : from(), to() {}\n    conv2_t(uint8_t from_index, uint8_t to_index)\n        : from(from_index), to(to_index) {}\n    conv2_t(uint8_t from_col, uint8_t from_row, uint8_t to_col, uint8_t to_row)\n        : from(from_col, from_row), to(to_col, to_row) {}\n    conv2_t(const conv1_t&amp;amp; from_, const conv1_t&amp;amp; to_)\n        : from(from_), to(to_) {}\n\n    void set_from_index(uint8_t value) { from.set_index(value); }\n    void set_from_col(uint8_t value) { from.set_col(value); }\n    void set_from_row(uint8_t value) { from.set_row(value); }\n    void set_from_type(uint8_t value) { from.set_type(value); }\n    void set_from_side(uint8_t value) { from.set_side(value); }\n\n    void set_to_index(uint8_t value) { to.set_index(value); }\n    void set_to_col(uint8_t value) { to.set_col(value); }\n    void set_to_row(uint8_t value) { to.set_row(value); }\n    void set_to_type(uint8_t value) { to.set_type(value); }\n    void set_to_side(uint8_t value) { to.set_side(value); }\n\n    uint8_t get_from_index() const { return from.get_index(); }\n    uint8_t get_from_col() const { return from.get_col(); }\n    uint8_t get_from_row() const { return from.get_row(); }\n    uint8_t get_from_type() const { return from.get_type(); }\n    uint8_t get_from_side() const { return from.get_side(); }\n\n    uint8_t get_to_index() const { return to.get_index(); }\n    uint8_t get_to_col() const { return to.get_col(); }\n    uint8_t get_to_row() const { return to.get_row(); }\n    uint8_t get_to_type() const { return to.get_type(); }\n    uint8_t get_to_side() const { return to.get_side(); }\n\n};  // conv2_t\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;All the Best!&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ripred&lt;/code&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
      "likes": null,
      "suggested_sort": "confidence",
      "banned_at_utc": null,
      "view_count": null,
      "archived": false,
      "no_follow": true,
      "is_crosspostable": false,
      "pinned": false,
      "over_18": false,
      "all_awardings": [],
      "awarders": [],
      "media_only": false,
      "can_gild": false,
      "spoiler": false,
      "locked": false,
      "author_flair_text": ":400K::Arduino_500k::600K::640K: My other dev board is a Porsche",
      "treatment_tags": [],
      "visited": false,
      "removed_by": null,
      "num_reports": null,
      "distinguished": null,
      "subreddit_id": "t5_2qknj",
      "author_is_blocked": false,
      "mod_reason_by": null,
      "removal_reason": null,
      "link_flair_background_color": "",
      "id": "125ezne",
      "is_robot_indexable": true,
      "report_reasons": null,
      "author": "ripred3",
      "discussion_type": null,
      "num_comments": 10,
      "send_replies": true,
      "contest_mode": false,
      "mod_reports": [],
      "author_patreon_flair": false,
      "author_flair_text_color": "light",
      "permalink": "/r/arduino/comments/125ezne/microchess_update_money_for_nothing/",
      "stickied": false,
      "url": "https://www.reddit.com/r/arduino/comments/125ezne/microchess_update_money_for_nothing/",
      "subreddit_subscribers": 691355,
      "created_utc": 1680070319.0,
      "num_crossposts": 6,
      "media": null,
      "is_video": false
    }
  ],
  "created": 1680070794.0,
  "link_flair_type": "text",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "text",
  "domain": "self.arduino",
  "allow_live_comments": false,
  "selftext_html": null,
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "url_overridden_by_dest": "/r/arduino/comments/125ezne/microchess_update_money_for_nothing/",
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": null,
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_7yd5re",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "",
  "id": "125f4lu",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "crosspost_parent": "t3_125ezne",
  "author_flair_text_color": null,
  "permalink": "/r/Arduino_AI/comments/125f4lu/microchess_update_money_for_nothing/",
  "stickied": false,
  "url": "/r/arduino/comments/125ezne/microchess_update_money_for_nothing/",
  "subreddit_subscribers": 3135,
  "created_utc": 1680070794.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}