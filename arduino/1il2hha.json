{
  "approved_at_utc": null,
  "subreddit": "arduino",
  "selftext": "I'm trying to build a select fire system for my nerf blaster using a solenoid to push the darts, an analog stick and [I2C SSD1306 OLED display ](https://www.amazon.com/dp/B079BN2J8V?ref=ppx_yo2ov_dt_b_fed_asin_title&amp;th=1)for a UI, with battery percentage getting measured by way of a voltage limiter. Here's the code:\n\n    #include#include &lt;Wire.h&gt;\n    #include &lt;Adafruit_GFX.h&gt;\n    #include &lt;Adafruit_SSD1306.h&gt;\n    \n    // Pin Definitions\n    const int solenoidPin = 6; // Assigned to D1 (GPIO6) on Seeed XIAO RP2040\n    const int buttonPin = 5;   // Assigned to D0 (GPIO5) on Seeed XIAO RP2040\n    const int analogStickX = 26; // Assigned to A0 (GPIO26) on Seeed XIAO RP2040\n    const int analogStickY = 27; // Assigned to A1 (GPIO27) on Seeed XIAO RP2040\n    const int batteryPin = 28; // A2 (GPIO28) on Seeed XIAO RP2040 for battery monitoring\n    \n    // Mode Variables\n    int mode = 0; // Current mode index\n    String modes[4] = {\"semi\", \"burst2\", \"burst3\", \"full\"}; // Firing modes\n    \n    // Rate of Fire (ROF) Variables\n    int delayMs = 20;\n    const int minDelay = 50; // Adjusted to set maximum ROF to 10.0 d/s\n    const int maxDelay = 200; // Maximum delay in milliseconds\n    \n    // Battery Monitoring Variables\n    const float R1 = 100000.0; // 100k\u03a9\n    const float R2 = 33000.0;  // 33k\u03a9\n    const float voltageDividerRatio = (R1 + R2) / R2;\n    const float batteryMaxVoltage = 12.6;\n    const float batteryMinVoltage = 9.0;\n    \n    // OLED Display Setup\n    Adafruit_SSD1306 display(128, 64, &amp;Wire, -1);\n    \n    // Interaction Timeout\n    unsigned long lastDebounceTime = 0;\n    const unsigned long debounceDelay = 200;\n    \n    void setup() {\n      pinMode(solenoidPin, OUTPUT);\n      pinMode(buttonPin, INPUT_PULLUP);\n      pinMode(batteryPin, INPUT);\n    \n      display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n      display.clearDisplay();\n      display.setTextSize(1);\n      \n      display.setCursor(20, 30);\n      display.println(\"HI, LET'S PLAY\");\n      display.display();\n      delay(2000);\n      display.clearDisplay();\n    }\n    \n    void loop() {\n      handleJoystickInput();\n      updateDisplay();\n      handleFullAutoMode();\n    }\n    \n    void handleJoystickInput() {\n      int analogXValue = analogRead(analogStickX);\n      int analogYValue = analogRead(analogStickY);\n      unsigned long currentMillis = millis();\n    \n      const int deadZone = 250;\n      const int center = 512;\n    \n      if (currentMillis - lastDebounceTime &gt; debounceDelay) {\n        if (analogYValue &gt; center + deadZone) {\n          mode = constrain(mode + 1, 0, 3);\n          lastDebounceTime = currentMillis;\n        } else if (analogYValue &lt; center - deadZone) {\n          mode = constrain(mode - 1, 0, 3);\n          lastDebounceTime = currentMillis;\n        }\n        if (analogXValue &gt; center + deadZone) {\n          delayMs = max(delayMs - 10, minDelay);\n          lastDebounceTime = currentMillis;\n        } else if (analogXValue &lt; center - deadZone) {\n          delayMs = min(delayMs + 10, maxDelay);\n          lastDebounceTime = currentMillis;\n        }\n      }\n    }\n    \n    void handleFullAutoMode() {\n      if (mode == 3 &amp;&amp; digitalRead(buttonPin) == LOW) {\n        while (digitalRead(buttonPin) == LOW) {\n          digitalWrite(solenoidPin, HIGH);\n          delay(delayMs);\n          digitalWrite(solenoidPin, LOW);\n          delay(delayMs);\n        }\n      }\n    }\n    \n    float getBatteryPercentage() {\n      int rawADC = analogRead(batteryPin);\n      float measuredVoltage = (rawADC / 4095.0) * 3.3;\n      float batteryVoltage = measuredVoltage * voltageDividerRatio;\n      float batteryPercent = ((batteryVoltage - batteryMinVoltage) / (batteryMaxVoltage - batteryMinVoltage)) * 100.0;\n      return constrain(batteryPercent, 0, 100);\n    }\n    \n    void updateDisplay() {\n      static int lastMode = -1;\n      static int lastDelayMs = -1;\n    \n      if (lastMode != mode || lastDelayMs != delayMs) {\n        lastMode = mode;\n        lastDelayMs = delayMs;\n    \n        float dartsPerSecond = 1000.0 / (delayMs * 2);\n        float batteryPercent = getBatteryPercentage();\n    \n        display.clearDisplay();\n        display.setTextSize(3);\n        display.setCursor(5, 55); display.print(\"MODE: \");\n        \n        display.setCursor(110, 55);\n        display.print(modes[mode]);\n    \n        display.setCursor(5, 35); display.print(\"ROF: \");\n        \n        display.setCursor(110, 35);\n        display.print(dartsPerSecond, 1);\n        display.print(\" d/s\");\n    \n        display.drawRect(100, 4, 20, 8, SSD1306_WHITE);\n        display.fillRect(120, 6, 2, 4, SSD1306_WHITE);\n        int batteryFillWidth = map((int)batteryPercent, 0, 100, 0, 18);\n        display.fillRect(102, 6, batteryFillWidth, 6, SSD1306_WHITE);\n        display.setCursor(85, 10);\n        if (batteryPercent &lt;= 20) {\n            \n        } else {\n            \n        }\n        display.print((int)batteryPercent);\n        display.print(\"%\");\n        display.display();\n      }\n    }\n    \n    \n     &lt;Wire.h&gt;\n    #include &lt;Adafruit_GFX.h&gt;\n    #include &lt;Adafruit_SSD1306.h&gt;\n    \n    // Pin Definitions\n    const int solenoidPin = 6; // Assigned to D1 (GPIO6) on Seeed XIAO RP2040\n    const int buttonPin = 5;   // Assigned to D0 (GPIO5) on Seeed XIAO RP2040\n    const int analogStickX = 26; // Assigned to A0 (GPIO26) on Seeed XIAO RP2040\n    const int analogStickY = 27; // Assigned to A1 (GPIO27) on Seeed XIAO RP2040\n    const int batteryPin = 28; // A2 (GPIO28) on Seeed XIAO RP2040 for battery monitoring\n    \n    // Mode Variables\n    int mode = 0; // Current mode index\n    String modes[4] = {\"semi\", \"burst2\", \"burst3\", \"full\"}; // Firing modes\n    \n    // Rate of Fire (ROF) Variables\n    int delayMs = 20;\n    const int minDelay = 50; // Adjusted to set maximum ROF to 10.0 d/s\n    const int maxDelay = 200; // Maximum delay in milliseconds\n    \n    // Battery Monitoring Variables\n    const float R1 = 100000.0; // 100k\u03a9\n    const float R2 = 33000.0;  // 33k\u03a9\n    const float voltageDividerRatio = (R1 + R2) / R2;\n    const float batteryMaxVoltage = 12.6;\n    const float batteryMinVoltage = 9.0;\n    \n    // OLED Display Setup\n    Adafruit_SSD1306 display(128, 64, &amp;Wire, -1);\n    \n    // Interaction Timeout\n    unsigned long lastDebounceTime = 0;\n    const unsigned long debounceDelay = 200;\n    \n    void setup() {\n      pinMode(solenoidPin, OUTPUT);\n      pinMode(buttonPin, INPUT_PULLUP);\n      pinMode(batteryPin, INPUT);\n    \n      display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n      display.clearDisplay();\n      display.setTextSize(1);\n      \n      display.setCursor(20, 30);\n      display.println(\"HI, LET'S PLAY\");\n      display.display();\n      delay(2000);\n      display.clearDisplay();\n    }\n    \n    void loop() {\n      handleJoystickInput();\n      updateDisplay();\n      handleFullAutoMode();\n    }\n    \n    void handleJoystickInput() {\n      int analogXValue = analogRead(analogStickX);\n      int analogYValue = analogRead(analogStickY);\n      unsigned long currentMillis = millis();\n    \n      const int deadZone = 250;\n      const int center = 512;\n    \n      if (currentMillis - lastDebounceTime &gt; debounceDelay) {\n        if (analogYValue &gt; center + deadZone) {\n          mode = constrain(mode + 1, 0, 3);\n          lastDebounceTime = currentMillis;\n        } else if (analogYValue &lt; center - deadZone) {\n          mode = constrain(mode - 1, 0, 3);\n          lastDebounceTime = currentMillis;\n        }\n        if (analogXValue &gt; center + deadZone) {\n          delayMs = max(delayMs - 10, minDelay);\n          lastDebounceTime = currentMillis;\n        } else if (analogXValue &lt; center - deadZone) {\n          delayMs = min(delayMs + 10, maxDelay);\n          lastDebounceTime = currentMillis;\n        }\n      }\n    }\n    \n    void handleFullAutoMode() {\n      if (mode == 3 &amp;&amp; digitalRead(buttonPin) == LOW) {\n        while (digitalRead(buttonPin) == LOW) {\n          digitalWrite(solenoidPin, HIGH);\n          delay(delayMs);\n          digitalWrite(solenoidPin, LOW);\n          delay(delayMs);\n        }\n      }\n    }\n    \n    float getBatteryPercentage() {\n      int rawADC = analogRead(batteryPin);\n      float measuredVoltage = (rawADC / 4095.0) * 3.3;\n      float batteryVoltage = measuredVoltage * voltageDividerRatio;\n      float batteryPercent = ((batteryVoltage - batteryMinVoltage) / (batteryMaxVoltage - batteryMinVoltage)) * 100.0;\n      return constrain(batteryPercent, 0, 100);\n    }\n    \n    void updateDisplay() {\n      static int lastMode = -1;\n      static int lastDelayMs = -1;\n    \n      if (lastMode != mode || lastDelayMs != delayMs) {\n        lastMode = mode;\n        lastDelayMs = delayMs;\n    \n        float dartsPerSecond = 1000.0 / (delayMs * 2);\n        float batteryPercent = getBatteryPercentage();\n    \n        display.clearDisplay();\n        display.setTextSize(3);\n        display.setCursor(5, 55); display.print(\"MODE: \");\n        \n        display.setCursor(110, 55);\n        display.print(modes[mode]);\n    \n        display.setCursor(5, 35); display.print(\"ROF: \");\n        \n        display.setCursor(110, 35);\n        display.print(dartsPerSecond, 1);\n        display.print(\" d/s\");\n    \n        display.drawRect(100, 4, 20, 8, SSD1306_WHITE);\n        display.fillRect(120, 6, 2, 4, SSD1306_WHITE);\n        int batteryFillWidth = map((int)batteryPercent, 0, 100, 0, 18);\n        display.fillRect(102, 6, batteryFillWidth, 6, SSD1306_WHITE);\n        display.setCursor(85, 10);\n        if (batteryPercent &lt;= 20) {\n            \n        } else {\n            \n        }\n        display.print((int)batteryPercent);\n        display.print(\"%\");\n        display.display();\n      }\n    }\n    \n    \n    \n\nWhen I connect everything up, or even just connect the OLED display up, nothing happens. I uploaded the Blink test program and it works just fine, and I can get power from 3V3/GND pins powering the breadboard, but I can't get the display or anything else to interact with the RP2040. \n\nHow can I troubleshoot this?",
  "author_fullname": "t2_ex8tn",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "How can I troubleshoot my XIAO RP2040 not interacting with anything I connect to its pins?",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Hardware Help"
    }
  ],
  "subreddit_name_prefixed": "r/arduino",
  "hidden": false,
  "pwls": 6,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_1il2hha",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 0.67,
  "author_flair_background_color": null,
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": null,
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Hardware Help",
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [],
  "gildings": {},
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1739062062.0,
  "link_flair_type": "richtext",
  "wls": 6,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "text",
  "domain": "self.arduino",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I&amp;#39;m trying to build a select fire system for my nerf blaster using a solenoid to push the darts, an analog stick and &lt;a href=\"https://www.amazon.com/dp/B079BN2J8V?ref=ppx_yo2ov_dt_b_fed_asin_title&amp;amp;th=1\"&gt;I2C SSD1306 OLED display &lt;/a&gt;for a UI, with battery percentage getting measured by way of a voltage limiter. Here&amp;#39;s the code:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include#include &amp;lt;Wire.h&amp;gt;\n#include &amp;lt;Adafruit_GFX.h&amp;gt;\n#include &amp;lt;Adafruit_SSD1306.h&amp;gt;\n\n// Pin Definitions\nconst int solenoidPin = 6; // Assigned to D1 (GPIO6) on Seeed XIAO RP2040\nconst int buttonPin = 5;   // Assigned to D0 (GPIO5) on Seeed XIAO RP2040\nconst int analogStickX = 26; // Assigned to A0 (GPIO26) on Seeed XIAO RP2040\nconst int analogStickY = 27; // Assigned to A1 (GPIO27) on Seeed XIAO RP2040\nconst int batteryPin = 28; // A2 (GPIO28) on Seeed XIAO RP2040 for battery monitoring\n\n// Mode Variables\nint mode = 0; // Current mode index\nString modes[4] = {&amp;quot;semi&amp;quot;, &amp;quot;burst2&amp;quot;, &amp;quot;burst3&amp;quot;, &amp;quot;full&amp;quot;}; // Firing modes\n\n// Rate of Fire (ROF) Variables\nint delayMs = 20;\nconst int minDelay = 50; // Adjusted to set maximum ROF to 10.0 d/s\nconst int maxDelay = 200; // Maximum delay in milliseconds\n\n// Battery Monitoring Variables\nconst float R1 = 100000.0; // 100k\u03a9\nconst float R2 = 33000.0;  // 33k\u03a9\nconst float voltageDividerRatio = (R1 + R2) / R2;\nconst float batteryMaxVoltage = 12.6;\nconst float batteryMinVoltage = 9.0;\n\n// OLED Display Setup\nAdafruit_SSD1306 display(128, 64, &amp;amp;Wire, -1);\n\n// Interaction Timeout\nunsigned long lastDebounceTime = 0;\nconst unsigned long debounceDelay = 200;\n\nvoid setup() {\n  pinMode(solenoidPin, OUTPUT);\n  pinMode(buttonPin, INPUT_PULLUP);\n  pinMode(batteryPin, INPUT);\n\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n  display.clearDisplay();\n  display.setTextSize(1);\n\n  display.setCursor(20, 30);\n  display.println(&amp;quot;HI, LET&amp;#39;S PLAY&amp;quot;);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n}\n\nvoid loop() {\n  handleJoystickInput();\n  updateDisplay();\n  handleFullAutoMode();\n}\n\nvoid handleJoystickInput() {\n  int analogXValue = analogRead(analogStickX);\n  int analogYValue = analogRead(analogStickY);\n  unsigned long currentMillis = millis();\n\n  const int deadZone = 250;\n  const int center = 512;\n\n  if (currentMillis - lastDebounceTime &amp;gt; debounceDelay) {\n    if (analogYValue &amp;gt; center + deadZone) {\n      mode = constrain(mode + 1, 0, 3);\n      lastDebounceTime = currentMillis;\n    } else if (analogYValue &amp;lt; center - deadZone) {\n      mode = constrain(mode - 1, 0, 3);\n      lastDebounceTime = currentMillis;\n    }\n    if (analogXValue &amp;gt; center + deadZone) {\n      delayMs = max(delayMs - 10, minDelay);\n      lastDebounceTime = currentMillis;\n    } else if (analogXValue &amp;lt; center - deadZone) {\n      delayMs = min(delayMs + 10, maxDelay);\n      lastDebounceTime = currentMillis;\n    }\n  }\n}\n\nvoid handleFullAutoMode() {\n  if (mode == 3 &amp;amp;&amp;amp; digitalRead(buttonPin) == LOW) {\n    while (digitalRead(buttonPin) == LOW) {\n      digitalWrite(solenoidPin, HIGH);\n      delay(delayMs);\n      digitalWrite(solenoidPin, LOW);\n      delay(delayMs);\n    }\n  }\n}\n\nfloat getBatteryPercentage() {\n  int rawADC = analogRead(batteryPin);\n  float measuredVoltage = (rawADC / 4095.0) * 3.3;\n  float batteryVoltage = measuredVoltage * voltageDividerRatio;\n  float batteryPercent = ((batteryVoltage - batteryMinVoltage) / (batteryMaxVoltage - batteryMinVoltage)) * 100.0;\n  return constrain(batteryPercent, 0, 100);\n}\n\nvoid updateDisplay() {\n  static int lastMode = -1;\n  static int lastDelayMs = -1;\n\n  if (lastMode != mode || lastDelayMs != delayMs) {\n    lastMode = mode;\n    lastDelayMs = delayMs;\n\n    float dartsPerSecond = 1000.0 / (delayMs * 2);\n    float batteryPercent = getBatteryPercentage();\n\n    display.clearDisplay();\n    display.setTextSize(3);\n    display.setCursor(5, 55); display.print(&amp;quot;MODE: &amp;quot;);\n\n    display.setCursor(110, 55);\n    display.print(modes[mode]);\n\n    display.setCursor(5, 35); display.print(&amp;quot;ROF: &amp;quot;);\n\n    display.setCursor(110, 35);\n    display.print(dartsPerSecond, 1);\n    display.print(&amp;quot; d/s&amp;quot;);\n\n    display.drawRect(100, 4, 20, 8, SSD1306_WHITE);\n    display.fillRect(120, 6, 2, 4, SSD1306_WHITE);\n    int batteryFillWidth = map((int)batteryPercent, 0, 100, 0, 18);\n    display.fillRect(102, 6, batteryFillWidth, 6, SSD1306_WHITE);\n    display.setCursor(85, 10);\n    if (batteryPercent &amp;lt;= 20) {\n\n    } else {\n\n    }\n    display.print((int)batteryPercent);\n    display.print(&amp;quot;%&amp;quot;);\n    display.display();\n  }\n}\n\n\n &amp;lt;Wire.h&amp;gt;\n#include &amp;lt;Adafruit_GFX.h&amp;gt;\n#include &amp;lt;Adafruit_SSD1306.h&amp;gt;\n\n// Pin Definitions\nconst int solenoidPin = 6; // Assigned to D1 (GPIO6) on Seeed XIAO RP2040\nconst int buttonPin = 5;   // Assigned to D0 (GPIO5) on Seeed XIAO RP2040\nconst int analogStickX = 26; // Assigned to A0 (GPIO26) on Seeed XIAO RP2040\nconst int analogStickY = 27; // Assigned to A1 (GPIO27) on Seeed XIAO RP2040\nconst int batteryPin = 28; // A2 (GPIO28) on Seeed XIAO RP2040 for battery monitoring\n\n// Mode Variables\nint mode = 0; // Current mode index\nString modes[4] = {&amp;quot;semi&amp;quot;, &amp;quot;burst2&amp;quot;, &amp;quot;burst3&amp;quot;, &amp;quot;full&amp;quot;}; // Firing modes\n\n// Rate of Fire (ROF) Variables\nint delayMs = 20;\nconst int minDelay = 50; // Adjusted to set maximum ROF to 10.0 d/s\nconst int maxDelay = 200; // Maximum delay in milliseconds\n\n// Battery Monitoring Variables\nconst float R1 = 100000.0; // 100k\u03a9\nconst float R2 = 33000.0;  // 33k\u03a9\nconst float voltageDividerRatio = (R1 + R2) / R2;\nconst float batteryMaxVoltage = 12.6;\nconst float batteryMinVoltage = 9.0;\n\n// OLED Display Setup\nAdafruit_SSD1306 display(128, 64, &amp;amp;Wire, -1);\n\n// Interaction Timeout\nunsigned long lastDebounceTime = 0;\nconst unsigned long debounceDelay = 200;\n\nvoid setup() {\n  pinMode(solenoidPin, OUTPUT);\n  pinMode(buttonPin, INPUT_PULLUP);\n  pinMode(batteryPin, INPUT);\n\n  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);\n  display.clearDisplay();\n  display.setTextSize(1);\n\n  display.setCursor(20, 30);\n  display.println(&amp;quot;HI, LET&amp;#39;S PLAY&amp;quot;);\n  display.display();\n  delay(2000);\n  display.clearDisplay();\n}\n\nvoid loop() {\n  handleJoystickInput();\n  updateDisplay();\n  handleFullAutoMode();\n}\n\nvoid handleJoystickInput() {\n  int analogXValue = analogRead(analogStickX);\n  int analogYValue = analogRead(analogStickY);\n  unsigned long currentMillis = millis();\n\n  const int deadZone = 250;\n  const int center = 512;\n\n  if (currentMillis - lastDebounceTime &amp;gt; debounceDelay) {\n    if (analogYValue &amp;gt; center + deadZone) {\n      mode = constrain(mode + 1, 0, 3);\n      lastDebounceTime = currentMillis;\n    } else if (analogYValue &amp;lt; center - deadZone) {\n      mode = constrain(mode - 1, 0, 3);\n      lastDebounceTime = currentMillis;\n    }\n    if (analogXValue &amp;gt; center + deadZone) {\n      delayMs = max(delayMs - 10, minDelay);\n      lastDebounceTime = currentMillis;\n    } else if (analogXValue &amp;lt; center - deadZone) {\n      delayMs = min(delayMs + 10, maxDelay);\n      lastDebounceTime = currentMillis;\n    }\n  }\n}\n\nvoid handleFullAutoMode() {\n  if (mode == 3 &amp;amp;&amp;amp; digitalRead(buttonPin) == LOW) {\n    while (digitalRead(buttonPin) == LOW) {\n      digitalWrite(solenoidPin, HIGH);\n      delay(delayMs);\n      digitalWrite(solenoidPin, LOW);\n      delay(delayMs);\n    }\n  }\n}\n\nfloat getBatteryPercentage() {\n  int rawADC = analogRead(batteryPin);\n  float measuredVoltage = (rawADC / 4095.0) * 3.3;\n  float batteryVoltage = measuredVoltage * voltageDividerRatio;\n  float batteryPercent = ((batteryVoltage - batteryMinVoltage) / (batteryMaxVoltage - batteryMinVoltage)) * 100.0;\n  return constrain(batteryPercent, 0, 100);\n}\n\nvoid updateDisplay() {\n  static int lastMode = -1;\n  static int lastDelayMs = -1;\n\n  if (lastMode != mode || lastDelayMs != delayMs) {\n    lastMode = mode;\n    lastDelayMs = delayMs;\n\n    float dartsPerSecond = 1000.0 / (delayMs * 2);\n    float batteryPercent = getBatteryPercentage();\n\n    display.clearDisplay();\n    display.setTextSize(3);\n    display.setCursor(5, 55); display.print(&amp;quot;MODE: &amp;quot;);\n\n    display.setCursor(110, 55);\n    display.print(modes[mode]);\n\n    display.setCursor(5, 35); display.print(&amp;quot;ROF: &amp;quot;);\n\n    display.setCursor(110, 35);\n    display.print(dartsPerSecond, 1);\n    display.print(&amp;quot; d/s&amp;quot;);\n\n    display.drawRect(100, 4, 20, 8, SSD1306_WHITE);\n    display.fillRect(120, 6, 2, 4, SSD1306_WHITE);\n    int batteryFillWidth = map((int)batteryPercent, 0, 100, 0, 18);\n    display.fillRect(102, 6, batteryFillWidth, 6, SSD1306_WHITE);\n    display.setCursor(85, 10);\n    if (batteryPercent &amp;lt;= 20) {\n\n    } else {\n\n    }\n    display.print((int)batteryPercent);\n    display.print(&amp;quot;%&amp;quot;);\n    display.display();\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When I connect everything up, or even just connect the OLED display up, nothing happens. I uploaded the Blink test program and it works just fine, and I can get power from 3V3/GND pins powering the breadboard, but I can&amp;#39;t get the display or anything else to interact with the RP2040. &lt;/p&gt;\n\n&lt;p&gt;How can I troubleshoot this?&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": "confidence",
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "95279390-51ce-11e9-887b-0e6f64f4557a",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": null,
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_2qknj",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#ffbb30",
  "id": "1il2hha",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "CallThatGoing",
  "discussion_type": null,
  "num_comments": 6,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": null,
  "permalink": "/r/arduino/comments/1il2hha/how_can_i_troubleshoot_my_xiao_rp2040_not/",
  "stickied": false,
  "url": "https://www.reddit.com/r/arduino/comments/1il2hha/how_can_i_troubleshoot_my_xiao_rp2040_not/",
  "subreddit_subscribers": 691347,
  "created_utc": 1739062062.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}