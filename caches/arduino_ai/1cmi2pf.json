{
  "approved_at_utc": null,
  "subreddit": "Arduino_AI",
  "selftext": "i have this PID control that i wanna use to stabilize a drone, idc about flight right now, i just want it to spin the motors at 50% speed and then add the PID output to the base speed \"\n\n    #include &lt;Adafruit_MPU6050.h&gt;\n    #include &lt;Adafruit_Sensor.h&gt;\n    #include &lt;Wire.h&gt;\n    #include &lt;ArduPID.h&gt;\n    \n    Adafruit_MPU6050 mpu;\n    \n    ArduPID controlRoll;\n    ArduPID controlPitch;\n    \n    double rollSP = 0;\n    double pitchSP = 0;\n    \n    double rollInput;\n    double pitchInput;\n    \n    double rollOutput;\n    double pitchOutput;\n    \n    // Initially set low PID values for smoother control\n    double rollP = 0.1;\n    double pitchP = 0.1;\n    \n    double rollI = 0.0;\n    double pitchI = 0.0;\n    \n    double rollD = 0.1;\n    double pitchD = 0.1;\n    \n    const int esc1Pin = 17;\n    const int esc2Pin = 5;\n    const int esc3Pin = 18;\n    const int esc4Pin = 19;\n    int valanMax = 950;\n    int valanMin = 450;\n    \n    void setup(void) {\n    \u00a0 Serial.begin(115200);\n    \u00a0 while (!Serial) {\n    \u00a0 \u00a0 delay(10); // Wait for serial monitor to open\n    \u00a0 }\n    \n    \u00a0 // Attempt communication with MPU6050\n    \u00a0 if (!mpu.begin()) {\n    \u00a0 \u00a0 Serial.println(\"Failed to find MPU6050 chip\");\n    \u00a0 \u00a0 while (1) {\n    \u00a0 \u00a0 \u00a0 delay(10);\n    \u00a0 \u00a0 }\n    \u00a0 }\n    \n    \u00a0 // Initial motor spin at slightly above minimum (adjust if needed)\n    \u00a0 analogWrite(esc1Pin, valanMin + 10);\n    \u00a0 analogWrite(esc2Pin, valanMax - (valanMin + 10));\n    \u00a0 analogWrite(esc3Pin, valanMin + 10);\n    \u00a0 analogWrite(esc4Pin, valanMax - (valanMin + 10));\n    \n    \u00a0 mpu.setAccelerometerRange(MPU6050_RANGE_16_G);\n    \u00a0 mpu.setGyroRange(MPU6050_RANGE_250_DEG);\n    \u00a0 mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);\n    \u00a0 Serial.println(\"\");\n    \u00a0 delay(100);\n    \n    \u00a0 pinMode(esc1Pin, OUTPUT);\n    \u00a0 pinMode(esc2Pin, OUTPUT);\n    \u00a0 pinMode(esc3Pin, OUTPUT);\n    \u00a0 pinMode(esc4Pin, OUTPUT);\n    \n    \u00a0 controlRoll.begin(&amp;rollInput,&amp;rollOutput,&amp;rollSP,rollP,rollI,rollD);\n    \u00a0 controlPitch.begin(&amp;pitchInput,&amp;pitchOutput,&amp;pitchSP,pitchP,pitchI,pitchD);\n    \n    \n    }\n    \n    void loop() {\n    \u00a0 // Base speed for 50% throttle with slight adjustment (optional)\n    \u00a0 const double baseSpeed = valanMin + (valanMax - valanMin) * 0.5 + 10;\n    \n    \u00a0 // Read sensor data\n    \u00a0 sensors_event_t a, g, temp;\n    \u00a0 mpu.getEvent(&amp;a, &amp;g, &amp;temp);\n    \n    \u00a0 // Calculate roll and pitch angles from accelerometer data\n    \u00a0 int gradosRoll = atan2(a.acceleration.y, a.acceleration.z) * RAD_TO_DEG;\n    \u00a0 int gradosPitch = atan2(-a.acceleration.x, a.acceleration.z) * RAD_TO_DEG;\n    \n    \u00a0 // Optional gyro drift compensation (adjust values as needed)\n    \u00a0 g.gyro.x = g.gyro.x + 0.01;\n    \u00a0 g.gyro.y = g.gyro.y + 0.085;\n    \n    \u00a0 // Set roll and pitch inputs for PID controller\n    \u00a0 rollInput = gradosRoll;\n    \u00a0 pitchInput = gradosPitch;\n    \n    \u00a0 // Perform PID calculations to determine motor adjustments\n    \u00a0 controlRoll.compute();\n    \u00a0 controlPitch.compute();\n    \n    \u00a0 // Calculate motor signal with base speed (adjusted for deadzone)\n    \u00a0 int motorSignal = map(rollOutput + pitchOutput + baseSpeed, -valanMax, valanMax, valanMin + 10, valanMax);\n    \n    \u00a0 // Constrain motor signal within valid ESC range\n    \u00a0 motorSignal = constrain(motorSignal, valanMin + 10, valanMax);\n    \n    \u00a0 // Set motor signals for each ESC with direction control\n    \u00a0 analogWrite(esc1Pin, motorSignal);\n    \u00a0 analogWrite(esc2Pin, valanMax - motorSignal);\n    \u00a0 analogWrite(esc3Pin, motorSignal);\n    \u00a0 analogWrite(esc4Pin, valanMax - motorSignal);\n    \n    \u00a0 // Uncomment for debugging (optional)\n    \u00a0 Serial.print(\"Grados Roll:\");\n    \u00a0 Serial.print(gradosRoll);\n    \u00a0 Serial.print(\" Grados Pitch:\");\n    \u00a0 Serial.print(gradosPitch);\n    \u00a0 Serial.print(\" senal motor:\");\n    \u00a0 Serial.println(motorSignal);\n    \u00a0 \n    \u00a0 delay(100);\n    }\n    \"\n    ",
  "author_fullname": "t2_i6zx9vnk",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "Motors arent spinning ",
  "link_flair_richtext": [],
  "subreddit_name_prefixed": "r/Arduino_AI",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": null,
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_1cmi2pf",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 1.0,
  "author_flair_background_color": null,
  "subreddit_type": "public",
  "ups": 2,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": null,
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": null,
  "can_mod_post": false,
  "score": 2,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [],
  "gildings": {},
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1715104472.0,
  "link_flair_type": "text",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "text",
  "domain": "self.Arduino_AI",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;i have this PID control that i wanna use to stabilize a drone, idc about flight right now, i just want it to spin the motors at 50% speed and then add the PID output to the base speed &amp;quot;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;lt;Adafruit_MPU6050.h&amp;gt;\n#include &amp;lt;Adafruit_Sensor.h&amp;gt;\n#include &amp;lt;Wire.h&amp;gt;\n#include &amp;lt;ArduPID.h&amp;gt;\n\nAdafruit_MPU6050 mpu;\n\nArduPID controlRoll;\nArduPID controlPitch;\n\ndouble rollSP = 0;\ndouble pitchSP = 0;\n\ndouble rollInput;\ndouble pitchInput;\n\ndouble rollOutput;\ndouble pitchOutput;\n\n// Initially set low PID values for smoother control\ndouble rollP = 0.1;\ndouble pitchP = 0.1;\n\ndouble rollI = 0.0;\ndouble pitchI = 0.0;\n\ndouble rollD = 0.1;\ndouble pitchD = 0.1;\n\nconst int esc1Pin = 17;\nconst int esc2Pin = 5;\nconst int esc3Pin = 18;\nconst int esc4Pin = 19;\nint valanMax = 950;\nint valanMin = 450;\n\nvoid setup(void) {\n\u00a0 Serial.begin(115200);\n\u00a0 while (!Serial) {\n\u00a0 \u00a0 delay(10); // Wait for serial monitor to open\n\u00a0 }\n\n\u00a0 // Attempt communication with MPU6050\n\u00a0 if (!mpu.begin()) {\n\u00a0 \u00a0 Serial.println(&amp;quot;Failed to find MPU6050 chip&amp;quot;);\n\u00a0 \u00a0 while (1) {\n\u00a0 \u00a0 \u00a0 delay(10);\n\u00a0 \u00a0 }\n\u00a0 }\n\n\u00a0 // Initial motor spin at slightly above minimum (adjust if needed)\n\u00a0 analogWrite(esc1Pin, valanMin + 10);\n\u00a0 analogWrite(esc2Pin, valanMax - (valanMin + 10));\n\u00a0 analogWrite(esc3Pin, valanMin + 10);\n\u00a0 analogWrite(esc4Pin, valanMax - (valanMin + 10));\n\n\u00a0 mpu.setAccelerometerRange(MPU6050_RANGE_16_G);\n\u00a0 mpu.setGyroRange(MPU6050_RANGE_250_DEG);\n\u00a0 mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);\n\u00a0 Serial.println(&amp;quot;&amp;quot;);\n\u00a0 delay(100);\n\n\u00a0 pinMode(esc1Pin, OUTPUT);\n\u00a0 pinMode(esc2Pin, OUTPUT);\n\u00a0 pinMode(esc3Pin, OUTPUT);\n\u00a0 pinMode(esc4Pin, OUTPUT);\n\n\u00a0 controlRoll.begin(&amp;amp;rollInput,&amp;amp;rollOutput,&amp;amp;rollSP,rollP,rollI,rollD);\n\u00a0 controlPitch.begin(&amp;amp;pitchInput,&amp;amp;pitchOutput,&amp;amp;pitchSP,pitchP,pitchI,pitchD);\n\n\n}\n\nvoid loop() {\n\u00a0 // Base speed for 50% throttle with slight adjustment (optional)\n\u00a0 const double baseSpeed = valanMin + (valanMax - valanMin) * 0.5 + 10;\n\n\u00a0 // Read sensor data\n\u00a0 sensors_event_t a, g, temp;\n\u00a0 mpu.getEvent(&amp;amp;a, &amp;amp;g, &amp;amp;temp);\n\n\u00a0 // Calculate roll and pitch angles from accelerometer data\n\u00a0 int gradosRoll = atan2(a.acceleration.y, a.acceleration.z) * RAD_TO_DEG;\n\u00a0 int gradosPitch = atan2(-a.acceleration.x, a.acceleration.z) * RAD_TO_DEG;\n\n\u00a0 // Optional gyro drift compensation (adjust values as needed)\n\u00a0 g.gyro.x = g.gyro.x + 0.01;\n\u00a0 g.gyro.y = g.gyro.y + 0.085;\n\n\u00a0 // Set roll and pitch inputs for PID controller\n\u00a0 rollInput = gradosRoll;\n\u00a0 pitchInput = gradosPitch;\n\n\u00a0 // Perform PID calculations to determine motor adjustments\n\u00a0 controlRoll.compute();\n\u00a0 controlPitch.compute();\n\n\u00a0 // Calculate motor signal with base speed (adjusted for deadzone)\n\u00a0 int motorSignal = map(rollOutput + pitchOutput + baseSpeed, -valanMax, valanMax, valanMin + 10, valanMax);\n\n\u00a0 // Constrain motor signal within valid ESC range\n\u00a0 motorSignal = constrain(motorSignal, valanMin + 10, valanMax);\n\n\u00a0 // Set motor signals for each ESC with direction control\n\u00a0 analogWrite(esc1Pin, motorSignal);\n\u00a0 analogWrite(esc2Pin, valanMax - motorSignal);\n\u00a0 analogWrite(esc3Pin, motorSignal);\n\u00a0 analogWrite(esc4Pin, valanMax - motorSignal);\n\n\u00a0 // Uncomment for debugging (optional)\n\u00a0 Serial.print(&amp;quot;Grados Roll:&amp;quot;);\n\u00a0 Serial.print(gradosRoll);\n\u00a0 Serial.print(&amp;quot; Grados Pitch:&amp;quot;);\n\u00a0 Serial.print(gradosPitch);\n\u00a0 Serial.print(&amp;quot; senal motor:&amp;quot;);\n\u00a0 Serial.println(motorSignal);\n\u00a0 \n\u00a0 delay(100);\n}\n&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": null,
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_7yd5re",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "",
  "id": "1cmi2pf",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "Business-Constant540",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": null,
  "permalink": "/r/Arduino_AI/comments/1cmi2pf/motors_arent_spinning/",
  "stickied": false,
  "url": "https://www.reddit.com/r/Arduino_AI/comments/1cmi2pf/motors_arent_spinning/",
  "subreddit_subscribers": 3137,
  "created_utc": 1715104472.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}