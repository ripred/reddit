{
  "approved_at_utc": null,
  "subreddit": "Arduino_AI",
  "selftext": "",
  "user_reports": [],
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "MicroChess - Move Evaluation Function",
  "link_flair_richtext": [],
  "subreddit_name_prefixed": "r/Arduino_AI",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": null,
  "downs": 0,
  "thumbnail_height": 68,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_123f6we",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 1.0,
  "author_flair_background_color": null,
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": 140,
  "author_flair_template_id": null,
  "is_original_content": false,
  "author_fullname": "t2_adfkq",
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": null,
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "https://b.thumbs.redditmedia.com/kBgsdgT7GpDx-ecdqVFLnppPH_wbrIwVEb9YH5mQLfY.jpg",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [],
  "gildings": {},
  "content_categories": null,
  "is_self": false,
  "mod_note": null,
  "crosspost_parent_list": [
    {
      "approved_at_utc": null,
      "subreddit": "arduino",
      "selftext": "This is post #3 in a series about writing a chess engine for the Arduino platform. Here are [the first](https://www.reddit.com/r/arduino/comments/11q4916/so_you_want_to_build_a_chess_engine/?utm_source=share&amp;utm_medium=web2x&amp;context=3) and [the second](https://www.reddit.com/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/?utm_source=share&amp;utm_medium=web2x&amp;context=3) posts and [here is the next one](https://www.reddit.com/r/arduino/comments/125ezne/microchess_update_money_for_nothing/?utm_source=share&amp;utm_medium=web2x&amp;context=3). The main point of this post is to go over the evaluation function that is used to rate and decide every move the engine makes. First an update on the progress since a ton has been added in the two weeks since I started:\n\n* **All** of the pieces have been implemented. By the last post only the pawns and the knights were implemented but now the rook, bishop, queen, and king have also been added. All of the transposition tables for the move offsets are stored in flash memory using the `PROGMEM` directive and retrieved as needed in order to minimize the use of RAM. All piece types can be individually enabled or disabled for debugging. The code is repetitive at the moment and needs to be [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) cleaned which will happen soon and will reduce the program size. And speaking of debugging..\n* Added a level-based, variable argument, runtime controllable `printf(...)` like output system. This cleaned up the code a whole bunch as there were lots of commented out `Serial.print()` statements left behind as things were fixed. Everything in the output is controlled by individual levels of verbosity. The code is clear and readable and the strings are stored in flash memory behind the scenes [using variadic macros](https://www.reddit.com/r/arduino/comments/1224r94/question_about_making_a_better_variable_argument/?utm_source=share&amp;utm_medium=web2x&amp;context=3) and the strings are read back as needed to keep memory use at a minimum. The storage using `PROGMEM` happens naturally and automatically without the user needing to declare anything as such and litter the code. The output level can range from `Everything` to `Nothing` with many choices of `Debug1, Debug2` &amp;c. in between. Setting the output to `Nothing` allows timings to be measured without them including the `Serial` I/O overhead. Speaking of which..\n* Added a *profiling and statistics* class that tracks the number of *moves evaluated per second* during the entire game as well as on individual turns. The first version that supported this evaluated about 360 moves a second which I thought was pretty decent for an Arduino Nano running at 16MHz. The current version evaluates *over* *~~1,200~~* *1,900 moves a second on the same Nano*. \ud83d\ude01\n* Added the *move and board evaluation function* `evaluate(Color side)`. This function rates and gives a static score for any board configuration or layout of pieces so that the moves that lead up to that board can be given a value. It is also *the most called function in the whole program* so it better be quick. That's what this post is about.\n* Added the `make_move(...)` function which gives the ability to make the moves on the board that were generated by the pieces and to optionally take the move back and restore the board to the state before the move was made, but only ***after*** we call the `evaluate(side)` function to see what the value of the move accomplishes.\n* Added the `play_game()` function that calls all of the above mentioned functions to get the best move, and changes sides. Sets `game.done` when one or both sides have no moves available.\n* The use of random is easily controlled in the game and the seed value is tracked which allows bugs to be duplicated until they resolved and then the use of random can be turned back on. This is also used in tandem with the profiling system.\n* All data types used throughout the program are program defined and controlled with extensive use of bitfields. Some of the code was examined in assembly to decide how to structure and iterate through the game. With the use of random turned off and playing against itself *the program makes it 165 moves into the game in 3 seconds before a bug stops things*.\n* The program compiles cleanly now with 0 warnings and 0 errors on every build (with warnings turned up to show all):\n\n&amp;#x200B;\n\n    Sketch uses 18258 bytes (59%) of program storage space. Maximum is 30720 \n    bytes.\n    Global variables use 1449 bytes (70%) of dynamic memory, leaving 599 bytes \n    for local variables. Maximum is 2048 bytes.\n\nAnd that's with 106 moves stored for each side. And that will go away for the most part on the last (and next) big update to the engine *that implements the minimax algorithm*. And that will leave tons of room for the additional libraries used for controlling the physical or visual versions of the games by the Arduino or other microcontroller. I'm curious to run this on an ESP32 to see the speed changes and play with having more headroom for memory. \\*Or maybe I'll get in the early adopter program for the new R4 Uno board, hint hint u/mbanzi lol.\n\n# The evaluate(...) function\n\nThe `evaluate(Color side)` function is called dozens of times on every move made so it has to be fast. *It is the most called function in the program.* On my first engine awhile back I knew I wanted something I could calculate extremely fast using only metrics that mattered. Everything had to be symetrical in that it would evenly reward and punish either side for a given move. So the 3 things I decided on were:\n\n* **Material values**. These are the *relative individual chess pieces values* (\\* 10,000) ranked by [the conventional relative values used by most chess engines](https://www.chess.com/terms/chess-piece-value). `White` piece values are added to the score and `Black` piece values are subtracted from the score. So at the beginning of the game the values from both sides should cancel out and the board will have a value of 0. The `King`'s value is set waaaay above every other piece value. Hence a board more favorable for the **white side will be positive** and a board more favorable for the **black side will be negative**. The material value can be scaled up or down separately from the other metrics to control it's relative influence. More valuable material moves will have more pieces on the board for our side or take away pieces from the other side *after* the move when compared to other moves.\n* **Proximity to the center**. This is simply a 0 - 3 value in all 4 directions which rewards pieces that are closer to the center of the board (except the King! \ud83d\ude02). The sum of the this is then multiplied by the `Type`; so stronger pieces gravitate towards the center of the board. Like the material score, the proximity to center can be separately scaled to control it's influence relative to the other metrics. Also like the other metrics we do this for every move for every piece on each move, so if our opponent gets closer to the center we see that reflected in the evaluation just in the opposite direction of what our side wants. This symetry in the evaluation makes us work towards eliminating those future moves and stopping them by choosing moves for our side that eliminate them. It takes awhile to learn to think about all of the future evaluations having already taken place. It's sort of like writing blockchain code that relies on future promises already being met kind of thing.\n* **Mobility**. This metric rewards board configurations *that result in more moves* being available to our side and/or fewer moves being available to our opponent after the move is made. Because the metric requires knowing how many future moves were enabled or disabled because of the last move and comparing it to the current number of moves; the use of this metric is tricky and can only be used *on the way back* (*so to speak. I'm not sure that I will actually make it recursive; I may unroll it to have deterministic control over the memory used*) from future calls that evaluate the moves made in response to the last move. Since [the minimax algorithm](https://en.wikipedia.org/wiki/Minimax) is not in place yet we don't examine any responses to our moves yet so the current engine plays out a dumb and greedy game. It also makes moves that place our own King in check or fail to respond when our King is in check but that will fall away in the next update. Things get really interesting when several pawns on both sides make it to the last rows and are auto-promoted to queens!\n\nAnd it's really that simple. An arrangement of pieces that reward one or more of those three things is treated as more valuable. So when all of the moves have been generated for all of the pieces, and then each move is made on the board and the evaluation function is called, then the move is undone and the board is restored. Moves that subtract from the other side's material or that move us closer to controlling the center of the board are scored higher. Then we just do a `qsort()` on the moves using a comparison lambda function that rewards higher values if the current side is white or if the current side is black it sorts things in reverse so that the most negative values are ranked higher. Then we pick the highest value move as our next move and make it for real on the board and we change to the other sides's turn. Actually to mix things up we pick a random move from all of the top moves that have the same score. That's it! It's actually very simple. A different evaluation function might be designed if you were using this engine to make a checkers game.\n\nAs mentioned the mobility metric is turned off at the moment but you can enable it and experiment with it to see it's influence. And without further ado here is the ~~current~~ updated `evaluate(Color side)` function:\n\n    long evaluate(Color side) \n    {\n        // flags choices for which attributes are included in the board score\n        static uint8_t const material = 0x01u;\n        static uint8_t const   center = 0x02u;\n        static uint8_t const mobility = 0x04u;\n    \n        static uint8_t const filter = material | center;\n    \n        // calculate the value of the board\n        long materialTotal = 0L;\n        long mobilityTotal = 0L;\n        long centerTotal = 0L;\n        long score = 0L;\n    \n        // iterate over the pieces on the board if necessary\n        if (filter &amp; (material | center)) {\n            for (\n                index_t piece_index = 0; \n                piece_index &lt; game.piece_count; \n                piece_index++) {\n                index_t const col = game.pieces[piece_index].x;\n                index_t const row = game.pieces[piece_index].y;\n                Piece   const p = board.get(col + row * 8);\n                Piece   const ptype = getType(p);\n                Color   const pside = getSide(p);\n    \n                if (filter &amp; material) {\n                    // now uses pre-computed material bonus table for speed!\n                    materialTotal += \n                        pgm_read_dword(&amp;material_bonus[ptype][pside]);\n                }\n    \n                if (filter &amp; center) { \n                    // now uses pre-computed center bonus table for speed!\n                    centerTotal += (King == ptype) ? 0 :\n                        pgm_read_dword(&amp;center_bonus[col][ptype][pside]) + \n                        pgm_read_dword(&amp;center_bonus[row][ptype][pside]);\n                }\n            }\n        }\n    \n        if (filter &amp; mobility) {\n            long sideFactor = (Black == side) ? -1 : 1;\n            mobilityTotal += \n            static_cast&lt;long&gt;(game.move_count1 * mobilityBonus * sideFactor);\n            mobilityTotal -= \n            static_cast&lt;long&gt;(game.move_count2 * mobilityBonus * sideFactor);\n        }\n    \n        score = materialTotal + centerTotal + mobilityTotal;\n    \n        printf(Debug4, \n            \"evaluation: %ld = centerTotal: %ld  \"\n            \"materialTotal: %ld  mobilityTotal: %ld\\n\", \n            score, centerTotal, materialTotal, mobilityTotal);\n    \n        return score;\n    }\n\nedit: [Here is the github repo of the current version](https://github.com/ripred/MicroChess)\n\nand here's the current look of the serial output:\n\n    Move #52: Black Pawn from: 2,4 (C4) to: 3,5 (D3) taking a White Pawn\n    White King is in check!\n    \n    0  *  .  *  .  k  .  *  r     Last Move: C4 to D3\n    1  .  *  .  *  .  *  b  p     Time spent: 76 ms\n    2  *  .  *  .  *  .  *  p     Moves evaluated: 82\n    3  .  *  .  *  p  *  .  * \n    4  *  p  *  .  *  p  *  .     Taken 1: n n b q r p p \n    5  .  *  K  p  .  *  .  P     Taken 2: P B P P N P P \n    6  *  .  *  .  P  P  B  . \n    7  .  *  .  *  R  Q  N  R     Board value:      800 White's favor\n       0  1  2  3  4  5  6  7\n    \n    and:\n    \n    starting..\n    \n    game hash: 0x232F89A3, profiling...\n    finished.\n    \n    0  *  .  *  .  *  .  *  .     Last Move: F1 to G1\n    1  .  *  .  k  .  *  .  *     Time spent: 16 ms\n    2  *  .  *  .  *  .  *  .     Moves evaluated: 50\n    3  .  *  .  *  .  *  .  p \n    4  *  .  *  .  *  .  *  p     Taken 1: n n b q r p p p p p q b r \n    5  .  *  .  *  K  *  .  P     Taken 2: P B P P N P P P Q B N \n    6  *  .  *  .  *  P  *  . \n    7  .  *  .  *  .  *  R  R     Board value:      550 White's favor\n       0  1  2  3  4  5  6  7\n    \n    ======================================================================\n               total game time:   5.3180 seconds\n               number of moves: 125\n    total game moves evaluated: 10,277\n      average moves per second: 1932.4935 \n       max move count per turn: 39\n\nPlease ask any questions you have about the way the engine works, what's next, or of course any bugs you catch! There's one that I know of currently but I'm on the hunt.\n\nupdate: [the current version is running online for free at arduino.cc's IoT Cloud at this link](https://create.arduino.cc/editor/Ripred/ba021340-bf68-4bd8-ac7b-d0d25144dcce/preview):\n\n[MicroChess running online at arduino.cc](https://preview.redd.it/6ag0m1p90cqa1.png?width=5120&amp;format=png&amp;auto=webp&amp;s=fb682a766d82d2f242fb8e4c63aee30a4014ad34)\n\nCheers,\n\n`ripred`",
      "author_fullname": "t2_adfkq",
      "saved": false,
      "mod_reason_title": null,
      "gilded": 0,
      "clicked": false,
      "title": "MicroChess - Move Evaluation Function",
      "link_flair_richtext": [],
      "subreddit_name_prefixed": "r/arduino",
      "hidden": false,
      "pwls": 6,
      "link_flair_css_class": null,
      "downs": 0,
      "thumbnail_height": 68,
      "top_awarded_type": null,
      "hide_score": false,
      "media_metadata": {
        "6ag0m1p90cqa1": {
          "status": "valid",
          "e": "Image",
          "m": "image/png",
          "p": [
            {
              "y": 52,
              "x": 108,
              "u": "https://preview.redd.it/6ag0m1p90cqa1.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=2dd343c1f06c641c4cdb397b9b879808879d6fee"
            },
            {
              "y": 105,
              "x": 216,
              "u": "https://preview.redd.it/6ag0m1p90cqa1.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=5c1fb8944fb7dfa264759e2e5c13e6cccaea4ee7"
            },
            {
              "y": 156,
              "x": 320,
              "u": "https://preview.redd.it/6ag0m1p90cqa1.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=254ad4526206c45d7f8cabf3f7ffe91af3c02d0b"
            },
            {
              "y": 312,
              "x": 640,
              "u": "https://preview.redd.it/6ag0m1p90cqa1.png?width=640&amp;crop=smart&amp;auto=webp&amp;s=230fce647e8dee4004c8510e8105e85415131160"
            },
            {
              "y": 468,
              "x": 960,
              "u": "https://preview.redd.it/6ag0m1p90cqa1.png?width=960&amp;crop=smart&amp;auto=webp&amp;s=d4a734cd13925285f6e4cc4f81bbe5b0b0f731e2"
            },
            {
              "y": 527,
              "x": 1080,
              "u": "https://preview.redd.it/6ag0m1p90cqa1.png?width=1080&amp;crop=smart&amp;auto=webp&amp;s=6408521c66dda424e46532c074626675e9e88dd2"
            }
          ],
          "s": {
            "y": 2500,
            "x": 5120,
            "u": "https://preview.redd.it/6ag0m1p90cqa1.png?width=5120&amp;format=png&amp;auto=webp&amp;s=fb682a766d82d2f242fb8e4c63aee30a4014ad34"
          },
          "id": "6ag0m1p90cqa1"
        }
      },
      "name": "t3_123f5q3",
      "quarantine": false,
      "link_flair_text_color": "dark",
      "upvote_ratio": 0.95,
      "author_flair_background_color": "#00a6a5",
      "subreddit_type": "public",
      "ups": 18,
      "total_awards_received": 0,
      "media_embed": {},
      "thumbnail_width": 140,
      "author_flair_template_id": "5cb3c302-0ef5-11ed-b9fd-aab9a872a9c2",
      "is_original_content": false,
      "user_reports": [],
      "secure_media": null,
      "is_reddit_media_domain": false,
      "is_meta": false,
      "category": null,
      "secure_media_embed": {},
      "link_flair_text": null,
      "can_mod_post": false,
      "score": 18,
      "approved_by": null,
      "is_created_from_ads_ui": false,
      "author_premium": false,
      "thumbnail": "https://b.thumbs.redditmedia.com/kBgsdgT7GpDx-ecdqVFLnppPH_wbrIwVEb9YH5mQLfY.jpg",
      "edited": 1680072420.0,
      "author_flair_css_class": null,
      "author_flair_richtext": [
        {
          "a": ":400K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/apsbyvbwmfe91_t5_2qknj/400K"
        },
        {
          "a": ":Arduino_500k:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/o5qzzwwkvk5a1_t5_2qknj/Arduino_500k"
        },
        {
          "a": ":600K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/z23hxjk4hpeb1_t5_2qknj/600K"
        },
        {
          "a": ":640K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/g9r24xjaydqc1_t5_2qknj/640K"
        },
        {
          "e": "text",
          "t": " My other dev board is a Porsche"
        }
      ],
      "gildings": {},
      "content_categories": null,
      "is_self": true,
      "mod_note": null,
      "created": 1679902118.0,
      "link_flair_type": "text",
      "wls": 6,
      "removed_by_category": null,
      "banned_by": null,
      "author_flair_type": "richtext",
      "domain": "self.arduino",
      "allow_live_comments": false,
      "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This is post #3 in a series about writing a chess engine for the Arduino platform. Here are &lt;a href=\"https://www.reddit.com/r/arduino/comments/11q4916/so_you_want_to_build_a_chess_engine/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;the first&lt;/a&gt; and &lt;a href=\"https://www.reddit.com/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;the second&lt;/a&gt; posts and &lt;a href=\"https://www.reddit.com/r/arduino/comments/125ezne/microchess_update_money_for_nothing/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;here is the next one&lt;/a&gt;. The main point of this post is to go over the evaluation function that is used to rate and decide every move the engine makes. First an update on the progress since a ton has been added in the two weeks since I started:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;All&lt;/strong&gt; of the pieces have been implemented. By the last post only the pawns and the knights were implemented but now the rook, bishop, queen, and king have also been added. All of the transposition tables for the move offsets are stored in flash memory using the &lt;code&gt;PROGMEM&lt;/code&gt; directive and retrieved as needed in order to minimize the use of RAM. All piece types can be individually enabled or disabled for debugging. The code is repetitive at the moment and needs to be &lt;a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\"&gt;DRY&lt;/a&gt; cleaned which will happen soon and will reduce the program size. And speaking of debugging..&lt;/li&gt;\n&lt;li&gt;Added a level-based, variable argument, runtime controllable &lt;code&gt;printf(...)&lt;/code&gt; like output system. This cleaned up the code a whole bunch as there were lots of commented out &lt;code&gt;Serial.print()&lt;/code&gt; statements left behind as things were fixed. Everything in the output is controlled by individual levels of verbosity. The code is clear and readable and the strings are stored in flash memory behind the scenes &lt;a href=\"https://www.reddit.com/r/arduino/comments/1224r94/question_about_making_a_better_variable_argument/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;using variadic macros&lt;/a&gt; and the strings are read back as needed to keep memory use at a minimum. The storage using &lt;code&gt;PROGMEM&lt;/code&gt; happens naturally and automatically without the user needing to declare anything as such and litter the code. The output level can range from &lt;code&gt;Everything&lt;/code&gt; to &lt;code&gt;Nothing&lt;/code&gt; with many choices of &lt;code&gt;Debug1, Debug2&lt;/code&gt; &amp;amp;c. in between. Setting the output to &lt;code&gt;Nothing&lt;/code&gt; allows timings to be measured without them including the &lt;code&gt;Serial&lt;/code&gt; I/O overhead. Speaking of which..&lt;/li&gt;\n&lt;li&gt;Added a &lt;em&gt;profiling and statistics&lt;/em&gt; class that tracks the number of &lt;em&gt;moves evaluated per second&lt;/em&gt; during the entire game as well as on individual turns. The first version that supported this evaluated about 360 moves a second which I thought was pretty decent for an Arduino Nano running at 16MHz. The current version evaluates &lt;em&gt;over&lt;/em&gt; &lt;em&gt;&lt;del&gt;1,200&lt;/del&gt;&lt;/em&gt; &lt;em&gt;1,900 moves a second on the same Nano&lt;/em&gt;. \ud83d\ude01&lt;/li&gt;\n&lt;li&gt;Added the &lt;em&gt;move and board evaluation function&lt;/em&gt; &lt;code&gt;evaluate(Color side)&lt;/code&gt;. This function rates and gives a static score for any board configuration or layout of pieces so that the moves that lead up to that board can be given a value. It is also &lt;em&gt;the most called function in the whole program&lt;/em&gt; so it better be quick. That&amp;#39;s what this post is about.&lt;/li&gt;\n&lt;li&gt;Added the &lt;code&gt;make_move(...)&lt;/code&gt; function which gives the ability to make the moves on the board that were generated by the pieces and to optionally take the move back and restore the board to the state before the move was made, but only &lt;strong&gt;&lt;em&gt;after&lt;/em&gt;&lt;/strong&gt; we call the &lt;code&gt;evaluate(side)&lt;/code&gt; function to see what the value of the move accomplishes.&lt;/li&gt;\n&lt;li&gt;Added the &lt;code&gt;play_game()&lt;/code&gt; function that calls all of the above mentioned functions to get the best move, and changes sides. Sets &lt;code&gt;game.done&lt;/code&gt; when one or both sides have no moves available.&lt;/li&gt;\n&lt;li&gt;The use of random is easily controlled in the game and the seed value is tracked which allows bugs to be duplicated until they resolved and then the use of random can be turned back on. This is also used in tandem with the profiling system.&lt;/li&gt;\n&lt;li&gt;All data types used throughout the program are program defined and controlled with extensive use of bitfields. Some of the code was examined in assembly to decide how to structure and iterate through the game. With the use of random turned off and playing against itself &lt;em&gt;the program makes it 165 moves into the game in 3 seconds before a bug stops things&lt;/em&gt;.&lt;/li&gt;\n&lt;li&gt;The program compiles cleanly now with 0 warnings and 0 errors on every build (with warnings turned up to show all):&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Sketch uses 18258 bytes (59%) of program storage space. Maximum is 30720 \nbytes.\nGlobal variables use 1449 bytes (70%) of dynamic memory, leaving 599 bytes \nfor local variables. Maximum is 2048 bytes.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And that&amp;#39;s with 106 moves stored for each side. And that will go away for the most part on the last (and next) big update to the engine &lt;em&gt;that implements the minimax algorithm&lt;/em&gt;. And that will leave tons of room for the additional libraries used for controlling the physical or visual versions of the games by the Arduino or other microcontroller. I&amp;#39;m curious to run this on an ESP32 to see the speed changes and play with having more headroom for memory. *Or maybe I&amp;#39;ll get in the early adopter program for the new R4 Uno board, hint hint &lt;a href=\"/u/mbanzi\"&gt;u/mbanzi&lt;/a&gt; lol.&lt;/p&gt;\n\n&lt;h1&gt;The evaluate(...) function&lt;/h1&gt;\n\n&lt;p&gt;The &lt;code&gt;evaluate(Color side)&lt;/code&gt; function is called dozens of times on every move made so it has to be fast. &lt;em&gt;It is the most called function in the program.&lt;/em&gt; On my first engine awhile back I knew I wanted something I could calculate extremely fast using only metrics that mattered. Everything had to be symetrical in that it would evenly reward and punish either side for a given move. So the 3 things I decided on were:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Material values&lt;/strong&gt;. These are the &lt;em&gt;relative individual chess pieces values&lt;/em&gt; (* 10,000) ranked by &lt;a href=\"https://www.chess.com/terms/chess-piece-value\"&gt;the conventional relative values used by most chess engines&lt;/a&gt;. &lt;code&gt;White&lt;/code&gt; piece values are added to the score and &lt;code&gt;Black&lt;/code&gt; piece values are subtracted from the score. So at the beginning of the game the values from both sides should cancel out and the board will have a value of 0. The &lt;code&gt;King&lt;/code&gt;&amp;#39;s value is set waaaay above every other piece value. Hence a board more favorable for the &lt;strong&gt;white side will be positive&lt;/strong&gt; and a board more favorable for the &lt;strong&gt;black side will be negative&lt;/strong&gt;. The material value can be scaled up or down separately from the other metrics to control it&amp;#39;s relative influence. More valuable material moves will have more pieces on the board for our side or take away pieces from the other side &lt;em&gt;after&lt;/em&gt; the move when compared to other moves.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Proximity to the center&lt;/strong&gt;. This is simply a 0 - 3 value in all 4 directions which rewards pieces that are closer to the center of the board (except the King! \ud83d\ude02). The sum of the this is then multiplied by the &lt;code&gt;Type&lt;/code&gt;; so stronger pieces gravitate towards the center of the board. Like the material score, the proximity to center can be separately scaled to control it&amp;#39;s influence relative to the other metrics. Also like the other metrics we do this for every move for every piece on each move, so if our opponent gets closer to the center we see that reflected in the evaluation just in the opposite direction of what our side wants. This symetry in the evaluation makes us work towards eliminating those future moves and stopping them by choosing moves for our side that eliminate them. It takes awhile to learn to think about all of the future evaluations having already taken place. It&amp;#39;s sort of like writing blockchain code that relies on future promises already being met kind of thing.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Mobility&lt;/strong&gt;. This metric rewards board configurations &lt;em&gt;that result in more moves&lt;/em&gt; being available to our side and/or fewer moves being available to our opponent after the move is made. Because the metric requires knowing how many future moves were enabled or disabled because of the last move and comparing it to the current number of moves; the use of this metric is tricky and can only be used &lt;em&gt;on the way back&lt;/em&gt; (&lt;em&gt;so to speak. I&amp;#39;m not sure that I will actually make it recursive; I may unroll it to have deterministic control over the memory used&lt;/em&gt;) from future calls that evaluate the moves made in response to the last move. Since &lt;a href=\"https://en.wikipedia.org/wiki/Minimax\"&gt;the minimax algorithm&lt;/a&gt; is not in place yet we don&amp;#39;t examine any responses to our moves yet so the current engine plays out a dumb and greedy game. It also makes moves that place our own King in check or fail to respond when our King is in check but that will fall away in the next update. Things get really interesting when several pawns on both sides make it to the last rows and are auto-promoted to queens!&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;And it&amp;#39;s really that simple. An arrangement of pieces that reward one or more of those three things is treated as more valuable. So when all of the moves have been generated for all of the pieces, and then each move is made on the board and the evaluation function is called, then the move is undone and the board is restored. Moves that subtract from the other side&amp;#39;s material or that move us closer to controlling the center of the board are scored higher. Then we just do a &lt;code&gt;qsort()&lt;/code&gt; on the moves using a comparison lambda function that rewards higher values if the current side is white or if the current side is black it sorts things in reverse so that the most negative values are ranked higher. Then we pick the highest value move as our next move and make it for real on the board and we change to the other sides&amp;#39;s turn. Actually to mix things up we pick a random move from all of the top moves that have the same score. That&amp;#39;s it! It&amp;#39;s actually very simple. A different evaluation function might be designed if you were using this engine to make a checkers game.&lt;/p&gt;\n\n&lt;p&gt;As mentioned the mobility metric is turned off at the moment but you can enable it and experiment with it to see it&amp;#39;s influence. And without further ado here is the &lt;del&gt;current&lt;/del&gt; updated &lt;code&gt;evaluate(Color side)&lt;/code&gt; function:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;long evaluate(Color side) \n{\n    // flags choices for which attributes are included in the board score\n    static uint8_t const material = 0x01u;\n    static uint8_t const   center = 0x02u;\n    static uint8_t const mobility = 0x04u;\n\n    static uint8_t const filter = material | center;\n\n    // calculate the value of the board\n    long materialTotal = 0L;\n    long mobilityTotal = 0L;\n    long centerTotal = 0L;\n    long score = 0L;\n\n    // iterate over the pieces on the board if necessary\n    if (filter &amp;amp; (material | center)) {\n        for (\n            index_t piece_index = 0; \n            piece_index &amp;lt; game.piece_count; \n            piece_index++) {\n            index_t const col = game.pieces[piece_index].x;\n            index_t const row = game.pieces[piece_index].y;\n            Piece   const p = board.get(col + row * 8);\n            Piece   const ptype = getType(p);\n            Color   const pside = getSide(p);\n\n            if (filter &amp;amp; material) {\n                // now uses pre-computed material bonus table for speed!\n                materialTotal += \n                    pgm_read_dword(&amp;amp;material_bonus[ptype][pside]);\n            }\n\n            if (filter &amp;amp; center) { \n                // now uses pre-computed center bonus table for speed!\n                centerTotal += (King == ptype) ? 0 :\n                    pgm_read_dword(&amp;amp;center_bonus[col][ptype][pside]) + \n                    pgm_read_dword(&amp;amp;center_bonus[row][ptype][pside]);\n            }\n        }\n    }\n\n    if (filter &amp;amp; mobility) {\n        long sideFactor = (Black == side) ? -1 : 1;\n        mobilityTotal += \n        static_cast&amp;lt;long&amp;gt;(game.move_count1 * mobilityBonus * sideFactor);\n        mobilityTotal -= \n        static_cast&amp;lt;long&amp;gt;(game.move_count2 * mobilityBonus * sideFactor);\n    }\n\n    score = materialTotal + centerTotal + mobilityTotal;\n\n    printf(Debug4, \n        &amp;quot;evaluation: %ld = centerTotal: %ld  &amp;quot;\n        &amp;quot;materialTotal: %ld  mobilityTotal: %ld\\n&amp;quot;, \n        score, centerTotal, materialTotal, mobilityTotal);\n\n    return score;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;edit: &lt;a href=\"https://github.com/ripred/MicroChess\"&gt;Here is the github repo of the current version&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;and here&amp;#39;s the current look of the serial output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Move #52: Black Pawn from: 2,4 (C4) to: 3,5 (D3) taking a White Pawn\nWhite King is in check!\n\n0  *  .  *  .  k  .  *  r     Last Move: C4 to D3\n1  .  *  .  *  .  *  b  p     Time spent: 76 ms\n2  *  .  *  .  *  .  *  p     Moves evaluated: 82\n3  .  *  .  *  p  *  .  * \n4  *  p  *  .  *  p  *  .     Taken 1: n n b q r p p \n5  .  *  K  p  .  *  .  P     Taken 2: P B P P N P P \n6  *  .  *  .  P  P  B  . \n7  .  *  .  *  R  Q  N  R     Board value:      800 White&amp;#39;s favor\n   0  1  2  3  4  5  6  7\n\nand:\n\nstarting..\n\ngame hash: 0x232F89A3, profiling...\nfinished.\n\n0  *  .  *  .  *  .  *  .     Last Move: F1 to G1\n1  .  *  .  k  .  *  .  *     Time spent: 16 ms\n2  *  .  *  .  *  .  *  .     Moves evaluated: 50\n3  .  *  .  *  .  *  .  p \n4  *  .  *  .  *  .  *  p     Taken 1: n n b q r p p p p p q b r \n5  .  *  .  *  K  *  .  P     Taken 2: P B P P N P P P Q B N \n6  *  .  *  .  *  P  *  . \n7  .  *  .  *  .  *  R  R     Board value:      550 White&amp;#39;s favor\n   0  1  2  3  4  5  6  7\n\n======================================================================\n           total game time:   5.3180 seconds\n           number of moves: 125\ntotal game moves evaluated: 10,277\n  average moves per second: 1932.4935 \n   max move count per turn: 39\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Please ask any questions you have about the way the engine works, what&amp;#39;s next, or of course any bugs you catch! There&amp;#39;s one that I know of currently but I&amp;#39;m on the hunt.&lt;/p&gt;\n\n&lt;p&gt;update: &lt;a href=\"https://create.arduino.cc/editor/Ripred/ba021340-bf68-4bd8-ac7b-d0d25144dcce/preview\"&gt;the current version is running online for free at arduino.cc&amp;#39;s IoT Cloud at this link&lt;/a&gt;:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/6ag0m1p90cqa1.png?width=5120&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=fb682a766d82d2f242fb8e4c63aee30a4014ad34\"&gt;MicroChess running online at arduino.cc&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Cheers,&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ripred&lt;/code&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
      "likes": null,
      "suggested_sort": "confidence",
      "banned_at_utc": null,
      "view_count": null,
      "archived": false,
      "no_follow": false,
      "is_crosspostable": false,
      "pinned": false,
      "over_18": false,
      "all_awardings": [],
      "awarders": [],
      "media_only": false,
      "can_gild": false,
      "spoiler": false,
      "locked": false,
      "author_flair_text": ":400K::Arduino_500k::600K::640K: My other dev board is a Porsche",
      "treatment_tags": [],
      "visited": false,
      "removed_by": null,
      "num_reports": null,
      "distinguished": null,
      "subreddit_id": "t5_2qknj",
      "author_is_blocked": false,
      "mod_reason_by": null,
      "removal_reason": null,
      "link_flair_background_color": "",
      "id": "123f5q3",
      "is_robot_indexable": true,
      "report_reasons": null,
      "author": "ripred3",
      "discussion_type": null,
      "num_comments": 2,
      "send_replies": true,
      "contest_mode": false,
      "mod_reports": [],
      "author_patreon_flair": false,
      "author_flair_text_color": "light",
      "permalink": "/r/arduino/comments/123f5q3/microchess_move_evaluation_function/",
      "stickied": false,
      "url": "https://www.reddit.com/r/arduino/comments/123f5q3/microchess_move_evaluation_function/",
      "subreddit_subscribers": 691380,
      "created_utc": 1679902118.0,
      "num_crossposts": 6,
      "media": null,
      "is_video": false
    }
  ],
  "created": 1679902176.0,
  "link_flair_type": "text",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "text",
  "domain": "self.arduino",
  "allow_live_comments": false,
  "selftext_html": null,
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "url_overridden_by_dest": "/r/arduino/comments/123f5q3/microchess_move_evaluation_function/",
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": null,
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_7yd5re",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "",
  "id": "123f6we",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "crosspost_parent": "t3_123f5q3",
  "author_flair_text_color": null,
  "permalink": "/r/Arduino_AI/comments/123f6we/microchess_move_evaluation_function/",
  "stickied": false,
  "url": "/r/arduino/comments/123f5q3/microchess_move_evaluation_function/",
  "subreddit_subscribers": 3137,
  "created_utc": 1679902176.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}