{
  "approved_at_utc": null,
  "subreddit": "Arduino_AI",
  "selftext": "",
  "user_reports": [],
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "Writing an Embedded Chess Engine - Part 5",
  "link_flair_richtext": [],
  "subreddit_name_prefixed": "r/Arduino_AI",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": null,
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_13qgjrh",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 1.0,
  "author_flair_background_color": null,
  "subreddit_type": "public",
  "ups": 2,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": null,
  "is_original_content": false,
  "author_fullname": "t2_adfkq",
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": null,
  "can_mod_post": false,
  "score": 2,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "default",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [],
  "gildings": {},
  "content_categories": null,
  "is_self": false,
  "mod_note": null,
  "crosspost_parent_list": [
    {
      "approved_at_utc": null,
      "subreddit": "arduino",
      "selftext": "Hi all, it's been awhile since I posted anything about the project but I have continued to work on it now for about 3 months. The engine has been rewritten about 3 times so far and many many features have been added since my last update. For starters the [minimax/maximin algorithm](https://en.wikipedia.org/wiki/Minimax) is fully implemented and working as well as the [alpha-beta pruning](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning) (culling) search heuristic, and support for quiescent searches, en passant captures, and castling.\n\nExtensive effort has gone into minimizing the memory use. The basic RAM requirements at compile time are 810 bytes, leaving 1,238 bytes for runtime. The recursion of the minimax implementation requires \\~142 bytes per ply level (spread across 4 functions) which means the engine can reliably achieve searching up to 7 ply levels (turns) ahead (including the current move), all running under 2K of RAM.\n\nThis is a work in progress so there are a few bugs of course and I'm actively chasing them down and squishing them. The bugs remaining mostly concern the endgame. The game currently plays itself but the user can send commands via the `Serial` port to make any moves for either side at any time on-the-fly.\n\nSeveral approaches and techniques have been tried as this is being developed. At one point the engine even monitored the available stack space and simply ran to whatever ply depths could be afforded which was quite entertaining and achieved a depth of up to 8 ply levels but I am abandoning that approach and the supporting code and architecure are slowly being removed. Regardless of whether the engine is using the stack space or a max ply level setting (or both!) the user can specifiy a time limit per-move that overrides everything beyond a single ply so the turns can be limited to anywhere &gt;= \\~100 ms per move.\n\nEVERYTHING is fully configurable using an independent options class to hold your desired settings. There are even facilities to allow changing the settings for each side so that side by side comparisons of settings choices can be compared against each other. The engine also includes a profiling mode in which there is no output until the end of the game at which point the final board and various statistics are displayed including the number of moves evaluated per second. Using a standard 16MHz Arduino Nano the engine averages around \\~1000 moves evaluated/second but at times depending on the number of pieces and the board state it evaluates up to 3,200 moves per second.\n\nSupport for an external displayable game board has been added using a simple LED strip arranged in a serial 8x8 grid. Additionally the game is displayed using serial output.\n\nThe game now supports opening book moves as well. Full control over the use of `random(...)` is included so that the same game can be debugged or each game can be completely random (when more than one move achieves the same evaluation score).\n\nThis project started out as a platform for learning and teaching how to write turn-based game engines but at this point that has taken a lower priority behind optimizing the speed and memory use.\n\nIn addition I am about to refactor the code so that additional CPUs/microcontrollers can be attached via I2C (I'm thinking of using ATTiny85's right now) so that multiple engines can be run in parallel with each move being evaluated in parallel on it's own independent processor which will greatly increase the throughput of the engine.\n\nThe move generation for all piece types has been reduced down to only two extremely short and optimized functions.\n\nI know I'm leaving out (forgetting to mention \ud83e\udd74) a bunch of the enhancements that have been made but you can check out the full source code as well as a gif of the console output playing a 4-move opening book checkmate, and my janky LED strip game board I'm using for debugging.\n\nAs always I welcome any constructive feedback or questions anyone has. The full engine can be found [here in the MicroChess repository](https://github.com/ripred/MicroChess) along with [my other more full featured chess engines in various languages including Java, C++, and Javascript](https://github.com/ripred).\n\n[The full collection of articles written so far can be found here](https://www.reddit.com/r/ripred/collection/7b30fae2-e995-4287-85a8-b839cfbd2f1e/).\n\nThanks,\n\n`ripred`",
      "author_fullname": "t2_adfkq",
      "saved": false,
      "mod_reason_title": null,
      "gilded": 0,
      "clicked": false,
      "title": "Writing an Embedded Chess Engine - Part 5",
      "link_flair_richtext": [],
      "subreddit_name_prefixed": "r/arduino",
      "hidden": false,
      "pwls": 6,
      "link_flair_css_class": null,
      "downs": 0,
      "thumbnail_height": null,
      "top_awarded_type": null,
      "hide_score": false,
      "name": "t3_13qfqj9",
      "quarantine": false,
      "link_flair_text_color": "dark",
      "upvote_ratio": 0.9,
      "author_flair_background_color": "#00a6a5",
      "subreddit_type": "public",
      "ups": 8,
      "total_awards_received": 0,
      "media_embed": {},
      "thumbnail_width": null,
      "author_flair_template_id": "5cb3c302-0ef5-11ed-b9fd-aab9a872a9c2",
      "is_original_content": false,
      "user_reports": [],
      "secure_media": null,
      "is_reddit_media_domain": false,
      "is_meta": false,
      "category": null,
      "secure_media_embed": {},
      "link_flair_text": null,
      "can_mod_post": false,
      "score": 8,
      "approved_by": null,
      "is_created_from_ads_ui": false,
      "author_premium": false,
      "thumbnail": "self",
      "edited": 1684987424.0,
      "author_flair_css_class": null,
      "author_flair_richtext": [
        {
          "a": ":400K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/apsbyvbwmfe91_t5_2qknj/400K"
        },
        {
          "a": ":Arduino_500k:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/o5qzzwwkvk5a1_t5_2qknj/Arduino_500k"
        },
        {
          "a": ":600K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/z23hxjk4hpeb1_t5_2qknj/600K"
        },
        {
          "a": ":640K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/g9r24xjaydqc1_t5_2qknj/640K"
        },
        {
          "e": "text",
          "t": " My other dev board is a Porsche"
        }
      ],
      "gildings": {},
      "content_categories": null,
      "is_self": true,
      "mod_note": null,
      "created": 1684917279.0,
      "link_flair_type": "text",
      "wls": 6,
      "removed_by_category": null,
      "banned_by": null,
      "author_flair_type": "richtext",
      "domain": "self.arduino",
      "allow_live_comments": false,
      "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Hi all, it&amp;#39;s been awhile since I posted anything about the project but I have continued to work on it now for about 3 months. The engine has been rewritten about 3 times so far and many many features have been added since my last update. For starters the &lt;a href=\"https://en.wikipedia.org/wiki/Minimax\"&gt;minimax/maximin algorithm&lt;/a&gt; is fully implemented and working as well as the &lt;a href=\"https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning\"&gt;alpha-beta pruning&lt;/a&gt; (culling) search heuristic, and support for quiescent searches, en passant captures, and castling.&lt;/p&gt;\n\n&lt;p&gt;Extensive effort has gone into minimizing the memory use. The basic RAM requirements at compile time are 810 bytes, leaving 1,238 bytes for runtime. The recursion of the minimax implementation requires ~142 bytes per ply level (spread across 4 functions) which means the engine can reliably achieve searching up to 7 ply levels (turns) ahead (including the current move), all running under 2K of RAM.&lt;/p&gt;\n\n&lt;p&gt;This is a work in progress so there are a few bugs of course and I&amp;#39;m actively chasing them down and squishing them. The bugs remaining mostly concern the endgame. The game currently plays itself but the user can send commands via the &lt;code&gt;Serial&lt;/code&gt; port to make any moves for either side at any time on-the-fly.&lt;/p&gt;\n\n&lt;p&gt;Several approaches and techniques have been tried as this is being developed. At one point the engine even monitored the available stack space and simply ran to whatever ply depths could be afforded which was quite entertaining and achieved a depth of up to 8 ply levels but I am abandoning that approach and the supporting code and architecure are slowly being removed. Regardless of whether the engine is using the stack space or a max ply level setting (or both!) the user can specifiy a time limit per-move that overrides everything beyond a single ply so the turns can be limited to anywhere &amp;gt;= ~100 ms per move.&lt;/p&gt;\n\n&lt;p&gt;EVERYTHING is fully configurable using an independent options class to hold your desired settings. There are even facilities to allow changing the settings for each side so that side by side comparisons of settings choices can be compared against each other. The engine also includes a profiling mode in which there is no output until the end of the game at which point the final board and various statistics are displayed including the number of moves evaluated per second. Using a standard 16MHz Arduino Nano the engine averages around ~1000 moves evaluated/second but at times depending on the number of pieces and the board state it evaluates up to 3,200 moves per second.&lt;/p&gt;\n\n&lt;p&gt;Support for an external displayable game board has been added using a simple LED strip arranged in a serial 8x8 grid. Additionally the game is displayed using serial output.&lt;/p&gt;\n\n&lt;p&gt;The game now supports opening book moves as well. Full control over the use of &lt;code&gt;random(...)&lt;/code&gt; is included so that the same game can be debugged or each game can be completely random (when more than one move achieves the same evaluation score).&lt;/p&gt;\n\n&lt;p&gt;This project started out as a platform for learning and teaching how to write turn-based game engines but at this point that has taken a lower priority behind optimizing the speed and memory use.&lt;/p&gt;\n\n&lt;p&gt;In addition I am about to refactor the code so that additional CPUs/microcontrollers can be attached via I2C (I&amp;#39;m thinking of using ATTiny85&amp;#39;s right now) so that multiple engines can be run in parallel with each move being evaluated in parallel on it&amp;#39;s own independent processor which will greatly increase the throughput of the engine.&lt;/p&gt;\n\n&lt;p&gt;The move generation for all piece types has been reduced down to only two extremely short and optimized functions.&lt;/p&gt;\n\n&lt;p&gt;I know I&amp;#39;m leaving out (forgetting to mention \ud83e\udd74) a bunch of the enhancements that have been made but you can check out the full source code as well as a gif of the console output playing a 4-move opening book checkmate, and my janky LED strip game board I&amp;#39;m using for debugging.&lt;/p&gt;\n\n&lt;p&gt;As always I welcome any constructive feedback or questions anyone has. The full engine can be found &lt;a href=\"https://github.com/ripred/MicroChess\"&gt;here in the MicroChess repository&lt;/a&gt; along with &lt;a href=\"https://github.com/ripred\"&gt;my other more full featured chess engines in various languages including Java, C++, and Javascript&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://www.reddit.com/r/ripred/collection/7b30fae2-e995-4287-85a8-b839cfbd2f1e/\"&gt;The full collection of articles written so far can be found here&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;Thanks,&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ripred&lt;/code&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
      "likes": null,
      "suggested_sort": "confidence",
      "banned_at_utc": null,
      "view_count": null,
      "archived": false,
      "no_follow": false,
      "is_crosspostable": false,
      "pinned": false,
      "over_18": false,
      "all_awardings": [],
      "awarders": [],
      "media_only": false,
      "can_gild": false,
      "spoiler": false,
      "locked": false,
      "author_flair_text": ":400K::Arduino_500k::600K::640K: My other dev board is a Porsche",
      "treatment_tags": [],
      "visited": false,
      "removed_by": null,
      "num_reports": null,
      "distinguished": null,
      "subreddit_id": "t5_2qknj",
      "author_is_blocked": false,
      "mod_reason_by": null,
      "removal_reason": null,
      "link_flair_background_color": "",
      "id": "13qfqj9",
      "is_robot_indexable": true,
      "report_reasons": null,
      "author": "ripred3",
      "discussion_type": null,
      "num_comments": 2,
      "send_replies": true,
      "contest_mode": false,
      "mod_reports": [],
      "author_patreon_flair": false,
      "author_flair_text_color": "light",
      "permalink": "/r/arduino/comments/13qfqj9/writing_an_embedded_chess_engine_part_5/",
      "stickied": false,
      "url": "https://www.reddit.com/r/arduino/comments/13qfqj9/writing_an_embedded_chess_engine_part_5/",
      "subreddit_subscribers": 691380,
      "created_utc": 1684917279.0,
      "num_crossposts": 6,
      "media": null,
      "is_video": false
    }
  ],
  "created": 1684920138.0,
  "link_flair_type": "text",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "text",
  "domain": "self.arduino",
  "allow_live_comments": false,
  "selftext_html": null,
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "url_overridden_by_dest": "/r/arduino/comments/13qfqj9/writing_an_embedded_chess_engine_part_5/",
  "view_count": null,
  "archived": false,
  "no_follow": false,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": null,
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_7yd5re",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "",
  "id": "13qgjrh",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "crosspost_parent": "t3_13qfqj9",
  "author_flair_text_color": null,
  "permalink": "/r/Arduino_AI/comments/13qgjrh/writing_an_embedded_chess_engine_part_5/",
  "stickied": false,
  "url": "/r/arduino/comments/13qfqj9/writing_an_embedded_chess_engine_part_5/",
  "subreddit_subscribers": 3137,
  "created_utc": 1684920138.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}