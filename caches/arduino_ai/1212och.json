{
  "approved_at_utc": null,
  "subreddit": "Arduino_AI",
  "selftext": "",
  "user_reports": [],
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "So, You Want To Build A Chess Engine? Part2",
  "link_flair_richtext": [],
  "subreddit_name_prefixed": "r/Arduino_AI",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": null,
  "downs": 0,
  "thumbnail_height": 70,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_1212och",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 1.0,
  "author_flair_background_color": null,
  "subreddit_type": "public",
  "ups": 2,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": 140,
  "author_flair_template_id": null,
  "is_original_content": false,
  "author_fullname": "t2_adfkq",
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": null,
  "can_mod_post": false,
  "score": 2,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "https://b.thumbs.redditmedia.com/4CLDvdqmPVHesahFyGEtOhXJY_nR4li_jFtQsmqyAWM.jpg",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [],
  "gildings": {},
  "post_hint": "link",
  "content_categories": null,
  "is_self": false,
  "mod_note": null,
  "crosspost_parent_list": [
    {
      "approved_at_utc": null,
      "subreddit": "arduino",
      "selftext": "Happy Friday!\n\nThis is the second post in a series about writing a chess engine for the Arduino platform. All Arduinos except the *ATTiny* series (*still may be possible* \ud83e\uddd0) are supported *including the Uno and the Nano!*\n\nThe first post [can be found here](https://www.reddit.com/r/arduino/comments/11q4916/so_you_want_to_build_a_chess_engine/?utm_source=share&amp;utm_medium=web2x&amp;context=3) and [the next posts are here](https://www.reddit.com/r/arduino/comments/123f5q3/microchess_move_evaluation_function/?utm_source=share&amp;utm_medium=web2x&amp;context=3) and [here](https://www.reddit.com/r/arduino/comments/125ezne/microchess_update_money_for_nothing/?utm_source=share&amp;utm_medium=web2x&amp;context=3). The repository for the **MicroChess** project [can be found here](https://github.com/ripred/MicroChess).\n\nA ton has been added since the first post in this series. There are bugs and the code is a work in progress but all commits and pushes compile and run. About 60% of the engine is implemented in some form or another. Note that **only the Pawn and Knight pieces have been fully implemented and lightly tested** as of this writing even though there are placeholders (really crude and ugly placeholders) implemented for the other pieces as well. We'll get into the code for each `Piece` individually later on in future posts in the series.\n\n# Architecture\n\nThis post is about the basic architecture of the chess engine. This is likely to change in the future but I needed to get some basic scaffolding in place in order to develop the Arduino version. 95% of the code is brand-new and written for this project specifically. I will document any major architectural changes in future posts in the series when they happen. The C and C++ code rely heavily on the use of *bitfields, the ternary operator,* and *lambda* functions, for memory savings, readability, code density, and avoiding unneeded polution of the global namespace. These will be covered and fully explained as they are encountered in later posts.\n\n# board_t\n\nThe `board_t` structure was introduced in the first post of the series and is still currently used. The `board_t` data type is responsible for storing the pieces that are on the board and the attributes for those pieces such as their piece ***type***, their ***color***, whether the piece has been ***moved***, and whether the piece is in ***check***, for each of the 64 board locations. The `board_t` has 3 simple public methods available:\n\n* `init()` \\- initialize the pieces on the board for a new game\n* `get(index_t index)` \\- gets the `Piece` at the specified location. The `index` parameter should be in the range of 0 - 63.\n* `set(index_t index, Piece p)` \\- sets the `Piece` at the specified location. The `index` parameter should be in the range of 0 - 63.\n\nAt each location of the board is stored a `Piece`. A `Piece` contains 4 pieces of information about any piece at a location:\n\n* 3 bits for the type of `Piece` at that location. The following `Piece` types are available:\n\n&amp;#x200B;\n\n    // The Piece types\n    static Piece const Empty  = 0u;\n    static Piece const Pawn   = 1u;\n    static Piece const Knight = 2u;\n    static Piece const Bishop = 3u;\n    static Piece const Rook   = 4u;\n    static Piece const Queen  = 5u;\n    static Piece const King   = 6u;\n\n* 1 bit for the `Color`, or side the piece belongs to. 0 indicates the piece is a black piece and 1 indicates the piece is a white piece.\n* 1 bit for the moved state of the `Piece`. The moved state is 0 if the piece has not been moved and is 1 once the piece has been moved. This is used to determine whether `Pawns` can move to the second row on their first move, and whether the `King` and either `Rook` can castle or not. Note that castling has not been implemented yet.\n* 1 bit for the check state of the `Piece`. This will be used later on to highlight pieces that are under threat as well as to check when a move has put one of the kings in check or not.\n\n# game_t\n\nThe other major data type used is the `game_t` structure. The `game_t` data type keeps track of everything else about a running game. Eventually the `game_t` may likely evolve to contain the `board_t` for the game but for now there are two global variables defined for the *singleton* `board` and `game`.\n\nIn the other chess engines I have previously written I have always scanned the board at all 64 spots and if a spot was not `Empty` then I would process the `Piece` at that location. For this microcontroller version I decided that was inefficient because at the very least; A full half of the 64 spots processed will be `Empty.` And as the game progresses and more pieces are taken then the number of spots processed that will be `Empty` will only get bigger and more time would be wasted. So for this version I keep track of an array of x,y points, one for each active piece in the game. The array is stored in the `game_t` object along with an 8-bit integer indicating how many `Pieces` are currently active. In this way we can loop through only where the pieces are stored on the board extremely fast and not have to examine any other locations when examinging pieces and enumerating the possible moves.\n\nThe full declaration for the current version of the `game_t` structure is:\n\n    #pragma pack(0)\n    \n    struct game_t {\n    public:\n        point_t   pieces[MAX_PIECES];     // MAX_PIECES = 32\n        move_t    moves1[MAX_MOVES];      // MAX_MOVES = 106\n        move_t    moves2[MAX_MOVES];\n        Piece     taken1[16];\n        Piece     taken2[16];\n        Bool      white_king_in_check;\n        Bool      black_king_in_check;\n        move_t    last_move;\n        uint8_t   piece_count;\n        uint8_t   move_count1;\n        uint8_t   move_count2;\n        uint8_t   max_moves;\n        uint8_t   taken_count1;\n        uint8_t   taken_count2;\n        uint8_t   eval_ndx,     // board index being currently evaluated\n                  turn,         // 0 := Black, 1 := White\n                  move_num,     // increasing move number, 0-based\n                  done;         // 1 := game over\n    \n    public:\n        &lt;snip...&gt;\n    };\n\nHopefully most of the fields in the structure are self explanatory. Please post comments with any questions you have about any fields in the `game_t` structure.\n\nFor completeness here are the `point_t` and `move_t` structures:\n\n    enum {\n        ...\n        NUM_BITS_PT   =   5,  // bits per field in point_t struct\n        NUM_BITS_SPOT =   7,  // bits per field in move_t struct\n        ...\n    };\n    \n    struct point_t \n    {\n    public:\n        index_t  x : NUM_BITS_PT, \n                 y : NUM_BITS_PT;\n    \n    public:\n        point_t() : x(0), y(0) {}\n        point_t(index_t X, index_t Y) : x(X), y(Y) {}\n    \n    };  // point_t\n\nNote that the `point_t` type keeps the column and row on the board separate. The index into the `board_t` for a given piece in the `game.pieces[32]` array can be determined by calculating:\n\n    board index (0 - 63) = point_t.y * 8 + point_t.x\n\nThe `index_t` type is a `signed char` (`int8_t`) as we need to occassionaly do calculations using coordinates that may be negative (off of the board) during traversal and move generation.\n\n    struct move_t \n    {\n    public:\n        int32_t  from : NUM_BITS_SPOT, \n                   to : NUM_BITS_SPOT,\n                value : ((sizeof(int32_t) * 8) - (NUM_BITS_SPOT * 2));\n    \n    public:\n        move_t() : from(0), to(0), value(0) {}\n        move_t(index_t f, index_t t, long v) : from(f), to(t), value(v) {}\n    \n    };  // move_t\n\nThe `from` and `to` fields of the `move_t` structure are the 0 - 63 indexes of the *starting* spot and the *ending* spot on the board for each move for each piece. The `value` associated with each `move_t` is the ***score*** of the board *after that move has been made*.\n\nSo for example, when the game first starts up the `Piece`'s are all on the board at array entries `board[0]` thru `board[15]` for the black pieces (the two top rows) and at `board[56]` thru `board[63]` for the white pieces (the bottom two rows):\n\n[the board\\[64\\] array, shown with indexes and column and row numbers \\(rank and file\\)](https://preview.redd.it/5gj8caul2spa1.png?width=320&amp;format=png&amp;auto=webp&amp;s=1ab1ef2e0f1bc52a840905f6ce4fb89015f62098)\n\nAs mentioned, the location of pieces are translated back and forth between *col/row* and board *index* (0 - 63) throughout the code using the following idioms:\n\n    col = index % 8;\n    row = index / 8;\n    \n    and \n    \n    index = col + row * 8\n\nAnd the `game.pieces[32]` array holds the `point_t` *col/row* values for all of the pieces:\n\n    game.pieces[ 0] = { 0, 0 }    // black rook\n    game.pieces[ 1] = { 1, 0 }    // black knight\n    game.pieces[ 2] = { 2, 0 }    // black bishop\n    game.pieces[ 3] = { 3, 0 }    // ...\n    game.pieces[ 4] = { 4, 0 }\n    game.pieces[ 5] = { 5, 0 }\n    game.pieces[ 6] = { 6, 0 }\n    game.pieces[ 7] = { 7, 0 }\n    game.pieces[ 8] = { 0, 1 }    // black pawns\n    game.pieces[ 9] = { 1, 1 }\n    game.pieces[10] = { 2, 1 }\n    game.pieces[11] = { 3, 1 }\n    game.pieces[12] = { 4, 1 }\n    game.pieces[13] = { 5, 1 }\n    game.pieces[14] = { 6, 1 }\n    game.pieces[15] = { 7, 1 }\n    game.pieces[16] = { 0, 6 }    // white pawns\n    game.pieces[17] = { 1, 6 }\n    game.pieces[18] = { 2, 6 }\n    game.pieces[19] = { 3, 6 }\n    game.pieces[20] = { 4, 6 }\n    game.pieces[21] = { 5, 6 }\n    game.pieces[22] = { 6, 6 }\n    game.pieces[23] = { 7, 6 }\n    game.pieces[24] = { 0, 7 }    // white rook\n    game.pieces[25] = { 1, 7 }    // white knight\n    game.pieces[26] = { 2, 7 }    // white bishop\n    game.pieces[27] = { 3, 7 }    // ...\n    game.pieces[28] = { 4, 7 }\n    game.pieces[29] = { 5, 7 }\n    game.pieces[30] = { 6, 7 }\n    game.pieces[31] = { 7, 7 }\n\nAnd it is *this* `game.pieces[]` list that we iterate through when evaluating all of the pieces and what moves they can make. The number of pieces currently left in the game is stored in `game.piece_count`.\n\nAnd speaking of the board ***score***; **In the next post of the series** we will go over the `evaluation(...)` function that is used to determine the value identity for a given board arrangement when calculating what the value of each available move is so we can pick the best!\n\nAs a teaser; Here is the updated view of the output of the program to the `Serial` window (remember only the pawns and knights are enabled right now):\n\n    Move #13: White Pawn from: 6,6 (G2) to: 6,4 (G4)\n    \n    8  r  .  b  q  k  b  n  r \n    7  p  *  p  *  .  p  p  p     Last Move: G2 to G4\n    6  *  n  *  .  *  .  *  . \n    5  .  p  .  *  .  *  .  *     Taken 1: \n    4  *  P  *  p  p  P  P  P     Taken 2: P P \n    3  .  N  .  *  .  *  .  * \n    2  P  .  P  .  *  .  *  .     Board value:     -230 Black's favor\n    1  R  *  B  Q  K  B  N  R \n       A  B  C  D  E  F  G  H\n    \n    &lt;snip..&gt;\n    \n    game hash: 000089A3, profiling...\n    starting..\n    finished.\n    \n    0  r  .  Q  q  k  b  *  r \n    1  .  *  .  *  P  *  .  *     Last Move: A3 to A2\n    2  *  P  *  .  *  .  n  . \n    3  .  N  .  *  .  *  P  *     Taken 1: p p p p p b \n    4  *  .  *  .  *  .  p  .     Taken 2: P P P P B Q \n    5  .  *  .  *  .  *  N  * \n    6  n  .  *  .  *  .  *  .     Board value:     -373 Black's favor\n    7  R  *  q  q  K  B  .  R \n       0  1  2  3  4  5  6  7\n    \n    total game time: 1102 ms\n    max move count: 17\n    total game moves evaluated: 728\n    moves per second: 660.6171 \n\noutput window:\n\n    Sketch uses 16494 bytes (53%) of program storage space. Maximum \n    is 30720 bytes. Global variables use 1480 bytes (72%) of dynamic \n    memory, leaving 568 bytes for local variables. Maximum is 2048 \n    bytes.\n\nSee ya then!\n\n`ripred`",
      "author_fullname": "t2_adfkq",
      "saved": false,
      "mod_reason_title": null,
      "gilded": 0,
      "clicked": false,
      "title": "So, You Want To Build A Chess Engine? Part2",
      "link_flair_richtext": [
        {
          "a": ":Games:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/jmcekh3qfkna1_t5_2qknj/Games"
        },
        {
          "e": "text",
          "t": " Games"
        }
      ],
      "subreddit_name_prefixed": "r/arduino",
      "hidden": false,
      "pwls": 6,
      "link_flair_css_class": "",
      "downs": 0,
      "thumbnail_height": 70,
      "top_awarded_type": null,
      "hide_score": false,
      "media_metadata": {
        "5gj8caul2spa1": {
          "status": "valid",
          "e": "Image",
          "m": "image/png",
          "p": [
            {
              "y": 107,
              "x": 108,
              "u": "https://preview.redd.it/5gj8caul2spa1.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=1452ac4959322b2f5a36308f94f40f8a72a22b42"
            },
            {
              "y": 215,
              "x": 216,
              "u": "https://preview.redd.it/5gj8caul2spa1.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=51208fd8c2f32cdb18eb9ebe778425cb52aab8e4"
            },
            {
              "y": 319,
              "x": 320,
              "u": "https://preview.redd.it/5gj8caul2spa1.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=25a3d626df73e645f7f3e3c1896cbf5d8fff289f"
            }
          ],
          "s": {
            "y": 319,
            "x": 320,
            "u": "https://preview.redd.it/5gj8caul2spa1.png?width=320&amp;format=png&amp;auto=webp&amp;s=1ab1ef2e0f1bc52a840905f6ce4fb89015f62098"
          },
          "id": "5gj8caul2spa1"
        }
      },
      "name": "t3_120trd9",
      "quarantine": false,
      "link_flair_text_color": "light",
      "upvote_ratio": 0.73,
      "author_flair_background_color": "#00a6a5",
      "ups": 8,
      "total_awards_received": 0,
      "media_embed": {},
      "thumbnail_width": 140,
      "author_flair_template_id": "5cb3c302-0ef5-11ed-b9fd-aab9a872a9c2",
      "is_original_content": false,
      "user_reports": [],
      "secure_media": null,
      "is_reddit_media_domain": false,
      "is_meta": false,
      "category": null,
      "secure_media_embed": {},
      "link_flair_text": ":Games: Games",
      "can_mod_post": false,
      "score": 8,
      "approved_by": null,
      "is_created_from_ads_ui": false,
      "author_premium": false,
      "thumbnail": "https://b.thumbs.redditmedia.com/4CLDvdqmPVHesahFyGEtOhXJY_nR4li_jFtQsmqyAWM.jpg",
      "edited": 1680072486.0,
      "author_flair_css_class": null,
      "author_flair_richtext": [
        {
          "a": ":400K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/apsbyvbwmfe91_t5_2qknj/400K"
        },
        {
          "a": ":Arduino_500k:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/o5qzzwwkvk5a1_t5_2qknj/Arduino_500k"
        },
        {
          "a": ":600K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/z23hxjk4hpeb1_t5_2qknj/600K"
        },
        {
          "a": ":640K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/g9r24xjaydqc1_t5_2qknj/640K"
        },
        {
          "e": "text",
          "t": " My other dev board is a Porsche"
        }
      ],
      "gildings": {},
      "post_hint": "self",
      "content_categories": null,
      "is_self": true,
      "subreddit_type": "public",
      "created": 1679683472.0,
      "link_flair_type": "richtext",
      "wls": 6,
      "removed_by_category": null,
      "banned_by": null,
      "author_flair_type": "richtext",
      "domain": "self.arduino",
      "allow_live_comments": false,
      "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Happy Friday!&lt;/p&gt;\n\n&lt;p&gt;This is the second post in a series about writing a chess engine for the Arduino platform. All Arduinos except the &lt;em&gt;ATTiny&lt;/em&gt; series (&lt;em&gt;still may be possible&lt;/em&gt; \ud83e\uddd0) are supported &lt;em&gt;including the Uno and the Nano!&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;The first post &lt;a href=\"https://www.reddit.com/r/arduino/comments/11q4916/so_you_want_to_build_a_chess_engine/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;can be found here&lt;/a&gt; and &lt;a href=\"https://www.reddit.com/r/arduino/comments/123f5q3/microchess_move_evaluation_function/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;the next posts are here&lt;/a&gt; and &lt;a href=\"https://www.reddit.com/r/arduino/comments/125ezne/microchess_update_money_for_nothing/?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3\"&gt;here&lt;/a&gt;. The repository for the &lt;strong&gt;MicroChess&lt;/strong&gt; project &lt;a href=\"https://github.com/ripred/MicroChess\"&gt;can be found here&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;A ton has been added since the first post in this series. There are bugs and the code is a work in progress but all commits and pushes compile and run. About 60% of the engine is implemented in some form or another. Note that &lt;strong&gt;only the Pawn and Knight pieces have been fully implemented and lightly tested&lt;/strong&gt; as of this writing even though there are placeholders (really crude and ugly placeholders) implemented for the other pieces as well. We&amp;#39;ll get into the code for each &lt;code&gt;Piece&lt;/code&gt; individually later on in future posts in the series.&lt;/p&gt;\n\n&lt;h1&gt;Architecture&lt;/h1&gt;\n\n&lt;p&gt;This post is about the basic architecture of the chess engine. This is likely to change in the future but I needed to get some basic scaffolding in place in order to develop the Arduino version. 95% of the code is brand-new and written for this project specifically. I will document any major architectural changes in future posts in the series when they happen. The C and C++ code rely heavily on the use of &lt;em&gt;bitfields, the ternary operator,&lt;/em&gt; and &lt;em&gt;lambda&lt;/em&gt; functions, for memory savings, readability, code density, and avoiding unneeded polution of the global namespace. These will be covered and fully explained as they are encountered in later posts.&lt;/p&gt;\n\n&lt;h1&gt;board_t&lt;/h1&gt;\n\n&lt;p&gt;The &lt;code&gt;board_t&lt;/code&gt; structure was introduced in the first post of the series and is still currently used. The &lt;code&gt;board_t&lt;/code&gt; data type is responsible for storing the pieces that are on the board and the attributes for those pieces such as their piece &lt;strong&gt;&lt;em&gt;type&lt;/em&gt;&lt;/strong&gt;, their &lt;strong&gt;&lt;em&gt;color&lt;/em&gt;&lt;/strong&gt;, whether the piece has been &lt;strong&gt;&lt;em&gt;moved&lt;/em&gt;&lt;/strong&gt;, and whether the piece is in &lt;strong&gt;&lt;em&gt;check&lt;/em&gt;&lt;/strong&gt;, for each of the 64 board locations. The &lt;code&gt;board_t&lt;/code&gt; has 3 simple public methods available:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;init()&lt;/code&gt; - initialize the pieces on the board for a new game&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;get(index_t index)&lt;/code&gt; - gets the &lt;code&gt;Piece&lt;/code&gt; at the specified location. The &lt;code&gt;index&lt;/code&gt; parameter should be in the range of 0 - 63.&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;set(index_t index, Piece p)&lt;/code&gt; - sets the &lt;code&gt;Piece&lt;/code&gt; at the specified location. The &lt;code&gt;index&lt;/code&gt; parameter should be in the range of 0 - 63.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;At each location of the board is stored a &lt;code&gt;Piece&lt;/code&gt;. A &lt;code&gt;Piece&lt;/code&gt; contains 4 pieces of information about any piece at a location:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;3 bits for the type of &lt;code&gt;Piece&lt;/code&gt; at that location. The following &lt;code&gt;Piece&lt;/code&gt; types are available:&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// The Piece types\nstatic Piece const Empty  = 0u;\nstatic Piece const Pawn   = 1u;\nstatic Piece const Knight = 2u;\nstatic Piece const Bishop = 3u;\nstatic Piece const Rook   = 4u;\nstatic Piece const Queen  = 5u;\nstatic Piece const King   = 6u;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;ul&gt;\n&lt;li&gt;1 bit for the &lt;code&gt;Color&lt;/code&gt;, or side the piece belongs to. 0 indicates the piece is a black piece and 1 indicates the piece is a white piece.&lt;/li&gt;\n&lt;li&gt;1 bit for the moved state of the &lt;code&gt;Piece&lt;/code&gt;. The moved state is 0 if the piece has not been moved and is 1 once the piece has been moved. This is used to determine whether &lt;code&gt;Pawns&lt;/code&gt; can move to the second row on their first move, and whether the &lt;code&gt;King&lt;/code&gt; and either &lt;code&gt;Rook&lt;/code&gt; can castle or not. Note that castling has not been implemented yet.&lt;/li&gt;\n&lt;li&gt;1 bit for the check state of the &lt;code&gt;Piece&lt;/code&gt;. This will be used later on to highlight pieces that are under threat as well as to check when a move has put one of the kings in check or not.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h1&gt;game_t&lt;/h1&gt;\n\n&lt;p&gt;The other major data type used is the &lt;code&gt;game_t&lt;/code&gt; structure. The &lt;code&gt;game_t&lt;/code&gt; data type keeps track of everything else about a running game. Eventually the &lt;code&gt;game_t&lt;/code&gt; may likely evolve to contain the &lt;code&gt;board_t&lt;/code&gt; for the game but for now there are two global variables defined for the &lt;em&gt;singleton&lt;/em&gt; &lt;code&gt;board&lt;/code&gt; and &lt;code&gt;game&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In the other chess engines I have previously written I have always scanned the board at all 64 spots and if a spot was not &lt;code&gt;Empty&lt;/code&gt; then I would process the &lt;code&gt;Piece&lt;/code&gt; at that location. For this microcontroller version I decided that was inefficient because at the very least; A full half of the 64 spots processed will be &lt;code&gt;Empty.&lt;/code&gt; And as the game progresses and more pieces are taken then the number of spots processed that will be &lt;code&gt;Empty&lt;/code&gt; will only get bigger and more time would be wasted. So for this version I keep track of an array of x,y points, one for each active piece in the game. The array is stored in the &lt;code&gt;game_t&lt;/code&gt; object along with an 8-bit integer indicating how many &lt;code&gt;Pieces&lt;/code&gt; are currently active. In this way we can loop through only where the pieces are stored on the board extremely fast and not have to examine any other locations when examinging pieces and enumerating the possible moves.&lt;/p&gt;\n\n&lt;p&gt;The full declaration for the current version of the &lt;code&gt;game_t&lt;/code&gt; structure is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#pragma pack(0)\n\nstruct game_t {\npublic:\n    point_t   pieces[MAX_PIECES];     // MAX_PIECES = 32\n    move_t    moves1[MAX_MOVES];      // MAX_MOVES = 106\n    move_t    moves2[MAX_MOVES];\n    Piece     taken1[16];\n    Piece     taken2[16];\n    Bool      white_king_in_check;\n    Bool      black_king_in_check;\n    move_t    last_move;\n    uint8_t   piece_count;\n    uint8_t   move_count1;\n    uint8_t   move_count2;\n    uint8_t   max_moves;\n    uint8_t   taken_count1;\n    uint8_t   taken_count2;\n    uint8_t   eval_ndx,     // board index being currently evaluated\n              turn,         // 0 := Black, 1 := White\n              move_num,     // increasing move number, 0-based\n              done;         // 1 := game over\n\npublic:\n    &amp;lt;snip...&amp;gt;\n};\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Hopefully most of the fields in the structure are self explanatory. Please post comments with any questions you have about any fields in the &lt;code&gt;game_t&lt;/code&gt; structure.&lt;/p&gt;\n\n&lt;p&gt;For completeness here are the &lt;code&gt;point_t&lt;/code&gt; and &lt;code&gt;move_t&lt;/code&gt; structures:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;enum {\n    ...\n    NUM_BITS_PT   =   5,  // bits per field in point_t struct\n    NUM_BITS_SPOT =   7,  // bits per field in move_t struct\n    ...\n};\n\nstruct point_t \n{\npublic:\n    index_t  x : NUM_BITS_PT, \n             y : NUM_BITS_PT;\n\npublic:\n    point_t() : x(0), y(0) {}\n    point_t(index_t X, index_t Y) : x(X), y(Y) {}\n\n};  // point_t\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that the &lt;code&gt;point_t&lt;/code&gt; type keeps the column and row on the board separate. The index into the &lt;code&gt;board_t&lt;/code&gt; for a given piece in the &lt;code&gt;game.pieces[32]&lt;/code&gt; array can be determined by calculating:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;board index (0 - 63) = point_t.y * 8 + point_t.x\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;index_t&lt;/code&gt; type is a &lt;code&gt;signed char&lt;/code&gt; (&lt;code&gt;int8_t&lt;/code&gt;) as we need to occassionaly do calculations using coordinates that may be negative (off of the board) during traversal and move generation.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct move_t \n{\npublic:\n    int32_t  from : NUM_BITS_SPOT, \n               to : NUM_BITS_SPOT,\n            value : ((sizeof(int32_t) * 8) - (NUM_BITS_SPOT * 2));\n\npublic:\n    move_t() : from(0), to(0), value(0) {}\n    move_t(index_t f, index_t t, long v) : from(f), to(t), value(v) {}\n\n};  // move_t\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; fields of the &lt;code&gt;move_t&lt;/code&gt; structure are the 0 - 63 indexes of the &lt;em&gt;starting&lt;/em&gt; spot and the &lt;em&gt;ending&lt;/em&gt; spot on the board for each move for each piece. The &lt;code&gt;value&lt;/code&gt; associated with each &lt;code&gt;move_t&lt;/code&gt; is the &lt;strong&gt;&lt;em&gt;score&lt;/em&gt;&lt;/strong&gt; of the board &lt;em&gt;after that move has been made&lt;/em&gt;.&lt;/p&gt;\n\n&lt;p&gt;So for example, when the game first starts up the &lt;code&gt;Piece&lt;/code&gt;&amp;#39;s are all on the board at array entries &lt;code&gt;board[0]&lt;/code&gt; thru &lt;code&gt;board[15]&lt;/code&gt; for the black pieces (the two top rows) and at &lt;code&gt;board[56]&lt;/code&gt; thru &lt;code&gt;board[63]&lt;/code&gt; for the white pieces (the bottom two rows):&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://preview.redd.it/5gj8caul2spa1.png?width=320&amp;amp;format=png&amp;amp;auto=webp&amp;amp;s=1ab1ef2e0f1bc52a840905f6ce4fb89015f62098\"&gt;the board[64] array, shown with indexes and column and row numbers (rank and file)&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;As mentioned, the location of pieces are translated back and forth between &lt;em&gt;col/row&lt;/em&gt; and board &lt;em&gt;index&lt;/em&gt; (0 - 63) throughout the code using the following idioms:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;col = index % 8;\nrow = index / 8;\n\nand \n\nindex = col + row * 8\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And the &lt;code&gt;game.pieces[32]&lt;/code&gt; array holds the &lt;code&gt;point_t&lt;/code&gt; &lt;em&gt;col/row&lt;/em&gt; values for all of the pieces:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;game.pieces[ 0] = { 0, 0 }    // black rook\ngame.pieces[ 1] = { 1, 0 }    // black knight\ngame.pieces[ 2] = { 2, 0 }    // black bishop\ngame.pieces[ 3] = { 3, 0 }    // ...\ngame.pieces[ 4] = { 4, 0 }\ngame.pieces[ 5] = { 5, 0 }\ngame.pieces[ 6] = { 6, 0 }\ngame.pieces[ 7] = { 7, 0 }\ngame.pieces[ 8] = { 0, 1 }    // black pawns\ngame.pieces[ 9] = { 1, 1 }\ngame.pieces[10] = { 2, 1 }\ngame.pieces[11] = { 3, 1 }\ngame.pieces[12] = { 4, 1 }\ngame.pieces[13] = { 5, 1 }\ngame.pieces[14] = { 6, 1 }\ngame.pieces[15] = { 7, 1 }\ngame.pieces[16] = { 0, 6 }    // white pawns\ngame.pieces[17] = { 1, 6 }\ngame.pieces[18] = { 2, 6 }\ngame.pieces[19] = { 3, 6 }\ngame.pieces[20] = { 4, 6 }\ngame.pieces[21] = { 5, 6 }\ngame.pieces[22] = { 6, 6 }\ngame.pieces[23] = { 7, 6 }\ngame.pieces[24] = { 0, 7 }    // white rook\ngame.pieces[25] = { 1, 7 }    // white knight\ngame.pieces[26] = { 2, 7 }    // white bishop\ngame.pieces[27] = { 3, 7 }    // ...\ngame.pieces[28] = { 4, 7 }\ngame.pieces[29] = { 5, 7 }\ngame.pieces[30] = { 6, 7 }\ngame.pieces[31] = { 7, 7 }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And it is &lt;em&gt;this&lt;/em&gt; &lt;code&gt;game.pieces[]&lt;/code&gt; list that we iterate through when evaluating all of the pieces and what moves they can make. The number of pieces currently left in the game is stored in &lt;code&gt;game.piece_count&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;And speaking of the board &lt;strong&gt;&lt;em&gt;score&lt;/em&gt;&lt;/strong&gt;; &lt;strong&gt;In the next post of the series&lt;/strong&gt; we will go over the &lt;code&gt;evaluation(...)&lt;/code&gt; function that is used to determine the value identity for a given board arrangement when calculating what the value of each available move is so we can pick the best!&lt;/p&gt;\n\n&lt;p&gt;As a teaser; Here is the updated view of the output of the program to the &lt;code&gt;Serial&lt;/code&gt; window (remember only the pawns and knights are enabled right now):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Move #13: White Pawn from: 6,6 (G2) to: 6,4 (G4)\n\n8  r  .  b  q  k  b  n  r \n7  p  *  p  *  .  p  p  p     Last Move: G2 to G4\n6  *  n  *  .  *  .  *  . \n5  .  p  .  *  .  *  .  *     Taken 1: \n4  *  P  *  p  p  P  P  P     Taken 2: P P \n3  .  N  .  *  .  *  .  * \n2  P  .  P  .  *  .  *  .     Board value:     -230 Black&amp;#39;s favor\n1  R  *  B  Q  K  B  N  R \n   A  B  C  D  E  F  G  H\n\n&amp;lt;snip..&amp;gt;\n\ngame hash: 000089A3, profiling...\nstarting..\nfinished.\n\n0  r  .  Q  q  k  b  *  r \n1  .  *  .  *  P  *  .  *     Last Move: A3 to A2\n2  *  P  *  .  *  .  n  . \n3  .  N  .  *  .  *  P  *     Taken 1: p p p p p b \n4  *  .  *  .  *  .  p  .     Taken 2: P P P P B Q \n5  .  *  .  *  .  *  N  * \n6  n  .  *  .  *  .  *  .     Board value:     -373 Black&amp;#39;s favor\n7  R  *  q  q  K  B  .  R \n   0  1  2  3  4  5  6  7\n\ntotal game time: 1102 ms\nmax move count: 17\ntotal game moves evaluated: 728\nmoves per second: 660.6171 \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;output window:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Sketch uses 16494 bytes (53%) of program storage space. Maximum \nis 30720 bytes. Global variables use 1480 bytes (72%) of dynamic \nmemory, leaving 568 bytes for local variables. Maximum is 2048 \nbytes.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;See ya then!&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ripred&lt;/code&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
      "likes": null,
      "suggested_sort": "confidence",
      "banned_at_utc": null,
      "view_count": null,
      "archived": false,
      "no_follow": false,
      "is_crosspostable": false,
      "pinned": false,
      "over_18": false,
      "preview": {
        "images": [
          {
            "source": {
              "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?auto=webp&amp;s=e4333ee9f745f9b130c347425d80cb9ac703583b",
              "width": 1200,
              "height": 600
            },
            "resolutions": [
              {
                "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=62e6ebc220e9e1122f33de1abc461e469f44a0a1",
                "width": 108,
                "height": 54
              },
              {
                "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=1f06b46a7e4ae5ffb1fb9e1812c6ff0bc1bce467",
                "width": 216,
                "height": 108
              },
              {
                "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=dfe958f21f822e290e18997cc8d2a5007a88d721",
                "width": 320,
                "height": 160
              },
              {
                "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=16aabd5f36fd0cd7dcf33bdf248a635c475b9d2d",
                "width": 640,
                "height": 320
              },
              {
                "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=a3d7969970a1f655af7d9b3ea72ba35b2f601b36",
                "width": 960,
                "height": 480
              },
              {
                "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=a05e2fd77fd8b220bae94e3ff5ca571b1db3852c",
                "width": 1080,
                "height": 540
              }
            ],
            "variants": {},
            "id": "T01InclRGT3UP9qroFRaBj0_w22sDRkZFB1H7x211Xo"
          }
        ],
        "enabled": false
      },
      "all_awardings": [],
      "awarders": [],
      "media_only": false,
      "link_flair_template_id": "1072597c-c1d8-11ed-a4a8-869232c38365",
      "can_gild": false,
      "spoiler": false,
      "locked": false,
      "author_flair_text": ":400K::Arduino_500k::600K::640K: My other dev board is a Porsche",
      "treatment_tags": [],
      "visited": false,
      "removed_by": null,
      "mod_note": null,
      "distinguished": null,
      "subreddit_id": "t5_2qknj",
      "author_is_blocked": false,
      "mod_reason_by": null,
      "num_reports": null,
      "removal_reason": null,
      "link_flair_background_color": "#0266b3",
      "id": "120trd9",
      "is_robot_indexable": true,
      "report_reasons": null,
      "author": "ripred3",
      "discussion_type": null,
      "num_comments": 2,
      "send_replies": true,
      "contest_mode": false,
      "mod_reports": [],
      "author_patreon_flair": false,
      "author_flair_text_color": "light",
      "permalink": "/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/",
      "stickied": false,
      "url": "https://www.reddit.com/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/",
      "subreddit_subscribers": 691374,
      "created_utc": 1679683472.0,
      "num_crossposts": 6,
      "media": null,
      "is_video": false
    }
  ],
  "created": 1679700202.0,
  "link_flair_type": "text",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "text",
  "domain": "self.arduino",
  "allow_live_comments": false,
  "selftext_html": null,
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "url_overridden_by_dest": "/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/",
  "view_count": null,
  "archived": false,
  "no_follow": false,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "preview": {
    "images": [
      {
        "source": {
          "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?auto=webp&amp;s=e4333ee9f745f9b130c347425d80cb9ac703583b",
          "width": 1200,
          "height": 600
        },
        "resolutions": [
          {
            "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=62e6ebc220e9e1122f33de1abc461e469f44a0a1",
            "width": 108,
            "height": 54
          },
          {
            "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=1f06b46a7e4ae5ffb1fb9e1812c6ff0bc1bce467",
            "width": 216,
            "height": 108
          },
          {
            "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=dfe958f21f822e290e18997cc8d2a5007a88d721",
            "width": 320,
            "height": 160
          },
          {
            "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=16aabd5f36fd0cd7dcf33bdf248a635c475b9d2d",
            "width": 640,
            "height": 320
          },
          {
            "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=a3d7969970a1f655af7d9b3ea72ba35b2f601b36",
            "width": 960,
            "height": 480
          },
          {
            "url": "https://external-preview.redd.it/Fv1kG023T2qjgWyceALUEyiDwi7LrbFBsYT4dPxFxRY.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=a05e2fd77fd8b220bae94e3ff5ca571b1db3852c",
            "width": 1080,
            "height": 540
          }
        ],
        "variants": {},
        "id": "T01InclRGT3UP9qroFRaBj0_w22sDRkZFB1H7x211Xo"
      }
    ],
    "enabled": false
  },
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": null,
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_7yd5re",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "",
  "id": "1212och",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "crosspost_parent": "t3_120trd9",
  "author_flair_text_color": null,
  "permalink": "/r/Arduino_AI/comments/1212och/so_you_want_to_build_a_chess_engine_part2/",
  "stickied": false,
  "url": "/r/arduino/comments/120trd9/so_you_want_to_build_a_chess_engine_part2/",
  "subreddit_subscribers": 3137,
  "created_utc": 1679700202.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}