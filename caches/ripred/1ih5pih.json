{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "",
  "user_reports": [],
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "High-Frequency PWM Waveform Generator with RC Filter \u2013 A DIY Analog Signal Generator for Audio &amp; Control!",
  "link_flair_richtext": [],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": null,
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_1ih5pih",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "author_fullname": "t2_adfkq",
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": null,
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "default",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "content_categories": null,
  "is_self": false,
  "mod_note": null,
  "crosspost_parent_list": [
    {
      "approved_at_utc": null,
      "subreddit": "arduino",
      "selftext": "After seeing another community members great post about controlling the internal AVR Timers about a week ago I was inspired to tackle making a decent waveform generator, using two timers and custom PWM generator code based off of one of the timers with the other timer updating the PWM value 256 times/sec. I think it's pretty good and only requires a 1K resistor and a 10nF cap and it outputs starting on pin 9 and then goes to the RC filter. \n\nThe sketch is capable of producing Square, Sawtooth, and Sine waves in the range from DC to around 1KHz. (the actual PWM rate used to accomplish this can go up to 62.5KHz). It uses two timers at the same time to shape and produce the final waveform.\n\nThe user is prompted to tell it what kind of waveform to produce, and then what frequency, through the serial debug window and then the values are computed and used.\n  \n**Wiring the Hardware:**\n\n1. Upload the sketch to your Arduino Uno.\n2. Connect the PWM output (pin 9) to one end of a 470 \u03a9 resistor.\n3. Connect the other end of the 470 \u03a9 resistor to a common node.\n4. Connect a 10 nF capacitor from that node to ground.\n5. (Optional) If you plan to drive a low-impedance load like an amplifier, connect the common node to the non-inverting input of a voltage-follower op-amp (e.g., LM358 with the inverting input connected to the output), and use the op-amp\u2019s output as the final analog signal.\n6. Ensure that the Arduino\u2019s ground, the capacitor\u2019s ground, and any\n additional circuit grounds are connected together.\n\n**Starting the Software:**\n\nOpen the Serial Monitor (set the baud rate to 115200).The program will prompt you first to enter a waveform type:Next, enter your desired waveform frequency in Hertz (for example, 100 for a 100 Hz tone). \n\n**1** for Square **2** for Sawtooth **3** for Sine.\n\nExample output:\n\n    High-Frequency PWM Waveform Generator\n    ======================================\n    Enter waveform type (1 = square, 2 = sawtooth, 3 = sine):\n    3\n    Waveform type: 3\n    Enter desired waveform frequency in Hz (e.g., 100):\n    500\n    Waveform frequency: 500 Hz\n    Computed sample rate: 32000 Hz\n    Setup complete.\n    Remember to apply the RC low-pass filter (e.g., 470 \u03a9 resistor + 10 nF capacitor) to PWM output on pin 9.\n\n\nThe Code:\n\n    /*\n     * High-Frequency PWM Waveform Generator with RC Filter\n     *\n     * This sketch generates one of three waveforms (square, sawtooth, sine)\n     * by updating the PWM duty cycle on pin 9 at a rate determined by the desired\n     * waveform frequency and the number of samples per period.\n     *\n     * The PWM output is filtered through an external RC low-pass filter \n     * (e.g., a 470 \u03a9 resistor in series with a 10 nF capacitor to ground) \n     * to produce a smooth analog voltage.\n     *\n     * User inputs (via Serial Monitor):\n     *   - Waveform type: 1 = square, 2 = sawtooth, 3 = sine.\n     *   - Desired waveform frequency in Hz.\n     *\n     * NOTE on Serial Input:\n     * A custom function getInput() is used to prompt for and retrieve a complete,\n     * non-empty line from the Serial Monitor without inserting delays. This avoids\n     * the problem of leftover end-of-line characters (EOL's) being interpreted as\n     * empty input.\n     *\n     * For more information on the Serial API, see:\n     *   - Serial.begin(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/begin/\n     *   - Serial.available(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/available/\n     *   - Serial.readStringUntil(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/readstringuntil/\n     *\n     * ++u/ripred3 \u2013 Feb 3, 2025\n     *\n     */\n    \n    #include &lt;Arduino.h&gt;\n    #include &lt;avr/interrupt.h&gt;\n    #include &lt;avr/pgmspace.h&gt;\n    \n    #define NUM_SAMPLES 64      // Number of samples per waveform period\n    #define PWM_PIN 9           // PWM output pin (Timer1 output)\n    \n    // ---------- Global Variables ----------\n    volatile uint8_t waveform_type = 0;   // 1: square, 2: sawtooth, 3: sine\n    volatile uint16_t sample_index = 0;   // Current index for waveform sample progression\n    volatile uint8_t saw_value = 0;       // Sawtooth waveform current value\n    \n    // ---------- Sine Wave Lookup Table (8-bit values: 0-255) ----------\n    const uint8_t sine_table[NUM_SAMPLES] PROGMEM = {\n      128, 140, 152, 163, 173, 182, 189, 195,\n      200, 203, 205, 205, 203, 200, 195, 189,\n      182, 173, 163, 152, 140, 128, 115, 102,\n       90,  79,  70,  63,  57,  53,  51,  51,\n       53,  57,  63,  70,  79,  90, 102, 115,\n      128, 140, 152, 163, 173, 182, 189, 195,\n      200, 203, 205, 205, 203, 200, 195, 189,\n      182, 173, 163, 152, 140, 128, 115, 102\n    };\n    \n    // ---------- Timer2 Prescaler Options ----------\n    struct PrescalerOption {\n      uint16_t prescaler;\n      uint8_t cs_bits;  // Clock select bits for Timer2 (CS22:0)\n    };\n    \n    PrescalerOption options[] = {\n      {1,    (1 &lt;&lt; CS20)},\n      {8,    (1 &lt;&lt; CS21)},\n      {32,   (1 &lt;&lt; CS21) | (1 &lt;&lt; CS20)},\n      {64,   (1 &lt;&lt; CS22)},\n      {128,  (1 &lt;&lt; CS22) | (1 &lt;&lt; CS20)},\n      {256,  (1 &lt;&lt; CS22) | (1 &lt;&lt; CS21)},\n      {1024, (1 &lt;&lt; CS22) | (1 &lt;&lt; CS21) | (1 &lt;&lt; CS20)}\n    };\n    #define NUM_OPTIONS (sizeof(options) / sizeof(options[0]))\n    \n    // ---------- Timer2 ISR: Updates PWM Duty Cycle ----------\n    ISR(TIMER2_COMPA_vect) {\n      uint8_t output_val = 0;\n      \n      switch (waveform_type) {\n        case 1: // Square wave: output 255 for first half of samples, then 0.\n          output_val = (sample_index &lt; (NUM_SAMPLES / 2)) ? 255 : 0;\n          break;\n          \n        case 2: // Sawtooth wave: continuously increment value.\n          output_val = saw_value;\n          saw_value++;  // 8-bit arithmetic wraps from 255 back to 0.\n          break;\n          \n        case 3: // Sine wave: retrieve value from lookup table.\n          output_val = pgm_read_byte(&amp;(sine_table[sample_index]));\n          break;\n          \n        default:\n          output_val = 0;\n          break;\n      }\n      \n      sample_index++;\n      if (sample_index &gt;= NUM_SAMPLES) {\n        sample_index = 0;\n      }\n      \n      // Update Timer1's PWM duty cycle by writing to OCR1A.\n      OCR1A = output_val;\n    }\n    \n    // ---------- Function: getInput -----------------\n    // Prompts the user and waits (busy-waiting) for a non-empty line from the Serial Monitor.\n    // Uses Serial.available() and Serial.readStringUntil() without adding delay() calls.\n    // For Serial API details, see:\n    //   - Serial.available(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/available/\n    //   - Serial.readStringUntil(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/readstringuntil/\n    String getInput(const char* prompt) {\n      Serial.println(prompt);\n      String input = \"\";\n      // Busy-wait until a non-empty line is received.\n      while (input.length() == 0) {\n        if (Serial.available() &gt; 0) {\n          input = Serial.readStringUntil('\\n');\n          input.trim(); // Remove any whitespace or EOL characters.\n        }\n      }\n      return input;\n    }\n    \n    // ---------- Setup Timer2 for Waveform Updates ----------\n    void setup_timer2(uint32_t sample_rate) {\n      uint8_t chosen_cs = 0;\n      uint16_t chosen_ocr = 0;\n      \n      // Determine a prescaler option yielding OCR2A &lt;= 255.\n      for (uint8_t i = 0; i &lt; NUM_OPTIONS; i++) {\n        uint32_t ocr = (F_CPU / (options[i].prescaler * sample_rate)) - 1;\n        if (ocr &lt;= 255) {\n          chosen_cs = options[i].cs_bits;\n          chosen_ocr = ocr;\n          break;\n        }\n      }\n      \n      // If no valid prescaler was found, use the maximum prescaler.\n      if (chosen_cs == 0) {\n        chosen_cs = options[NUM_OPTIONS - 1].cs_bits;\n        chosen_ocr = 255;\n      }\n      \n      cli();  // Disable interrupts during Timer2 configuration.\n      \n      TCCR2A = 0;\n      TCCR2B = 0;\n      TCNT2  = 0;\n      \n      TCCR2A |= (1 &lt;&lt; WGM21);  // Set Timer2 to CTC mode.\n      OCR2A = chosen_ocr;\n      TCCR2B |= chosen_cs;\n      TIMSK2 |= (1 &lt;&lt; OCIE2A); // Enable Timer2 Compare Match interrupt.\n      \n      sei();  // Re-enable interrupts.\n    }\n    \n    // ---------- Setup Timer1 for PWM Output on Pin 9 ----------\n    void setup_timer1_pwm() {\n      pinMode(PWM_PIN, OUTPUT);\n      \n      cli(); // Disable interrupts during Timer1 configuration.\n      \n      TCCR1A = 0;\n      TCCR1B = 0;\n      TCNT1  = 0;\n      \n      // Configure Timer1 for 8-bit Fast PWM on channel A (pin 9) in non-inverting mode.\n      TCCR1A |= (1 &lt;&lt; WGM10) | (1 &lt;&lt; COM1A1);\n      TCCR1B |= (1 &lt;&lt; CS10);  // No prescaling: PWM frequency \u2248 16MHz/256 \u2248 62.5 kHz.\n      \n      sei(); // Re-enable interrupts.\n    }\n    \n    // ---------- Setup Function ----------\n    void setup() {\n      Serial.begin(115200);  // Preferred baud rate.\n      while (!Serial) { }     // Wait for the Serial Monitor connection.\n      \n      Serial.println(F(\"High-Frequency PWM Waveform Generator\"));\n      Serial.println(F(\"======================================\"));\n      \n      // --- Get Waveform Type ---\n      String typeString = getInput(\"Enter waveform type (1 = square, 2 = sawtooth, 3 = sine):\");\n      waveform_type = typeString.toInt();\n      Serial.print(F(\"Waveform type: \"));\n      Serial.println(waveform_type);\n      \n      // --- Get Desired Waveform Frequency ---\n      String freqString = getInput(\"Enter desired waveform frequency in Hz (e.g., 100):\");\n      uint32_t waveform_freq = freqString.toInt();\n      Serial.print(F(\"Waveform frequency: \"));\n      Serial.print(waveform_freq);\n      Serial.println(F(\" Hz\"));\n      \n      // Compute the sample rate as: waveform frequency * NUM_SAMPLES.\n      uint32_t sample_rate = waveform_freq * NUM_SAMPLES;\n      Serial.print(F(\"Computed sample rate: \"));\n      Serial.print(sample_rate);\n      Serial.println(F(\" Hz\"));\n      \n      // Initialize PWM on Timer1.\n      setup_timer1_pwm();\n      \n      // Initialize Timer2 to update the PWM duty cycle.\n      setup_timer2(sample_rate);\n      \n      Serial.println(F(\"Setup complete.\"));\n      Serial.println(F(\"Remember to apply the RC low-pass filter (e.g., 470 \u03a9 resistor + 10 nF capacitor) to PWM output on pin 9.\"));\n    }\n    \n    // ---------- Main Loop ----------\n    void loop() {\n      // No processing is needed here as waveform generation is handled in the Timer2 ISR.\n      // The loop remains empty to allow uninterrupted timer interrupts.\n    }\n\nLet me know if I screwed anything up.\n\nCheers!\n\n`ripred`\n\n",
      "author_fullname": "t2_adfkq",
      "saved": false,
      "mod_reason_title": null,
      "gilded": 0,
      "clicked": false,
      "title": "High-Frequency PWM Waveform Generator with RC Filter \u2013 A DIY Analog Signal Generator for Audio &amp; Control!",
      "link_flair_richtext": [
        {
          "e": "text",
          "t": "Look what I made!"
        }
      ],
      "subreddit_name_prefixed": "r/arduino",
      "hidden": false,
      "pwls": 6,
      "link_flair_css_class": "",
      "downs": 0,
      "thumbnail_height": null,
      "top_awarded_type": null,
      "hide_score": false,
      "name": "t3_1igkdtr",
      "quarantine": false,
      "link_flair_text_color": "dark",
      "upvote_ratio": 1.0,
      "author_flair_background_color": "#00a6a5",
      "subreddit_type": "public",
      "ups": 4,
      "total_awards_received": 0,
      "media_embed": {},
      "thumbnail_width": null,
      "author_flair_template_id": "5cb3c302-0ef5-11ed-b9fd-aab9a872a9c2",
      "is_original_content": false,
      "user_reports": [],
      "secure_media": null,
      "is_reddit_media_domain": false,
      "is_meta": false,
      "category": null,
      "secure_media_embed": {},
      "link_flair_text": "Look what I made!",
      "can_mod_post": false,
      "score": 4,
      "approved_by": null,
      "is_created_from_ads_ui": false,
      "author_premium": false,
      "thumbnail": "self",
      "edited": 1738574137.0,
      "author_flair_css_class": null,
      "author_flair_richtext": [
        {
          "a": ":400K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/apsbyvbwmfe91_t5_2qknj/400K"
        },
        {
          "a": ":Arduino_500k:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/o5qzzwwkvk5a1_t5_2qknj/Arduino_500k"
        },
        {
          "a": ":600K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/z23hxjk4hpeb1_t5_2qknj/600K"
        },
        {
          "a": ":640K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/g9r24xjaydqc1_t5_2qknj/640K"
        },
        {
          "e": "text",
          "t": " My other dev board is a Porsche"
        }
      ],
      "gildings": {},
      "content_categories": null,
      "is_self": true,
      "mod_note": null,
      "created": 1738570622.0,
      "link_flair_type": "richtext",
      "wls": 6,
      "removed_by_category": null,
      "banned_by": null,
      "author_flair_type": "richtext",
      "domain": "self.arduino",
      "allow_live_comments": false,
      "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;After seeing another community members great post about controlling the internal AVR Timers about a week ago I was inspired to tackle making a decent waveform generator, using two timers and custom PWM generator code based off of one of the timers with the other timer updating the PWM value 256 times/sec. I think it&amp;#39;s pretty good and only requires a 1K resistor and a 10nF cap and it outputs starting on pin 9 and then goes to the RC filter. &lt;/p&gt;\n\n&lt;p&gt;The sketch is capable of producing Square, Sawtooth, and Sine waves in the range from DC to around 1KHz. (the actual PWM rate used to accomplish this can go up to 62.5KHz). It uses two timers at the same time to shape and produce the final waveform.&lt;/p&gt;\n\n&lt;p&gt;The user is prompted to tell it what kind of waveform to produce, and then what frequency, through the serial debug window and then the values are computed and used.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Wiring the Hardware:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Upload the sketch to your Arduino Uno.&lt;/li&gt;\n&lt;li&gt;Connect the PWM output (pin 9) to one end of a 470 \u03a9 resistor.&lt;/li&gt;\n&lt;li&gt;Connect the other end of the 470 \u03a9 resistor to a common node.&lt;/li&gt;\n&lt;li&gt;Connect a 10 nF capacitor from that node to ground.&lt;/li&gt;\n&lt;li&gt;(Optional) If you plan to drive a low-impedance load like an amplifier, connect the common node to the non-inverting input of a voltage-follower op-amp (e.g., LM358 with the inverting input connected to the output), and use the op-amp\u2019s output as the final analog signal.&lt;/li&gt;\n&lt;li&gt;Ensure that the Arduino\u2019s ground, the capacitor\u2019s ground, and any\nadditional circuit grounds are connected together.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;&lt;strong&gt;Starting the Software:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Open the Serial Monitor (set the baud rate to 115200).The program will prompt you first to enter a waveform type:Next, enter your desired waveform frequency in Hertz (for example, 100 for a 100 Hz tone). &lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt; for Square &lt;strong&gt;2&lt;/strong&gt; for Sawtooth &lt;strong&gt;3&lt;/strong&gt; for Sine.&lt;/p&gt;\n\n&lt;p&gt;Example output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;High-Frequency PWM Waveform Generator\n======================================\nEnter waveform type (1 = square, 2 = sawtooth, 3 = sine):\n3\nWaveform type: 3\nEnter desired waveform frequency in Hz (e.g., 100):\n500\nWaveform frequency: 500 Hz\nComputed sample rate: 32000 Hz\nSetup complete.\nRemember to apply the RC low-pass filter (e.g., 470 \u03a9 resistor + 10 nF capacitor) to PWM output on pin 9.\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The Code:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * High-Frequency PWM Waveform Generator with RC Filter\n *\n * This sketch generates one of three waveforms (square, sawtooth, sine)\n * by updating the PWM duty cycle on pin 9 at a rate determined by the desired\n * waveform frequency and the number of samples per period.\n *\n * The PWM output is filtered through an external RC low-pass filter \n * (e.g., a 470 \u03a9 resistor in series with a 10 nF capacitor to ground) \n * to produce a smooth analog voltage.\n *\n * User inputs (via Serial Monitor):\n *   - Waveform type: 1 = square, 2 = sawtooth, 3 = sine.\n *   - Desired waveform frequency in Hz.\n *\n * NOTE on Serial Input:\n * A custom function getInput() is used to prompt for and retrieve a complete,\n * non-empty line from the Serial Monitor without inserting delays. This avoids\n * the problem of leftover end-of-line characters (EOL&amp;#39;s) being interpreted as\n * empty input.\n *\n * For more information on the Serial API, see:\n *   - Serial.begin(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/begin/\n *   - Serial.available(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/available/\n *   - Serial.readStringUntil(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/readstringuntil/\n *\n * ++u/ripred3 \u2013 Feb 3, 2025\n *\n */\n\n#include &amp;lt;Arduino.h&amp;gt;\n#include &amp;lt;avr/interrupt.h&amp;gt;\n#include &amp;lt;avr/pgmspace.h&amp;gt;\n\n#define NUM_SAMPLES 64      // Number of samples per waveform period\n#define PWM_PIN 9           // PWM output pin (Timer1 output)\n\n// ---------- Global Variables ----------\nvolatile uint8_t waveform_type = 0;   // 1: square, 2: sawtooth, 3: sine\nvolatile uint16_t sample_index = 0;   // Current index for waveform sample progression\nvolatile uint8_t saw_value = 0;       // Sawtooth waveform current value\n\n// ---------- Sine Wave Lookup Table (8-bit values: 0-255) ----------\nconst uint8_t sine_table[NUM_SAMPLES] PROGMEM = {\n  128, 140, 152, 163, 173, 182, 189, 195,\n  200, 203, 205, 205, 203, 200, 195, 189,\n  182, 173, 163, 152, 140, 128, 115, 102,\n   90,  79,  70,  63,  57,  53,  51,  51,\n   53,  57,  63,  70,  79,  90, 102, 115,\n  128, 140, 152, 163, 173, 182, 189, 195,\n  200, 203, 205, 205, 203, 200, 195, 189,\n  182, 173, 163, 152, 140, 128, 115, 102\n};\n\n// ---------- Timer2 Prescaler Options ----------\nstruct PrescalerOption {\n  uint16_t prescaler;\n  uint8_t cs_bits;  // Clock select bits for Timer2 (CS22:0)\n};\n\nPrescalerOption options[] = {\n  {1,    (1 &amp;lt;&amp;lt; CS20)},\n  {8,    (1 &amp;lt;&amp;lt; CS21)},\n  {32,   (1 &amp;lt;&amp;lt; CS21) | (1 &amp;lt;&amp;lt; CS20)},\n  {64,   (1 &amp;lt;&amp;lt; CS22)},\n  {128,  (1 &amp;lt;&amp;lt; CS22) | (1 &amp;lt;&amp;lt; CS20)},\n  {256,  (1 &amp;lt;&amp;lt; CS22) | (1 &amp;lt;&amp;lt; CS21)},\n  {1024, (1 &amp;lt;&amp;lt; CS22) | (1 &amp;lt;&amp;lt; CS21) | (1 &amp;lt;&amp;lt; CS20)}\n};\n#define NUM_OPTIONS (sizeof(options) / sizeof(options[0]))\n\n// ---------- Timer2 ISR: Updates PWM Duty Cycle ----------\nISR(TIMER2_COMPA_vect) {\n  uint8_t output_val = 0;\n\n  switch (waveform_type) {\n    case 1: // Square wave: output 255 for first half of samples, then 0.\n      output_val = (sample_index &amp;lt; (NUM_SAMPLES / 2)) ? 255 : 0;\n      break;\n\n    case 2: // Sawtooth wave: continuously increment value.\n      output_val = saw_value;\n      saw_value++;  // 8-bit arithmetic wraps from 255 back to 0.\n      break;\n\n    case 3: // Sine wave: retrieve value from lookup table.\n      output_val = pgm_read_byte(&amp;amp;(sine_table[sample_index]));\n      break;\n\n    default:\n      output_val = 0;\n      break;\n  }\n\n  sample_index++;\n  if (sample_index &amp;gt;= NUM_SAMPLES) {\n    sample_index = 0;\n  }\n\n  // Update Timer1&amp;#39;s PWM duty cycle by writing to OCR1A.\n  OCR1A = output_val;\n}\n\n// ---------- Function: getInput -----------------\n// Prompts the user and waits (busy-waiting) for a non-empty line from the Serial Monitor.\n// Uses Serial.available() and Serial.readStringUntil() without adding delay() calls.\n// For Serial API details, see:\n//   - Serial.available(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/available/\n//   - Serial.readStringUntil(): https://docs.arduino.cc/reference/en/language/functions/communication/serial/readstringuntil/\nString getInput(const char* prompt) {\n  Serial.println(prompt);\n  String input = &amp;quot;&amp;quot;;\n  // Busy-wait until a non-empty line is received.\n  while (input.length() == 0) {\n    if (Serial.available() &amp;gt; 0) {\n      input = Serial.readStringUntil(&amp;#39;\\n&amp;#39;);\n      input.trim(); // Remove any whitespace or EOL characters.\n    }\n  }\n  return input;\n}\n\n// ---------- Setup Timer2 for Waveform Updates ----------\nvoid setup_timer2(uint32_t sample_rate) {\n  uint8_t chosen_cs = 0;\n  uint16_t chosen_ocr = 0;\n\n  // Determine a prescaler option yielding OCR2A &amp;lt;= 255.\n  for (uint8_t i = 0; i &amp;lt; NUM_OPTIONS; i++) {\n    uint32_t ocr = (F_CPU / (options[i].prescaler * sample_rate)) - 1;\n    if (ocr &amp;lt;= 255) {\n      chosen_cs = options[i].cs_bits;\n      chosen_ocr = ocr;\n      break;\n    }\n  }\n\n  // If no valid prescaler was found, use the maximum prescaler.\n  if (chosen_cs == 0) {\n    chosen_cs = options[NUM_OPTIONS - 1].cs_bits;\n    chosen_ocr = 255;\n  }\n\n  cli();  // Disable interrupts during Timer2 configuration.\n\n  TCCR2A = 0;\n  TCCR2B = 0;\n  TCNT2  = 0;\n\n  TCCR2A |= (1 &amp;lt;&amp;lt; WGM21);  // Set Timer2 to CTC mode.\n  OCR2A = chosen_ocr;\n  TCCR2B |= chosen_cs;\n  TIMSK2 |= (1 &amp;lt;&amp;lt; OCIE2A); // Enable Timer2 Compare Match interrupt.\n\n  sei();  // Re-enable interrupts.\n}\n\n// ---------- Setup Timer1 for PWM Output on Pin 9 ----------\nvoid setup_timer1_pwm() {\n  pinMode(PWM_PIN, OUTPUT);\n\n  cli(); // Disable interrupts during Timer1 configuration.\n\n  TCCR1A = 0;\n  TCCR1B = 0;\n  TCNT1  = 0;\n\n  // Configure Timer1 for 8-bit Fast PWM on channel A (pin 9) in non-inverting mode.\n  TCCR1A |= (1 &amp;lt;&amp;lt; WGM10) | (1 &amp;lt;&amp;lt; COM1A1);\n  TCCR1B |= (1 &amp;lt;&amp;lt; CS10);  // No prescaling: PWM frequency \u2248 16MHz/256 \u2248 62.5 kHz.\n\n  sei(); // Re-enable interrupts.\n}\n\n// ---------- Setup Function ----------\nvoid setup() {\n  Serial.begin(115200);  // Preferred baud rate.\n  while (!Serial) { }     // Wait for the Serial Monitor connection.\n\n  Serial.println(F(&amp;quot;High-Frequency PWM Waveform Generator&amp;quot;));\n  Serial.println(F(&amp;quot;======================================&amp;quot;));\n\n  // --- Get Waveform Type ---\n  String typeString = getInput(&amp;quot;Enter waveform type (1 = square, 2 = sawtooth, 3 = sine):&amp;quot;);\n  waveform_type = typeString.toInt();\n  Serial.print(F(&amp;quot;Waveform type: &amp;quot;));\n  Serial.println(waveform_type);\n\n  // --- Get Desired Waveform Frequency ---\n  String freqString = getInput(&amp;quot;Enter desired waveform frequency in Hz (e.g., 100):&amp;quot;);\n  uint32_t waveform_freq = freqString.toInt();\n  Serial.print(F(&amp;quot;Waveform frequency: &amp;quot;));\n  Serial.print(waveform_freq);\n  Serial.println(F(&amp;quot; Hz&amp;quot;));\n\n  // Compute the sample rate as: waveform frequency * NUM_SAMPLES.\n  uint32_t sample_rate = waveform_freq * NUM_SAMPLES;\n  Serial.print(F(&amp;quot;Computed sample rate: &amp;quot;));\n  Serial.print(sample_rate);\n  Serial.println(F(&amp;quot; Hz&amp;quot;));\n\n  // Initialize PWM on Timer1.\n  setup_timer1_pwm();\n\n  // Initialize Timer2 to update the PWM duty cycle.\n  setup_timer2(sample_rate);\n\n  Serial.println(F(&amp;quot;Setup complete.&amp;quot;));\n  Serial.println(F(&amp;quot;Remember to apply the RC low-pass filter (e.g., 470 \u03a9 resistor + 10 nF capacitor) to PWM output on pin 9.&amp;quot;));\n}\n\n// ---------- Main Loop ----------\nvoid loop() {\n  // No processing is needed here as waveform generation is handled in the Timer2 ISR.\n  // The loop remains empty to allow uninterrupted timer interrupts.\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Let me know if I screwed anything up.&lt;/p&gt;\n\n&lt;p&gt;Cheers!&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ripred&lt;/code&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
      "likes": null,
      "suggested_sort": "confidence",
      "banned_at_utc": null,
      "view_count": null,
      "archived": false,
      "no_follow": false,
      "is_crosspostable": false,
      "pinned": false,
      "over_18": false,
      "all_awardings": [],
      "awarders": [],
      "media_only": false,
      "link_flair_template_id": "8a993096-51ce-11e9-84d9-0e29268ab306",
      "can_gild": false,
      "spoiler": false,
      "locked": false,
      "author_flair_text": ":400K::Arduino_500k::600K::640K: My other dev board is a Porsche",
      "treatment_tags": [],
      "visited": false,
      "removed_by": null,
      "num_reports": null,
      "distinguished": null,
      "subreddit_id": "t5_2qknj",
      "author_is_blocked": false,
      "mod_reason_by": null,
      "removal_reason": null,
      "link_flair_background_color": "#94e044",
      "id": "1igkdtr",
      "is_robot_indexable": true,
      "report_reasons": null,
      "author": "ripred3",
      "discussion_type": null,
      "num_comments": 2,
      "send_replies": true,
      "contest_mode": false,
      "mod_reports": [],
      "author_patreon_flair": false,
      "author_flair_text_color": "light",
      "permalink": "/r/arduino/comments/1igkdtr/highfrequency_pwm_waveform_generator_with_rc/",
      "stickied": false,
      "url": "https://www.reddit.com/r/arduino/comments/1igkdtr/highfrequency_pwm_waveform_generator_with_rc/",
      "subreddit_subscribers": 691390,
      "created_utc": 1738570622.0,
      "num_crossposts": 2,
      "media": null,
      "is_video": false
    }
  ],
  "created": 1738631565.0,
  "link_flair_type": "text",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "",
  "allow_live_comments": false,
  "selftext_html": null,
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "url_overridden_by_dest": "/r/arduino/comments/1igkdtr/highfrequency_pwm_waveform_generator_with_rc/",
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "",
  "id": "1ih5pih",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "crosspost_parent": "t3_1igkdtr",
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/1ih5pih/highfrequency_pwm_waveform_generator_with_rc/",
  "stickied": false,
  "url": "/r/arduino/comments/1igkdtr/highfrequency_pwm_waveform_generator_with_rc/",
  "subreddit_subscribers": 43,
  "created_utc": 1738631565.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}