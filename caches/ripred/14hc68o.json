{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "This post is about the advantages of breaking your project up into multiple CPU's. This kind of system can make robotics and animatronics *much more fluid and organic*. \n\nAnd it can actually make some projects easier to accomplish because one CPU isn't trying to juggle all of the interrupts and timings for a complicated system all by itself at the same time.\n\n***Imagine*** your robot with a dedicated processor just for the left motor, and another processor just for the right motor, both independently taking care of keeping each motor at the speed they were last told to keep it at, in a tight control loop. Maybe each dedicated motor CPU also takes care of receiving pulses from an an interrupt-driven encoder that's attached to the motor so that it takes care of everything just for that motor and the main microcontroller in the project; The \"Brains\", just has to tell the motors what number of encoder pulses to drive themselves at and what direction to go (or none at all - stop) at and it doesn't even have to deal with the interrupts!\n\n***Or*** imagine having a project that needs 10 rotary encoder controls on a panel. Good luck keeping up with all of those with the focus (bandwidth) available from just one microcontroller!\n\n***Or*** maybe in your project you want a tight, deterministic foreground loop with regular periodicity to run a PID loop, and supporting all of the devices in the project makes managing the foreground and background compute times nearly impossible.\n\n***Maybe*** you have some I2C devices that won't allow you to change their I2C address but you want to put several of them on the same I2C bus. You can easily fix that by having a separate small processor in front of the devices acting as a proxy and each using a different I2C address completely of your own choosing!\n\n***Maybe*** you're making a game and you'd like it to be fast and responsive to the user and also have dynamic, multi-channel polyphonic background music that plays all the time without stuttering and stopping.\n\n**All** of those kinds of problems can be solved or made into smaller and easier problems by splitting the tasks needed in your project into separate subsystems, each complete with their own dedicated processor. Brains!\n\nIn this series we'll build out a set of 8-pin ATtiny85 microcontrollers, each with a different dedicated function, and each one acting as an independent, addressable I2C device. Then we'll connect them all using only 2 pins to the main controller: an ATmega328! Along the way we'll develop a standard packet structure and communications system that we can re-use over-and-over in other projects.",
  "author_fullname": "t2_adfkq",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "Building a Parallel Multi-Processor Project - Part 1",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Guide "
    }
  ],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_14hc68o",
  "quarantine": false,
  "link_flair_text_color": null,
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 3,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Guide ",
  "can_mod_post": false,
  "score": 3,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": 1687937490.0,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1687560293.0,
  "link_flair_type": "richtext",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.ripred",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;This post is about the advantages of breaking your project up into multiple CPU&amp;#39;s. This kind of system can make robotics and animatronics &lt;em&gt;much more fluid and organic&lt;/em&gt;. &lt;/p&gt;\n\n&lt;p&gt;And it can actually make some projects easier to accomplish because one CPU isn&amp;#39;t trying to juggle all of the interrupts and timings for a complicated system all by itself at the same time.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;Imagine&lt;/em&gt;&lt;/strong&gt; your robot with a dedicated processor just for the left motor, and another processor just for the right motor, both independently taking care of keeping each motor at the speed they were last told to keep it at, in a tight control loop. Maybe each dedicated motor CPU also takes care of receiving pulses from an an interrupt-driven encoder that&amp;#39;s attached to the motor so that it takes care of everything just for that motor and the main microcontroller in the project; The &amp;quot;Brains&amp;quot;, just has to tell the motors what number of encoder pulses to drive themselves at and what direction to go (or none at all - stop) at and it doesn&amp;#39;t even have to deal with the interrupts!&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt; imagine having a project that needs 10 rotary encoder controls on a panel. Good luck keeping up with all of those with the focus (bandwidth) available from just one microcontroller!&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;Or&lt;/em&gt;&lt;/strong&gt; maybe in your project you want a tight, deterministic foreground loop with regular periodicity to run a PID loop, and supporting all of the devices in the project makes managing the foreground and background compute times nearly impossible.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;Maybe&lt;/em&gt;&lt;/strong&gt; you have some I2C devices that won&amp;#39;t allow you to change their I2C address but you want to put several of them on the same I2C bus. You can easily fix that by having a separate small processor in front of the devices acting as a proxy and each using a different I2C address completely of your own choosing!&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;em&gt;Maybe&lt;/em&gt;&lt;/strong&gt; you&amp;#39;re making a game and you&amp;#39;d like it to be fast and responsive to the user and also have dynamic, multi-channel polyphonic background music that plays all the time without stuttering and stopping.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;All&lt;/strong&gt; of those kinds of problems can be solved or made into smaller and easier problems by splitting the tasks needed in your project into separate subsystems, each complete with their own dedicated processor. Brains!&lt;/p&gt;\n\n&lt;p&gt;In this series we&amp;#39;ll build out a set of 8-pin ATtiny85 microcontrollers, each with a different dedicated function, and each one acting as an independent, addressable I2C device. Then we&amp;#39;ll connect them all using only 2 pins to the main controller: an ATmega328! Along the way we&amp;#39;ll develop a standard packet structure and communications system that we can re-use over-and-over in other projects.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": false,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "2667fddc-0562-11ed-bd6e-427c07716391",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#ffd635",
  "id": "14hc68o",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/14hc68o/building_a_parallel_multiprocessor_project_part_1/",
  "stickied": false,
  "url": "https://www.reddit.com/r/ripred/comments/14hc68o/building_a_parallel_multiprocessor_project_part_1/",
  "subreddit_subscribers": 43,
  "created_utc": 1687560293.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}