{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "One of the most critical decisions in building a chess engine is how to represent the game state. This isn't just about storing pieces on a board - it's about organizing data in a way that enables efficient move generation, position evaluation, and search, all while minimizing memory usage.\n\nLet's start with what at first seems like a simple challenge: how to store information about each square on the board. A naive approach might look something like this:\n\n```\nstruct Square {\n    uint8_t pieceType;   // what kind of piece is here\n    uint8_t color;       // which side the piece belongs to\n    bool hasMoved;       // has this piece moved (for castling/pawns)\n    bool inCheck;        // is this piece in check\n};\n\nSquare board[64];        // the complete chess board\n```\n\nThis would work, but it would use 4 bytes per square, or 256 bytes just for the board! On an Arduino with only 2KB of RAM, that's already using 12.5% of our available memory - and we haven't even started storing move lists, search trees, or any other game state.\n\n### The Power of Bit-Packing\nThis is where bit-packing comes in. Let's analyze exactly what information we need to store:\n```\n// Piece type needs 3 bits (7 possibilities):\nEmpty  = 0   // 000\nPawn   = 1   // 001\nKnight = 2   // 010\nBishop = 3   // 011\nRook   = 4   // 100\nQueen  = 5   // 101\nKing   = 6   // 110\n\n// Color needs 1 bit:\nBlack = 0\nWhite = 1\n\n// Movement and check status each need 1 bit\n```\n\nThis totals to 6 bits per square. Through careful use of bit fields, we can pack all this information into a single byte. But we can do even better through clever use of unions and bit alignment. Here's where things get interesting:\n```\nstruct conv1_t {\nprivate:\n    union {\n        struct {\n            uint8_t     col : 3,    // The column value (0-7)\n                        row : 3,    // The row value (0-7)\n                       type : 3,    // Piece type\n                       side : 1;    // Color (black/white)\n        } pt;                      \n        struct {\n            uint8_t   index : 6,    // Board index (0-63)\n                       type : 3,    // Piece type\n                       side : 1;    // Color\n        } ndx;                      \n    } u;\n};\n```\nThis structure is doing something quite clever. By aligning our bit fields in a specific way, we get automatic conversion between board coordinates (row/column) and linear board index. When we store a row and column, the bits naturally align to create the correct board index. When we store a board index, it automatically decomposes into the correct row and column values.\n\n### The Magic of Binary\n\nTo understand why this works, let's look at how board indices relate to rows and columns:\n```\nBoard Index = row * 8 + column\n\nFor example:\nrow 2, column 3:\n2 * 8 + 3 = 19\n\nIn binary:\n2 = 010\n3 = 011\n19 = 010011\n```\nNotice how the binary representation of the index (010011) contains both the row (010) and column (011) within it! By carefully aligning our bit fields, we get this conversion for free, saving both code space and execution time.\n\n### Building on the Foundation\n\nWe use this same principle to create our move representation:\n```\nstruct conv2_t {\nprivate:\n    conv1_t   from, to;\n\npublic:\n    /**\n     * @brief Default constructor. Initializes both positions to (0, 0).\n     */\n    conv2_t() : from(), to() {}\n\n    /**\n     * @brief Constructor that takes the indices of the start and end positions.\n     *\n     * @param from_index The index of the starting position.\n     * @param to_index The index of the ending position.\n     */\n    conv2_t(uint8_t from_index, uint8_t to_index)\n        : from(from_index), to(to_index) {}\n\n    /**\n     * @brief Constructor that takes the coordinates of the start and end positions.\n     *\n     * @param from_col The column of the starting position.\n     * @param from_row The row of the starting position.\n     * @param to_col The column of the ending position.\n     * @param to_row The row of the ending position.\n     */\n    conv2_t(uint8_t from_col, uint8_t from_row, uint8_t to_col, uint8_t to_row)\n        : from(from_col, from_row), to(to_col, to_row) {}\n\n    /**\n     * @brief Constructor that takes two `conv1_t` objects to represent the start and end positions.\n     *\n     * @param from_ The starting position.\n     * @param to_ The ending position.\n     */\n    conv2_t(const conv1_t&amp; from_, const conv1_t&amp; to_)\n        : from(from_), to(to_) {}\n\n    void set_from_index(uint8_t value) { from.set_index(value); }\n    void set_from_col(uint8_t value) { from.set_col(value); }\n    void set_from_row(uint8_t value) { from.set_row(value); }\n    void set_from_type(uint8_t value) { from.set_type(value); }\n    void set_from_side(uint8_t value) { from.set_side(value); }\n\n    void set_to_index(uint8_t value) { to.set_index(value); }\n    void set_to_col(uint8_t value) { to.set_col(value); }\n    void set_to_row(uint8_t value) { to.set_row(value); }\n    void set_to_type(uint8_t value) { to.set_type(value); }\n    void set_to_side(uint8_t value) { to.set_side(value); }\n\n    uint8_t get_from_index() const { return from.get_index(); }\n    uint8_t get_from_col() const { return from.get_col(); }\n    uint8_t get_from_row() const { return from.get_row(); }\n    uint8_t get_from_type() const { return from.get_type(); }\n    uint8_t get_from_side() const { return from.get_side(); }\n\n    uint8_t get_to_index() const { return to.get_index(); }\n    uint8_t get_to_col() const { return to.get_col(); }\n    uint8_t get_to_row() const { return to.get_row(); }\n    uint8_t get_to_type() const { return to.get_type(); }\n    uint8_t get_to_side() const { return to.get_side(); }\n\n};  // conv2_t\n```\n\nThis gives us a complete move representation that is both memory efficient and quick to manipulate. The `conv2_t` structure forms the basis for our move generation and evaluation system.\n\nIn the next article, we'll look at how we use these data structures to efficiently generate and track all possible moves in a position. We'll see how our careful attention to memory layout pays off when we need to analyze thousands of positions per second.\n\n",
  "author_fullname": "t2_adfkq",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "Article 2: Core Data Structures - The Foundation of Our Engine",
  "link_flair_richtext": [],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": null,
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_1if1pr1",
  "quarantine": false,
  "link_flair_text_color": "dark",
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 2,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": null,
  "can_mod_post": false,
  "score": 2,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1738397270.0,
  "link_flair_type": "text",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.ripred",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;One of the most critical decisions in building a chess engine is how to represent the game state. This isn&amp;#39;t just about storing pieces on a board - it&amp;#39;s about organizing data in a way that enables efficient move generation, position evaluation, and search, all while minimizing memory usage.&lt;/p&gt;\n\n&lt;p&gt;Let&amp;#39;s start with what at first seems like a simple challenge: how to store information about each square on the board. A naive approach might look something like this:&lt;/p&gt;\n\n&lt;p&gt;```\nstruct Square {\n    uint8_t pieceType;   // what kind of piece is here\n    uint8_t color;       // which side the piece belongs to\n    bool hasMoved;       // has this piece moved (for castling/pawns)\n    bool inCheck;        // is this piece in check\n};&lt;/p&gt;\n\n&lt;p&gt;Square board[64];        // the complete chess board\n```&lt;/p&gt;\n\n&lt;p&gt;This would work, but it would use 4 bytes per square, or 256 bytes just for the board! On an Arduino with only 2KB of RAM, that&amp;#39;s already using 12.5% of our available memory - and we haven&amp;#39;t even started storing move lists, search trees, or any other game state.&lt;/p&gt;\n\n&lt;h3&gt;The Power of Bit-Packing&lt;/h3&gt;\n\n&lt;p&gt;This is where bit-packing comes in. Let&amp;#39;s analyze exactly what information we need to store:\n```\n// Piece type needs 3 bits (7 possibilities):\nEmpty  = 0   // 000\nPawn   = 1   // 001\nKnight = 2   // 010\nBishop = 3   // 011\nRook   = 4   // 100\nQueen  = 5   // 101\nKing   = 6   // 110&lt;/p&gt;\n\n&lt;p&gt;// Color needs 1 bit:\nBlack = 0\nWhite = 1&lt;/p&gt;\n\n&lt;p&gt;// Movement and check status each need 1 bit\n```&lt;/p&gt;\n\n&lt;p&gt;This totals to 6 bits per square. Through careful use of bit fields, we can pack all this information into a single byte. But we can do even better through clever use of unions and bit alignment. Here&amp;#39;s where things get interesting:\n&lt;code&gt;\nstruct conv1_t {\nprivate:\n    union {\n        struct {\n            uint8_t     col : 3,    // The column value (0-7)\n                        row : 3,    // The row value (0-7)\n                       type : 3,    // Piece type\n                       side : 1;    // Color (black/white)\n        } pt;                      \n        struct {\n            uint8_t   index : 6,    // Board index (0-63)\n                       type : 3,    // Piece type\n                       side : 1;    // Color\n        } ndx;                      \n    } u;\n};\n&lt;/code&gt;\nThis structure is doing something quite clever. By aligning our bit fields in a specific way, we get automatic conversion between board coordinates (row/column) and linear board index. When we store a row and column, the bits naturally align to create the correct board index. When we store a board index, it automatically decomposes into the correct row and column values.&lt;/p&gt;\n\n&lt;h3&gt;The Magic of Binary&lt;/h3&gt;\n\n&lt;p&gt;To understand why this works, let&amp;#39;s look at how board indices relate to rows and columns:\n```\nBoard Index = row * 8 + column&lt;/p&gt;\n\n&lt;p&gt;For example:\nrow 2, column 3:\n2 * 8 + 3 = 19&lt;/p&gt;\n\n&lt;p&gt;In binary:\n2 = 010\n3 = 011\n19 = 010011\n```\nNotice how the binary representation of the index (010011) contains both the row (010) and column (011) within it! By carefully aligning our bit fields, we get this conversion for free, saving both code space and execution time.&lt;/p&gt;\n\n&lt;h3&gt;Building on the Foundation&lt;/h3&gt;\n\n&lt;p&gt;We use this same principle to create our move representation:\n```\nstruct conv2_t {\nprivate:\n    conv1_t   from, to;&lt;/p&gt;\n\n&lt;p&gt;public:\n    /**\n     * @brief Default constructor. Initializes both positions to (0, 0).\n     */\n    conv2_t() : from(), to() {}&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/**\n * @brief Constructor that takes the indices of the start and end positions.\n *\n * @param from_index The index of the starting position.\n * @param to_index The index of the ending position.\n */\nconv2_t(uint8_t from_index, uint8_t to_index)\n    : from(from_index), to(to_index) {}\n\n/**\n * @brief Constructor that takes the coordinates of the start and end positions.\n *\n * @param from_col The column of the starting position.\n * @param from_row The row of the starting position.\n * @param to_col The column of the ending position.\n * @param to_row The row of the ending position.\n */\nconv2_t(uint8_t from_col, uint8_t from_row, uint8_t to_col, uint8_t to_row)\n    : from(from_col, from_row), to(to_col, to_row) {}\n\n/**\n * @brief Constructor that takes two `conv1_t` objects to represent the start and end positions.\n *\n * @param from_ The starting position.\n * @param to_ The ending position.\n */\nconv2_t(const conv1_t&amp;amp; from_, const conv1_t&amp;amp; to_)\n    : from(from_), to(to_) {}\n\nvoid set_from_index(uint8_t value) { from.set_index(value); }\nvoid set_from_col(uint8_t value) { from.set_col(value); }\nvoid set_from_row(uint8_t value) { from.set_row(value); }\nvoid set_from_type(uint8_t value) { from.set_type(value); }\nvoid set_from_side(uint8_t value) { from.set_side(value); }\n\nvoid set_to_index(uint8_t value) { to.set_index(value); }\nvoid set_to_col(uint8_t value) { to.set_col(value); }\nvoid set_to_row(uint8_t value) { to.set_row(value); }\nvoid set_to_type(uint8_t value) { to.set_type(value); }\nvoid set_to_side(uint8_t value) { to.set_side(value); }\n\nuint8_t get_from_index() const { return from.get_index(); }\nuint8_t get_from_col() const { return from.get_col(); }\nuint8_t get_from_row() const { return from.get_row(); }\nuint8_t get_from_type() const { return from.get_type(); }\nuint8_t get_from_side() const { return from.get_side(); }\n\nuint8_t get_to_index() const { return to.get_index(); }\nuint8_t get_to_col() const { return to.get_col(); }\nuint8_t get_to_row() const { return to.get_row(); }\nuint8_t get_to_type() const { return to.get_type(); }\nuint8_t get_to_side() const { return to.get_side(); }\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;};  // conv2_t\n```&lt;/p&gt;\n\n&lt;p&gt;This gives us a complete move representation that is both memory efficient and quick to manipulate. The &lt;code&gt;conv2_t&lt;/code&gt; structure forms the basis for our move generation and evaluation system.&lt;/p&gt;\n\n&lt;p&gt;In the next article, we&amp;#39;ll look at how we use these data structures to efficiently generate and track all possible moves in a position. We&amp;#39;ll see how our careful attention to memory layout pays off when we need to analyze thousands of positions per second.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": false,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "",
  "id": "1if1pr1",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/1if1pr1/article_2_core_data_structures_the_foundation_of/",
  "stickied": false,
  "url": "https://www.reddit.com/r/ripred/comments/1if1pr1/article_2_core_data_structures_the_foundation_of/",
  "subreddit_subscribers": 43,
  "created_utc": 1738397270.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}