{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "",
  "user_reports": [],
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "Since we're all showing 3D rendering on our screens...",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Hardware"
    }
  ],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_16th93t",
  "quarantine": false,
  "link_flair_text_color": "light",
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "author_fullname": "t2_adfkq",
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Hardware",
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "default",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "content_categories": null,
  "is_self": false,
  "mod_note": null,
  "crosspost_parent_list": [
    {
      "approved_at_utc": null,
      "subreddit": "arduino",
      "selftext": "All 3D calculations, rotations, spinning, drawing instructions, background scolling, sun animations and touch screen I/O are being done on an **Uno R3** with a Gameduino 2 display. \ud83d\ude43 I was one of the original Kickstarter sponsors for the project! Example code that came with it for this below the video:\n\nCheers!\n\n`ripred`\n\n[Gameduino 2 running on an old school Arduino R3 with USB-A adapter](https://reddit.com/link/16tgqas/video/2p2e7bdjwrqb1/player)\n\n    #include &lt;EEPROM.h&gt;\n    #include &lt;SPI.h&gt;\n    #include &lt;GD2.h&gt;\n    \n    #include \"cobra_assets.h\"\n    \n    ////////////////////////////////////////////////////////////////////////////////\n    //                                  3D Projection\n    ////////////////////////////////////////////////////////////////////////////////\n    \n    static byte VXSCALE = 16;\n    \n    static float model_mat[9] = { 1.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0,\n                            0.0, 0.0, 1.0 };\n    static float normal_mat[9] = { 1.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0,\n                            0.0, 0.0, 1.0 };\n    \n    #define M(nm,i,j)       ((nm)[3 * (i) + (j)])\n    \n    void mult_matrices(float *a, float *b, float *c)\n    {\n      int i, j, k;\n      float result[9];\n      for(i = 0; i &lt; 3; i++) {\n        for(j = 0; j &lt; 3; j++) {\n          M(result,i,j) = 0.0f;\n          for(k = 0; k &lt; 3; k++) {\n            M(result,i,j) +=  M(a,i,k) *  M(b,k,j);\n          }\n        }\n      }\n      memcpy(c, result, sizeof(result));\n    }\n    \n    // Based on glRotate()\n    // Returns 3x3 rotation matrix in 'm'\n    // and its invese in 'mi'\n    \n    static void rotate(float *m, float *mi, float angle, float *axis)\n    {\n      float x = axis[0];\n      float y = axis[1];\n      float z = axis[2];\n    \n      float s = sin(angle);\n      float c = cos(angle);\n    \n      float xx = x*x*(1-c);\n      float xy = x*y*(1-c);\n      float xz = x*z*(1-c);\n      float yy = y*y*(1-c);\n      float yz = y*z*(1-c);\n      float zz = z*z*(1-c);\n    \n      float xs = x * s;\n      float ys = y * s;\n      float zs = z * s;\n    \n      m[0] = xx + c;\n      m[1] = xy - zs;\n      m[2] = xz + ys;\n    \n      m[3] = xy + zs;\n      m[4] = yy + c;\n      m[5] = yz - xs;\n    \n      m[6] = xz - ys;\n      m[7] = yz + xs;\n      m[8] = zz + c;\n    \n      mi[0] = m[0];\n      mi[1] = xy + zs;\n      mi[2] = xz - ys;\n    \n      mi[3] = xy - zs;\n      mi[4] = m[4];\n      mi[5] = yz + xs;\n    \n      mi[6] = xz + ys;\n      mi[7] = yz - xs;\n      mi[8] = m[8];\n    }\n    \n    static void rotation(float angle, float *axis)\n    {\n      float mat[9];\n      float mati[9];\n    \n      rotate(mat, mati, angle, axis);\n      mult_matrices(model_mat, mat, model_mat);\n      mult_matrices(mati, normal_mat, normal_mat);\n    }\n    \n    \n    #define N_VERTICES  (sizeof(COBRA_vertices) / 3)\n    \n    typedef struct {\n      int x, y;\n      float z;\n    } xyz;\n    \n    static xyz projected[N_VERTICES];\n    \n    void project(float distance)\n    {\n      const PROGMEM int8_t *pm = COBRA_vertices;\n      const PROGMEM int8_t *pm_e = pm + sizeof(COBRA_vertices);\n      xyz *dst = projected;\n      int8_t x, y, z;\n      int hw = GD.w / 2;\n    \n      while (pm &lt; pm_e) {\n        x = pgm_read_byte_near(pm++);\n        y = pgm_read_byte_near(pm++);\n        z = pgm_read_byte_near(pm++);\n        float xx = x * model_mat[0] + y * model_mat[3] + z * model_mat[6];\n        float yy = x * model_mat[1] + y * model_mat[4] + z * model_mat[7];\n        float zz = x * model_mat[2] + y * model_mat[5] + z * model_mat[8] + distance;\n        float q = hw / (100 + zz);\n        dst-&gt;x = VXSCALE * (hw       + xx * q);\n        dst-&gt;y = VXSCALE * (GD.h / 2 + yy * q);\n        dst-&gt;z = zz;\n        dst++;\n      }\n    }\n    \n    static void transform_normal(int8_t &amp;nx, int8_t &amp;ny, int8_t &amp;nz)\n    {\n      int8_t xx = nx * normal_mat[0] + ny * normal_mat[1] + nz * normal_mat[2];\n      int8_t yy = nx * normal_mat[3] + ny * normal_mat[4] + nz * normal_mat[5];\n      int8_t zz = nx * normal_mat[6] + ny * normal_mat[7] + nz * normal_mat[8];\n      nx = xx;\n      ny = yy;\n      nz = zz;\n    }\n    \n    #define EDGE_BYTES  5\n    static byte visible_edges[EDGE_BYTES];\n    \n    void draw_faces()\n    {\n      memset(visible_edges, 0, sizeof(visible_edges));\n    \n      const PROGMEM int8_t *p = COBRA_faces;\n      byte n;\n      int c = 1;\n      Poly po;\n      while ((n = pgm_read_byte_near(p++)) != 0xff) {\n        int8_t nx = pgm_read_byte_near(p++);\n        int8_t ny = pgm_read_byte_near(p++);\n        int8_t nz = pgm_read_byte_near(p++);\n        byte face_edges[EDGE_BYTES];\n        for (byte i = 0; i &lt; EDGE_BYTES; i++)\n          face_edges[i] = pgm_read_byte_near(p++);\n        byte v1 = pgm_read_byte_near(p);\n        byte v2 = pgm_read_byte_near(p + 1);\n        byte v3 = pgm_read_byte_near(p + 2);\n        long x1 = projected[v1].x;\n        long y1 = projected[v1].y;\n        long x2 = projected[v2].x;\n        long y2 = projected[v2].y;\n        long x3 = projected[v3].x;\n        long y3 = projected[v3].y;\n        long area = (x1 - x3) * (y2 - y1) - (x1 - x2) * (y3 - y1);\n    \n        if (area &gt; 0) {\n          for (byte i = 0; i &lt; EDGE_BYTES; i++)\n            visible_edges[i] |= face_edges[i];\n          po.begin();\n          for (int i = 0; i &lt; n; i++) {\n            byte vi = pgm_read_byte_near(p++);\n            xyz *v = &amp;projected[vi];\n            po.v(v-&gt;x, v-&gt;y);\n          }\n          {\n            transform_normal(nx, ny, nz);\n    \n            uint16_t r = 10, g = 10, b = 20;  // Ambient\n    \n            int d = -ny;                      // diffuse light from +ve Y\n            if (d &gt; 0) {\n              r += d &gt;&gt; 2;\n              g += d &gt;&gt; 1;\n              b += d;\n            }\n                                              // use specular half angle\n            d = ny * -90 + nz * -90;          // Range -16384 to +16384\n            if (d &gt; 8192) {\n              byte l = pgm_read_byte_near(shiny + ((d - 8192) &gt;&gt; 4));\n              r += l;\n              g += l;\n              b += l;\n            }\n    \n            GD.ColorRGB(min(255, r), min(255, g), min(255, b));\n          }\n          po.draw();\n        } else {\n          p += n;\n        }\n        c += 1;\n      }\n    }\n    \n    void draw_edges()\n    {\n      GD.ColorRGB(0x2e666e);\n      GD.Begin(LINES);\n      GD.LineWidth(20);\n    \n      const PROGMEM uint8_t *p = COBRA_edges;\n      byte *pvis = visible_edges;\n      byte vis = 0;\n    \n      for (byte i = 0; i &lt; sizeof(COBRA_edges) / 2; i++) {\n        if ((i &amp; 7) == 0)\n          vis = *pvis++;\n        byte v0 = pgm_read_byte_near(p++);\n        byte v1 = pgm_read_byte_near(p++);\n    \n        if (vis &amp; 1) {\n          int x0 = projected[v0].x;\n          int y0 = projected[v0].y;\n          int x1 = projected[v1].x;\n          int y1 = projected[v1].y;\n    \n          GD.Vertex2f(x0,y0);\n          GD.Vertex2f(x1,y1);\n        }\n        vis &gt;&gt;= 1;\n      }\n    }\n    \n    static void draw_navlight(byte nf)\n    {\n      float l0z = projected[N_VERTICES - 2].z;\n      float l1z = projected[N_VERTICES - 1].z;\n      byte i;\n      if (nf == 0)  // draw the one with smallest z\n        i = (l0z &lt; l1z) ? (N_VERTICES - 2) : (N_VERTICES - 1);\n      else\n        i = (l0z &lt; l1z) ? (N_VERTICES - 1) : (N_VERTICES - 2);\n    \n      GD.SaveContext();\n      GD.BlendFunc(SRC_ALPHA, ONE);\n      GD.Begin(BITMAPS);\n      GD.BitmapHandle(LIGHT_HANDLE);\n    \n      GD.ColorRGB((i == N_VERTICES - 2) ? 0xfe2b18 : 0x4fff82);\n      GD.Vertex2f(projected[i].x - (VXSCALE * LIGHT_WIDTH / 2),\n                  projected[i].y - (VXSCALE * LIGHT_WIDTH / 2));\n      GD.RestoreContext();\n    }\n    \n    /*****************************************************************/\n    \n    /* simple trackball-like motion control */\n    /* Based on projtex.c - by David Yu and David Blythe, SGI */\n    \n    float angle, axis[3] = {0,1,0};\n    float lastPos[3];\n    \n    void\n    ptov(int x, int y, int width, int height, float v[3])\n    {\n      float d, a;\n    \n      /* project x,y onto a hemi-sphere centered within width, height */\n      v[0] = (2.0 * x - width) / width;\n      v[1] = (2.0 * y - height) / height;\n      d = sqrt(v[0] * v[0] + v[1] * v[1]);\n      v[2] = cos((M_PI / 2.0) * ((d &lt; 1.0) ? d : 1.0));\n      a = 1.0 / sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n      v[0] *= a;\n      v[1] *= a;\n      v[2] *= a;\n    }\n    \n    void\n    startMotion(int x, int y)\n    {\n      angle = 0.0;\n      ptov(x, y, GD.w, GD.h, lastPos);\n    }\n    \n    void\n    trackMotion(int x, int y)\n    {\n      float curPos[3], dx, dy, dz;\n    \n      ptov(x, y, GD.w, GD.h, curPos);\n    \n      dx = curPos[0] - lastPos[0];\n      dy = curPos[1] - lastPos[1];\n      dz = curPos[2] - lastPos[2];\n      angle = (M_PI / 2) * sqrt(dx * dx + dy * dy + dz * dz);\n    \n      axis[0] = lastPos[1] * curPos[2] - lastPos[2] * curPos[1];\n      axis[1] = lastPos[2] * curPos[0] - lastPos[0] * curPos[2];\n      axis[2] = lastPos[0] * curPos[1] - lastPos[1] * curPos[0];\n    \n      float mag = 1 / sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n      axis[0] *= mag;\n      axis[1] *= mag;\n      axis[2] *= mag;\n    \n      lastPos[0] = curPos[0];\n      lastPos[1] = curPos[1];\n      lastPos[2] = curPos[2];\n    }\n    \n    /*****************************************************************/\n    \n    \n    void setup()\n    {\n      GD.begin();\n      LOAD_ASSETS();\n      GD.BitmapHandle(BACKGROUND_HANDLE);\n      GD.BitmapSize(BILINEAR, REPEAT, REPEAT, GD.w, GD.h);\n      startMotion(240, 136);\n      trackMotion(243, 139);\n    }\n    \n    static byte prev_touching;\n    static uint16_t t;\n    \n    static void draw_sun(int x, int y, int rot)\n    {\n      GD.cmd_loadidentity();\n      GD.cmd_translate(F16(SUN_WIDTH / 2), F16(SUN_WIDTH / 2));\n      GD.cmd_rotate(rot);\n      GD.cmd_translate(-F16(SUN_WIDTH / 2), -F16(SUN_WIDTH / 2));\n      GD.cmd_setmatrix();\n      GD.Vertex2f(x - (VXSCALE * SUN_WIDTH / 2), y - (VXSCALE * SUN_WIDTH / 2));\n    }\n    \n    void loop()\n    {\n      if (ft8xx_model == 2) {\n        GD.VertexFormat(3);\n        GD.vxf = 3;\n        VXSCALE = 8;\n      }\n      GD.Begin(BITMAPS);\n      GD.SaveContext();\n      GD.SaveContext();\n      GD.BitmapHandle(BACKGROUND_HANDLE);\n      GD.cmd_translate(-(long)t &lt;&lt; 14, (long)t &lt;&lt; 13);\n      GD.cmd_rotate(3312);\n      GD.cmd_setmatrix();\n      GD.Vertex2ii(0, 0, 0, 0);\n      GD.RestoreContext();\n    \n      int et = t - 0;\n      int sun_x = (GD.w * VXSCALE) - (et &lt;&lt; 2),\n          sun_y = (100 * VXSCALE) + (et &lt;&lt; 1);\n      GD.SaveContext();\n      GD.PointSize(52 * 16);\n      GD.ColorRGB(0x000000);\n      GD.Begin(POINTS);\n      GD.Vertex2f(sun_x, sun_y);\n      GD.RestoreContext();\n    \n      GD.SaveContext();\n      GD.Begin(BITMAPS);\n      GD.BlendFunc(ONE, ONE);\n      GD.BitmapHandle(SUN_HANDLE);\n      GD.ColorRGB(0xb0a090);\n      draw_sun(sun_x, sun_y, t &lt;&lt; 6);\n      draw_sun(sun_x, sun_y, -t &lt;&lt; 6);\n      GD.RestoreContext();\n    \n      GD.get_inputs();\n      byte touching = (GD.inputs.x != -32768);\n      if (!prev_touching &amp;&amp; touching)\n        startMotion(GD.inputs.x, GD.inputs.y);\n      else if (touching)\n        trackMotion(GD.inputs.x, GD.inputs.y);\n      prev_touching = touching;\n    \n      unsigned long t0 = micros();\n    \n      if (angle != 0.0f)\n        rotation(angle, axis);\n    \n      project(0);\n      draw_navlight(1);\n      draw_faces();\n      GD.RestoreContext();\n      draw_edges();\n      draw_navlight(0);\n      GD.RestoreContext();\n    \n      GD.swap();\n    \n      t++;\n    }\n\n&amp;#x200B;",
      "author_fullname": "t2_adfkq",
      "saved": false,
      "mod_reason_title": null,
      "gilded": 0,
      "clicked": false,
      "title": "Since we're all showing 3D rendering on our screens...",
      "link_flair_richtext": [
        {
          "e": "text",
          "t": "Look what I found!"
        }
      ],
      "subreddit_name_prefixed": "r/arduino",
      "hidden": false,
      "pwls": 6,
      "link_flair_css_class": "",
      "downs": 0,
      "thumbnail_height": null,
      "top_awarded_type": null,
      "hide_score": false,
      "media_metadata": {
        "2p2e7bdjwrqb1": {
          "status": "valid",
          "e": "RedditVideo",
          "dashUrl": "https://v.redd.it/link/16tgqas/asset/2p2e7bdjwrqb1/DASHPlaylist.mpd?a=1741715549%2CNDk1NDk1MDk2NjVkY2Q1NDkwNzBkZGJhZTQzMDkwMmNlMmExZTk2YWUwMzdlMGI3ZWNhNDAyOTNmZmMwNTI0YQ%3D%3D&amp;v=1&amp;f=sd",
          "x": 1280,
          "y": 720,
          "hlsUrl": "https://v.redd.it/link/16tgqas/asset/2p2e7bdjwrqb1/HLSPlaylist.m3u8?a=1741715549%2CMGY4NmZhZTE4N2NiMjMzOWRkYTFmNzgyNDhiMTc1NGVkNjRmOGJiZTQ3ZjgxYWE3OTcxNzI5YmZmYjNmMTYzZQ%3D%3D&amp;v=1&amp;f=sd",
          "id": "2p2e7bdjwrqb1",
          "isGif": false
        }
      },
      "name": "t3_16tgqas",
      "quarantine": false,
      "link_flair_text_color": "dark",
      "upvote_ratio": 0.98,
      "author_flair_background_color": "#00a6a5",
      "subreddit_type": "public",
      "ups": 35,
      "total_awards_received": 0,
      "media_embed": {},
      "thumbnail_width": null,
      "author_flair_template_id": "5cb3c302-0ef5-11ed-b9fd-aab9a872a9c2",
      "is_original_content": false,
      "user_reports": [],
      "secure_media": null,
      "is_reddit_media_domain": false,
      "is_meta": false,
      "category": null,
      "secure_media_embed": {},
      "link_flair_text": "Look what I found!",
      "can_mod_post": false,
      "score": 35,
      "approved_by": null,
      "is_created_from_ads_ui": false,
      "author_premium": false,
      "thumbnail": "self",
      "edited": 1695811836.0,
      "author_flair_css_class": null,
      "author_flair_richtext": [
        {
          "a": ":400K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/apsbyvbwmfe91_t5_2qknj/400K"
        },
        {
          "a": ":Arduino_500k:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/o5qzzwwkvk5a1_t5_2qknj/Arduino_500k"
        },
        {
          "a": ":600K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/z23hxjk4hpeb1_t5_2qknj/600K"
        },
        {
          "a": ":640K:",
          "e": "emoji",
          "u": "https://emoji.redditmedia.com/g9r24xjaydqc1_t5_2qknj/640K"
        },
        {
          "e": "text",
          "t": " My other dev board is a Porsche"
        }
      ],
      "gildings": {},
      "content_categories": null,
      "is_self": true,
      "mod_note": null,
      "created": 1695809938.0,
      "link_flair_type": "richtext",
      "wls": 6,
      "removed_by_category": null,
      "banned_by": null,
      "author_flair_type": "richtext",
      "domain": "self.arduino",
      "allow_live_comments": false,
      "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;All 3D calculations, rotations, spinning, drawing instructions, background scolling, sun animations and touch screen I/O are being done on an &lt;strong&gt;Uno R3&lt;/strong&gt; with a Gameduino 2 display. \ud83d\ude43 I was one of the original Kickstarter sponsors for the project! Example code that came with it for this below the video:&lt;/p&gt;\n\n&lt;p&gt;Cheers!&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ripred&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://reddit.com/link/16tgqas/video/2p2e7bdjwrqb1/player\"&gt;Gameduino 2 running on an old school Arduino R3 with USB-A adapter&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;lt;EEPROM.h&amp;gt;\n#include &amp;lt;SPI.h&amp;gt;\n#include &amp;lt;GD2.h&amp;gt;\n\n#include &amp;quot;cobra_assets.h&amp;quot;\n\n////////////////////////////////////////////////////////////////////////////////\n//                                  3D Projection\n////////////////////////////////////////////////////////////////////////////////\n\nstatic byte VXSCALE = 16;\n\nstatic float model_mat[9] = { 1.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0,\n                        0.0, 0.0, 1.0 };\nstatic float normal_mat[9] = { 1.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0,\n                        0.0, 0.0, 1.0 };\n\n#define M(nm,i,j)       ((nm)[3 * (i) + (j)])\n\nvoid mult_matrices(float *a, float *b, float *c)\n{\n  int i, j, k;\n  float result[9];\n  for(i = 0; i &amp;lt; 3; i++) {\n    for(j = 0; j &amp;lt; 3; j++) {\n      M(result,i,j) = 0.0f;\n      for(k = 0; k &amp;lt; 3; k++) {\n        M(result,i,j) +=  M(a,i,k) *  M(b,k,j);\n      }\n    }\n  }\n  memcpy(c, result, sizeof(result));\n}\n\n// Based on glRotate()\n// Returns 3x3 rotation matrix in &amp;#39;m&amp;#39;\n// and its invese in &amp;#39;mi&amp;#39;\n\nstatic void rotate(float *m, float *mi, float angle, float *axis)\n{\n  float x = axis[0];\n  float y = axis[1];\n  float z = axis[2];\n\n  float s = sin(angle);\n  float c = cos(angle);\n\n  float xx = x*x*(1-c);\n  float xy = x*y*(1-c);\n  float xz = x*z*(1-c);\n  float yy = y*y*(1-c);\n  float yz = y*z*(1-c);\n  float zz = z*z*(1-c);\n\n  float xs = x * s;\n  float ys = y * s;\n  float zs = z * s;\n\n  m[0] = xx + c;\n  m[1] = xy - zs;\n  m[2] = xz + ys;\n\n  m[3] = xy + zs;\n  m[4] = yy + c;\n  m[5] = yz - xs;\n\n  m[6] = xz - ys;\n  m[7] = yz + xs;\n  m[8] = zz + c;\n\n  mi[0] = m[0];\n  mi[1] = xy + zs;\n  mi[2] = xz - ys;\n\n  mi[3] = xy - zs;\n  mi[4] = m[4];\n  mi[5] = yz + xs;\n\n  mi[6] = xz + ys;\n  mi[7] = yz - xs;\n  mi[8] = m[8];\n}\n\nstatic void rotation(float angle, float *axis)\n{\n  float mat[9];\n  float mati[9];\n\n  rotate(mat, mati, angle, axis);\n  mult_matrices(model_mat, mat, model_mat);\n  mult_matrices(mati, normal_mat, normal_mat);\n}\n\n\n#define N_VERTICES  (sizeof(COBRA_vertices) / 3)\n\ntypedef struct {\n  int x, y;\n  float z;\n} xyz;\n\nstatic xyz projected[N_VERTICES];\n\nvoid project(float distance)\n{\n  const PROGMEM int8_t *pm = COBRA_vertices;\n  const PROGMEM int8_t *pm_e = pm + sizeof(COBRA_vertices);\n  xyz *dst = projected;\n  int8_t x, y, z;\n  int hw = GD.w / 2;\n\n  while (pm &amp;lt; pm_e) {\n    x = pgm_read_byte_near(pm++);\n    y = pgm_read_byte_near(pm++);\n    z = pgm_read_byte_near(pm++);\n    float xx = x * model_mat[0] + y * model_mat[3] + z * model_mat[6];\n    float yy = x * model_mat[1] + y * model_mat[4] + z * model_mat[7];\n    float zz = x * model_mat[2] + y * model_mat[5] + z * model_mat[8] + distance;\n    float q = hw / (100 + zz);\n    dst-&amp;gt;x = VXSCALE * (hw       + xx * q);\n    dst-&amp;gt;y = VXSCALE * (GD.h / 2 + yy * q);\n    dst-&amp;gt;z = zz;\n    dst++;\n  }\n}\n\nstatic void transform_normal(int8_t &amp;amp;nx, int8_t &amp;amp;ny, int8_t &amp;amp;nz)\n{\n  int8_t xx = nx * normal_mat[0] + ny * normal_mat[1] + nz * normal_mat[2];\n  int8_t yy = nx * normal_mat[3] + ny * normal_mat[4] + nz * normal_mat[5];\n  int8_t zz = nx * normal_mat[6] + ny * normal_mat[7] + nz * normal_mat[8];\n  nx = xx;\n  ny = yy;\n  nz = zz;\n}\n\n#define EDGE_BYTES  5\nstatic byte visible_edges[EDGE_BYTES];\n\nvoid draw_faces()\n{\n  memset(visible_edges, 0, sizeof(visible_edges));\n\n  const PROGMEM int8_t *p = COBRA_faces;\n  byte n;\n  int c = 1;\n  Poly po;\n  while ((n = pgm_read_byte_near(p++)) != 0xff) {\n    int8_t nx = pgm_read_byte_near(p++);\n    int8_t ny = pgm_read_byte_near(p++);\n    int8_t nz = pgm_read_byte_near(p++);\n    byte face_edges[EDGE_BYTES];\n    for (byte i = 0; i &amp;lt; EDGE_BYTES; i++)\n      face_edges[i] = pgm_read_byte_near(p++);\n    byte v1 = pgm_read_byte_near(p);\n    byte v2 = pgm_read_byte_near(p + 1);\n    byte v3 = pgm_read_byte_near(p + 2);\n    long x1 = projected[v1].x;\n    long y1 = projected[v1].y;\n    long x2 = projected[v2].x;\n    long y2 = projected[v2].y;\n    long x3 = projected[v3].x;\n    long y3 = projected[v3].y;\n    long area = (x1 - x3) * (y2 - y1) - (x1 - x2) * (y3 - y1);\n\n    if (area &amp;gt; 0) {\n      for (byte i = 0; i &amp;lt; EDGE_BYTES; i++)\n        visible_edges[i] |= face_edges[i];\n      po.begin();\n      for (int i = 0; i &amp;lt; n; i++) {\n        byte vi = pgm_read_byte_near(p++);\n        xyz *v = &amp;amp;projected[vi];\n        po.v(v-&amp;gt;x, v-&amp;gt;y);\n      }\n      {\n        transform_normal(nx, ny, nz);\n\n        uint16_t r = 10, g = 10, b = 20;  // Ambient\n\n        int d = -ny;                      // diffuse light from +ve Y\n        if (d &amp;gt; 0) {\n          r += d &amp;gt;&amp;gt; 2;\n          g += d &amp;gt;&amp;gt; 1;\n          b += d;\n        }\n                                          // use specular half angle\n        d = ny * -90 + nz * -90;          // Range -16384 to +16384\n        if (d &amp;gt; 8192) {\n          byte l = pgm_read_byte_near(shiny + ((d - 8192) &amp;gt;&amp;gt; 4));\n          r += l;\n          g += l;\n          b += l;\n        }\n\n        GD.ColorRGB(min(255, r), min(255, g), min(255, b));\n      }\n      po.draw();\n    } else {\n      p += n;\n    }\n    c += 1;\n  }\n}\n\nvoid draw_edges()\n{\n  GD.ColorRGB(0x2e666e);\n  GD.Begin(LINES);\n  GD.LineWidth(20);\n\n  const PROGMEM uint8_t *p = COBRA_edges;\n  byte *pvis = visible_edges;\n  byte vis = 0;\n\n  for (byte i = 0; i &amp;lt; sizeof(COBRA_edges) / 2; i++) {\n    if ((i &amp;amp; 7) == 0)\n      vis = *pvis++;\n    byte v0 = pgm_read_byte_near(p++);\n    byte v1 = pgm_read_byte_near(p++);\n\n    if (vis &amp;amp; 1) {\n      int x0 = projected[v0].x;\n      int y0 = projected[v0].y;\n      int x1 = projected[v1].x;\n      int y1 = projected[v1].y;\n\n      GD.Vertex2f(x0,y0);\n      GD.Vertex2f(x1,y1);\n    }\n    vis &amp;gt;&amp;gt;= 1;\n  }\n}\n\nstatic void draw_navlight(byte nf)\n{\n  float l0z = projected[N_VERTICES - 2].z;\n  float l1z = projected[N_VERTICES - 1].z;\n  byte i;\n  if (nf == 0)  // draw the one with smallest z\n    i = (l0z &amp;lt; l1z) ? (N_VERTICES - 2) : (N_VERTICES - 1);\n  else\n    i = (l0z &amp;lt; l1z) ? (N_VERTICES - 1) : (N_VERTICES - 2);\n\n  GD.SaveContext();\n  GD.BlendFunc(SRC_ALPHA, ONE);\n  GD.Begin(BITMAPS);\n  GD.BitmapHandle(LIGHT_HANDLE);\n\n  GD.ColorRGB((i == N_VERTICES - 2) ? 0xfe2b18 : 0x4fff82);\n  GD.Vertex2f(projected[i].x - (VXSCALE * LIGHT_WIDTH / 2),\n              projected[i].y - (VXSCALE * LIGHT_WIDTH / 2));\n  GD.RestoreContext();\n}\n\n/*****************************************************************/\n\n/* simple trackball-like motion control */\n/* Based on projtex.c - by David Yu and David Blythe, SGI */\n\nfloat angle, axis[3] = {0,1,0};\nfloat lastPos[3];\n\nvoid\nptov(int x, int y, int width, int height, float v[3])\n{\n  float d, a;\n\n  /* project x,y onto a hemi-sphere centered within width, height */\n  v[0] = (2.0 * x - width) / width;\n  v[1] = (2.0 * y - height) / height;\n  d = sqrt(v[0] * v[0] + v[1] * v[1]);\n  v[2] = cos((M_PI / 2.0) * ((d &amp;lt; 1.0) ? d : 1.0));\n  a = 1.0 / sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n  v[0] *= a;\n  v[1] *= a;\n  v[2] *= a;\n}\n\nvoid\nstartMotion(int x, int y)\n{\n  angle = 0.0;\n  ptov(x, y, GD.w, GD.h, lastPos);\n}\n\nvoid\ntrackMotion(int x, int y)\n{\n  float curPos[3], dx, dy, dz;\n\n  ptov(x, y, GD.w, GD.h, curPos);\n\n  dx = curPos[0] - lastPos[0];\n  dy = curPos[1] - lastPos[1];\n  dz = curPos[2] - lastPos[2];\n  angle = (M_PI / 2) * sqrt(dx * dx + dy * dy + dz * dz);\n\n  axis[0] = lastPos[1] * curPos[2] - lastPos[2] * curPos[1];\n  axis[1] = lastPos[2] * curPos[0] - lastPos[0] * curPos[2];\n  axis[2] = lastPos[0] * curPos[1] - lastPos[1] * curPos[0];\n\n  float mag = 1 / sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n  axis[0] *= mag;\n  axis[1] *= mag;\n  axis[2] *= mag;\n\n  lastPos[0] = curPos[0];\n  lastPos[1] = curPos[1];\n  lastPos[2] = curPos[2];\n}\n\n/*****************************************************************/\n\n\nvoid setup()\n{\n  GD.begin();\n  LOAD_ASSETS();\n  GD.BitmapHandle(BACKGROUND_HANDLE);\n  GD.BitmapSize(BILINEAR, REPEAT, REPEAT, GD.w, GD.h);\n  startMotion(240, 136);\n  trackMotion(243, 139);\n}\n\nstatic byte prev_touching;\nstatic uint16_t t;\n\nstatic void draw_sun(int x, int y, int rot)\n{\n  GD.cmd_loadidentity();\n  GD.cmd_translate(F16(SUN_WIDTH / 2), F16(SUN_WIDTH / 2));\n  GD.cmd_rotate(rot);\n  GD.cmd_translate(-F16(SUN_WIDTH / 2), -F16(SUN_WIDTH / 2));\n  GD.cmd_setmatrix();\n  GD.Vertex2f(x - (VXSCALE * SUN_WIDTH / 2), y - (VXSCALE * SUN_WIDTH / 2));\n}\n\nvoid loop()\n{\n  if (ft8xx_model == 2) {\n    GD.VertexFormat(3);\n    GD.vxf = 3;\n    VXSCALE = 8;\n  }\n  GD.Begin(BITMAPS);\n  GD.SaveContext();\n  GD.SaveContext();\n  GD.BitmapHandle(BACKGROUND_HANDLE);\n  GD.cmd_translate(-(long)t &amp;lt;&amp;lt; 14, (long)t &amp;lt;&amp;lt; 13);\n  GD.cmd_rotate(3312);\n  GD.cmd_setmatrix();\n  GD.Vertex2ii(0, 0, 0, 0);\n  GD.RestoreContext();\n\n  int et = t - 0;\n  int sun_x = (GD.w * VXSCALE) - (et &amp;lt;&amp;lt; 2),\n      sun_y = (100 * VXSCALE) + (et &amp;lt;&amp;lt; 1);\n  GD.SaveContext();\n  GD.PointSize(52 * 16);\n  GD.ColorRGB(0x000000);\n  GD.Begin(POINTS);\n  GD.Vertex2f(sun_x, sun_y);\n  GD.RestoreContext();\n\n  GD.SaveContext();\n  GD.Begin(BITMAPS);\n  GD.BlendFunc(ONE, ONE);\n  GD.BitmapHandle(SUN_HANDLE);\n  GD.ColorRGB(0xb0a090);\n  draw_sun(sun_x, sun_y, t &amp;lt;&amp;lt; 6);\n  draw_sun(sun_x, sun_y, -t &amp;lt;&amp;lt; 6);\n  GD.RestoreContext();\n\n  GD.get_inputs();\n  byte touching = (GD.inputs.x != -32768);\n  if (!prev_touching &amp;amp;&amp;amp; touching)\n    startMotion(GD.inputs.x, GD.inputs.y);\n  else if (touching)\n    trackMotion(GD.inputs.x, GD.inputs.y);\n  prev_touching = touching;\n\n  unsigned long t0 = micros();\n\n  if (angle != 0.0f)\n    rotation(angle, axis);\n\n  project(0);\n  draw_navlight(1);\n  draw_faces();\n  GD.RestoreContext();\n  draw_edges();\n  draw_navlight(0);\n  GD.RestoreContext();\n\n  GD.swap();\n\n  t++;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
      "likes": null,
      "suggested_sort": "confidence",
      "banned_at_utc": null,
      "view_count": null,
      "archived": false,
      "no_follow": false,
      "is_crosspostable": false,
      "pinned": false,
      "over_18": false,
      "all_awardings": [],
      "awarders": [],
      "media_only": false,
      "link_flair_template_id": "16d652c0-5bc8-11e9-9973-0e7a91bdd5ee",
      "can_gild": false,
      "spoiler": false,
      "locked": false,
      "author_flair_text": ":400K::Arduino_500k::600K::640K: My other dev board is a Porsche",
      "treatment_tags": [],
      "visited": false,
      "removed_by": null,
      "num_reports": null,
      "distinguished": null,
      "subreddit_id": "t5_2qknj",
      "author_is_blocked": false,
      "mod_reason_by": null,
      "removal_reason": null,
      "link_flair_background_color": "#0dd3bb",
      "id": "16tgqas",
      "is_robot_indexable": true,
      "report_reasons": null,
      "author": "ripred3",
      "discussion_type": null,
      "num_comments": 4,
      "send_replies": true,
      "contest_mode": false,
      "mod_reports": [],
      "author_patreon_flair": false,
      "author_flair_text_color": "light",
      "permalink": "/r/arduino/comments/16tgqas/since_were_all_showing_3d_rendering_on_our_screens/",
      "stickied": false,
      "url": "https://www.reddit.com/r/arduino/comments/16tgqas/since_were_all_showing_3d_rendering_on_our_screens/",
      "subreddit_subscribers": 691390,
      "created_utc": 1695809938.0,
      "num_crossposts": 6,
      "media": null,
      "is_video": false
    }
  ],
  "created": 1695811694.0,
  "link_flair_type": "richtext",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.arduino",
  "allow_live_comments": false,
  "selftext_html": null,
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "url_overridden_by_dest": "/r/arduino/comments/16tgqas/since_were_all_showing_3d_rendering_on_our_screens/",
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "f816b8fa-053a-11ed-9223-669af96e8c47",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#ae3549",
  "id": "16th93t",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "crosspost_parent": "t3_16tgqas",
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/16th93t/since_were_all_showing_3d_rendering_on_our_screens/",
  "stickied": false,
  "url": "/r/arduino/comments/16tgqas/since_were_all_showing_3d_rendering_on_our_screens/",
  "subreddit_subscribers": 43,
  "created_utc": 1695811694.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}