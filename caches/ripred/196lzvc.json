{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "Here is the current code as it was designed a couple of years ago:\n\n    /*\\\n    |*| menu.h\n    |*| \n    |*| (c) 2022 Trent M. Wyatt.\n    |*| companion file for Reverse Geocache Box project\n    |*| \n    \\*/\n    \n    #if !defined(MENU_H_INC)\n    #define MENU_H_INC\n    \n    enum entry_t : uint8_t\n    {\n        FUNC = 0, \n        MENU = 1, \n         INT = 2\n    };\n    \n    struct lcd_menu_t;\n    \n    struct variant_t\n    {\n        union {\n            void      (*func)();\n            lcd_menu_t *menu;\n            int         ival;\n        }       value{0};\n        entry_t type{INT};\n    \n        variant_t() : value{0}, type{INT} { }\n    \n        variant_t(void(*func)()) : type{FUNC} {\n            value.func = func;\n        }\n    \n        variant_t(lcd_menu_t *menu) : type{MENU} {\n            value.menu = menu;\n        }\n    \n        variant_t(int val) : type{INT} {\n            value.ival = val;\n        }\n    \n        variant_t const &amp; operator = (void (*func)()) \n        {\n            (*this).value.func = func;\n            type = FUNC;\n            return *this;\n        }\n    \n        variant_t const &amp; operator = (lcd_menu_t *menu) \n        {\n            (*this).value.menu = menu;\n            type = MENU;\n            return *this;\n        }\n    \n        variant_t const &amp; operator = (int ival) \n        {\n            (*this).value.ival = ival;\n            type = INT;\n            return *this;\n        }\n    \n    }; // variant_t\n    \n    struct menu_t\n    {\n        char      txt[17]{0};\n        variant_t value{0};\n        int       minv{0};\n        int       maxv{0};\n    \n        menu_t() : txt(\"\"), value(0), minv(0), maxv(0) { }\n        menu_t(   void(*func)()) : txt(\"\"), value(func), minv(0), maxv(0) { }\n        menu_t(lcd_menu_t *menu) : txt(\"\"), value(menu), minv(0), maxv(0) { }\n        menu_t(           int n) : txt(\"\"), value(   n), minv(0), maxv(0) { }\n    \n        menu_t(char const *t,            int n, int in = 0, int ax = 0) : value(   n), minv(in), maxv(ax) { strncpy(txt, t, sizeof(txt)); }\n        menu_t(char const *t,   void (*func)(), int in = 0, int ax = 0) : value(func), minv(in), maxv(ax) { strncpy(txt, t, sizeof(txt)); }\n        menu_t(char const *t, lcd_menu_t *menu, int in = 0, int ax = 0) : value(menu), minv(in), maxv(ax) { strncpy(txt, t, sizeof(txt)); }\n    };\n    \n    // the interface to update the display with the current menu\n    using disp_fptr_t = void (*)(char const *,char const *);\n    \n    // the interface to get menu input from the user\n    // the user can input one of 6 choices: left, right, up, down, select, and cancel:\n    enum choice_t { Invalid, Left, Right, Up, Down, Select, Cancel };\n    \n    using input_fptr_t = choice_t (*)(char const *prompt);\n    \n    struct lcd_menu_t \n    {\n        menu_t      menu[2];\n        uint8_t     cur     : 1,    // the current menu choice\n                    use_num : 1;    // use numbers in menus when true\n        disp_fptr_t fptr{nullptr};  // the display update function\n    \n    \n        lcd_menu_t() : cur(0), use_num(false) \n        {\n            for (menu_t &amp;entry : menu) {\n                entry.txt[0] = '\\0';\n                entry.value = 0;\n                entry.minv = 0;\n                entry.maxv = 0;\n            }\n    \n        } // lcd_menu_t\n    \n        lcd_menu_t(menu_t m1, menu_t m2) : cur(0), use_num(false) {\n            menu[0] = m1;\n            menu[1] = m2;\n        }\n        \n        \n        lcd_menu_t(char *msg1, void(*func1)(), char *msg2, void(*func2)())\n        {\n            strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n            menu[0].value = func1;\n            strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n            menu[1].value = func2;\n    \n        } // lcd_menu_t\n    \n        lcd_menu_t(char *msg1, lcd_menu_t *menu1, char *msg2, lcd_menu_t *menu2)\n        {\n            strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n            menu[0].value = menu1;\n            strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n            menu[1].value = menu2;\n    \n        } // lcd_menu_t\n    \n        lcd_menu_t(char const *msg1, void(*func1)(), char const *msg2, void(*func2)())\n        {\n            strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n            menu[0].value = func1;\n            strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n            menu[1].value = func2;\n    \n        } // lcd_menu_t\n    \n        lcd_menu_t(char const *msg1, lcd_menu_t *menu1, char const *msg2, lcd_menu_t *menu2)\n        {\n            strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n            menu[0].value = menu1;\n            strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n            menu[1].value = menu2;\n    \n        } // lcd_menu_t\n    \n        int next() \n        {\n            return cur = !cur;\n    \n        } // next\n    \n        lcd_menu_t &amp;exec() {\n            switch (menu[cur].value.type) {\n                case FUNC:\n                    if (menu[cur].value.value.func != nullptr) {\n                        menu[cur].value.value.func();\n                    }\n                    break;\n    \n                case MENU:\n                    if (menu[cur].value.value.menu != nullptr) {\n                        *this = *(menu[cur].value.value.menu);\n                    }\n                    break;\n    \n                case INT:\n                    break;\n            }\n    \n            return *this;\n    \n        } // exec\n    \n        lcd_menu_t &amp;run(input_fptr_t inp, disp_fptr_t update) {\n            lcd_menu_t parents[8]{};\n            int parent = 0;\n            parents[parent] = *this;\n    \n            int orig = menu[cur].value.value.ival;\n            bool editing = false;\n    \n            do {\n                char line1[32] = \"\", line2[32] = \"\", buff[16];\n                strcpy(line1, use_num ? \"1 \" : \"\");\n                strcpy(line2, use_num ? \"2 \" : \"\");\n                strcat(line1, menu[0].txt);\n                strcat(line2, menu[1].txt);\n                if (menu[0].value.type == INT) {\n                    sprintf(buff, \"%d\", menu[0].value.value.ival);\n                    strcat(line1, buff);\n                }\n                if (menu[1].value.type == INT) {\n                    sprintf(buff, \"%d\", menu[1].value.value.ival);\n                    strcat(line2, buff);\n                }\n                strncat(0 == cur ? line1 : line2, \"*\", sizeof(line1));\n                update(line1, line2);\n    \n                if (editing) {\n                    choice_t choice = inp(\"U,D,S,C:\");\n                    switch (choice) {\n                        case Up:\n                            if (menu[cur].value.value.ival &lt; menu[cur].maxv)\n                                menu[cur].value.value.ival++;\n                            break;\n    \n                        case Down:\n                            if (menu[cur].value.value.ival &gt; menu[cur].minv)\n                                menu[cur].value.value.ival--;\n                            break;\n    \n                        case Select:\n                            editing = false;\n                            break;\n    \n                        case Cancel:\n                            menu[cur].value.value.ival = orig;\n                            editing = false;\n                            break;\n    \n                        case    Left:\n                        case   Right:\n                        case Invalid:\n                            break;\n                    }\n    \n                } // editing\n                else {\n                    choice_t choice = inp(\"Choose:\");\n                    switch (choice) {\n                        case Down:\n                        case   Up:\n                            next();\n                            break;\n    \n                        case Select:\n                            switch (menu[cur].value.type) {\n                                case INT:   // it has a value - edit it\n                                    orig = menu[cur].value.value.ival;\n                                    editing = true;\n                                    break;\n                                case MENU:  // it has a menu - switch to it\n                                    parents[parent++] = *this;\n                                    exec();\n                                    break;\n                                case FUNC:  // it has a function - call it\n                                    exec();\n                                    break;\n                            }\n                            break;\n    \n                        case Cancel:\n                            if (parent &gt; 0) {\n                                *(parents[parent-1].menu[parents[parent-1].cur].value.value.menu) = *this;\n                                *this = parents[--parent];\n                            }\n                            break;\n    \n                        case    Left:\n                        case   Right:\n                        case Invalid:\n                            break;\n                    }\n    \n                } // !editing\n    \n            } while (true);\n    \n        } // run\n    \n    };\n    \n    #endif // MENU_H_INC",
  "author_fullname": "t2_adfkq",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "Lightweight Hierarchical Menu System: The Code",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Project Update:"
    }
  ],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_196lzvc",
  "quarantine": false,
  "link_flair_text_color": "light",
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Project Update:",
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1705255617.0,
  "link_flair_type": "richtext",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.ripred",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Here is the current code as it was designed a couple of years ago:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\\\n|*| menu.h\n|*| \n|*| (c) 2022 Trent M. Wyatt.\n|*| companion file for Reverse Geocache Box project\n|*| \n\\*/\n\n#if !defined(MENU_H_INC)\n#define MENU_H_INC\n\nenum entry_t : uint8_t\n{\n    FUNC = 0, \n    MENU = 1, \n     INT = 2\n};\n\nstruct lcd_menu_t;\n\nstruct variant_t\n{\n    union {\n        void      (*func)();\n        lcd_menu_t *menu;\n        int         ival;\n    }       value{0};\n    entry_t type{INT};\n\n    variant_t() : value{0}, type{INT} { }\n\n    variant_t(void(*func)()) : type{FUNC} {\n        value.func = func;\n    }\n\n    variant_t(lcd_menu_t *menu) : type{MENU} {\n        value.menu = menu;\n    }\n\n    variant_t(int val) : type{INT} {\n        value.ival = val;\n    }\n\n    variant_t const &amp;amp; operator = (void (*func)()) \n    {\n        (*this).value.func = func;\n        type = FUNC;\n        return *this;\n    }\n\n    variant_t const &amp;amp; operator = (lcd_menu_t *menu) \n    {\n        (*this).value.menu = menu;\n        type = MENU;\n        return *this;\n    }\n\n    variant_t const &amp;amp; operator = (int ival) \n    {\n        (*this).value.ival = ival;\n        type = INT;\n        return *this;\n    }\n\n}; // variant_t\n\nstruct menu_t\n{\n    char      txt[17]{0};\n    variant_t value{0};\n    int       minv{0};\n    int       maxv{0};\n\n    menu_t() : txt(&amp;quot;&amp;quot;), value(0), minv(0), maxv(0) { }\n    menu_t(   void(*func)()) : txt(&amp;quot;&amp;quot;), value(func), minv(0), maxv(0) { }\n    menu_t(lcd_menu_t *menu) : txt(&amp;quot;&amp;quot;), value(menu), minv(0), maxv(0) { }\n    menu_t(           int n) : txt(&amp;quot;&amp;quot;), value(   n), minv(0), maxv(0) { }\n\n    menu_t(char const *t,            int n, int in = 0, int ax = 0) : value(   n), minv(in), maxv(ax) { strncpy(txt, t, sizeof(txt)); }\n    menu_t(char const *t,   void (*func)(), int in = 0, int ax = 0) : value(func), minv(in), maxv(ax) { strncpy(txt, t, sizeof(txt)); }\n    menu_t(char const *t, lcd_menu_t *menu, int in = 0, int ax = 0) : value(menu), minv(in), maxv(ax) { strncpy(txt, t, sizeof(txt)); }\n};\n\n// the interface to update the display with the current menu\nusing disp_fptr_t = void (*)(char const *,char const *);\n\n// the interface to get menu input from the user\n// the user can input one of 6 choices: left, right, up, down, select, and cancel:\nenum choice_t { Invalid, Left, Right, Up, Down, Select, Cancel };\n\nusing input_fptr_t = choice_t (*)(char const *prompt);\n\nstruct lcd_menu_t \n{\n    menu_t      menu[2];\n    uint8_t     cur     : 1,    // the current menu choice\n                use_num : 1;    // use numbers in menus when true\n    disp_fptr_t fptr{nullptr};  // the display update function\n\n\n    lcd_menu_t() : cur(0), use_num(false) \n    {\n        for (menu_t &amp;amp;entry : menu) {\n            entry.txt[0] = &amp;#39;\\0&amp;#39;;\n            entry.value = 0;\n            entry.minv = 0;\n            entry.maxv = 0;\n        }\n\n    } // lcd_menu_t\n\n    lcd_menu_t(menu_t m1, menu_t m2) : cur(0), use_num(false) {\n        menu[0] = m1;\n        menu[1] = m2;\n    }\n\n\n    lcd_menu_t(char *msg1, void(*func1)(), char *msg2, void(*func2)())\n    {\n        strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n        menu[0].value = func1;\n        strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n        menu[1].value = func2;\n\n    } // lcd_menu_t\n\n    lcd_menu_t(char *msg1, lcd_menu_t *menu1, char *msg2, lcd_menu_t *menu2)\n    {\n        strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n        menu[0].value = menu1;\n        strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n        menu[1].value = menu2;\n\n    } // lcd_menu_t\n\n    lcd_menu_t(char const *msg1, void(*func1)(), char const *msg2, void(*func2)())\n    {\n        strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n        menu[0].value = func1;\n        strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n        menu[1].value = func2;\n\n    } // lcd_menu_t\n\n    lcd_menu_t(char const *msg1, lcd_menu_t *menu1, char const *msg2, lcd_menu_t *menu2)\n    {\n        strncpy(menu[0].txt, msg1, sizeof(menu[0].txt));\n        menu[0].value = menu1;\n        strncpy(menu[1].txt, msg2, sizeof(menu[1].txt));\n        menu[1].value = menu2;\n\n    } // lcd_menu_t\n\n    int next() \n    {\n        return cur = !cur;\n\n    } // next\n\n    lcd_menu_t &amp;amp;exec() {\n        switch (menu[cur].value.type) {\n            case FUNC:\n                if (menu[cur].value.value.func != nullptr) {\n                    menu[cur].value.value.func();\n                }\n                break;\n\n            case MENU:\n                if (menu[cur].value.value.menu != nullptr) {\n                    *this = *(menu[cur].value.value.menu);\n                }\n                break;\n\n            case INT:\n                break;\n        }\n\n        return *this;\n\n    } // exec\n\n    lcd_menu_t &amp;amp;run(input_fptr_t inp, disp_fptr_t update) {\n        lcd_menu_t parents[8]{};\n        int parent = 0;\n        parents[parent] = *this;\n\n        int orig = menu[cur].value.value.ival;\n        bool editing = false;\n\n        do {\n            char line1[32] = &amp;quot;&amp;quot;, line2[32] = &amp;quot;&amp;quot;, buff[16];\n            strcpy(line1, use_num ? &amp;quot;1 &amp;quot; : &amp;quot;&amp;quot;);\n            strcpy(line2, use_num ? &amp;quot;2 &amp;quot; : &amp;quot;&amp;quot;);\n            strcat(line1, menu[0].txt);\n            strcat(line2, menu[1].txt);\n            if (menu[0].value.type == INT) {\n                sprintf(buff, &amp;quot;%d&amp;quot;, menu[0].value.value.ival);\n                strcat(line1, buff);\n            }\n            if (menu[1].value.type == INT) {\n                sprintf(buff, &amp;quot;%d&amp;quot;, menu[1].value.value.ival);\n                strcat(line2, buff);\n            }\n            strncat(0 == cur ? line1 : line2, &amp;quot;*&amp;quot;, sizeof(line1));\n            update(line1, line2);\n\n            if (editing) {\n                choice_t choice = inp(&amp;quot;U,D,S,C:&amp;quot;);\n                switch (choice) {\n                    case Up:\n                        if (menu[cur].value.value.ival &amp;lt; menu[cur].maxv)\n                            menu[cur].value.value.ival++;\n                        break;\n\n                    case Down:\n                        if (menu[cur].value.value.ival &amp;gt; menu[cur].minv)\n                            menu[cur].value.value.ival--;\n                        break;\n\n                    case Select:\n                        editing = false;\n                        break;\n\n                    case Cancel:\n                        menu[cur].value.value.ival = orig;\n                        editing = false;\n                        break;\n\n                    case    Left:\n                    case   Right:\n                    case Invalid:\n                        break;\n                }\n\n            } // editing\n            else {\n                choice_t choice = inp(&amp;quot;Choose:&amp;quot;);\n                switch (choice) {\n                    case Down:\n                    case   Up:\n                        next();\n                        break;\n\n                    case Select:\n                        switch (menu[cur].value.type) {\n                            case INT:   // it has a value - edit it\n                                orig = menu[cur].value.value.ival;\n                                editing = true;\n                                break;\n                            case MENU:  // it has a menu - switch to it\n                                parents[parent++] = *this;\n                                exec();\n                                break;\n                            case FUNC:  // it has a function - call it\n                                exec();\n                                break;\n                        }\n                        break;\n\n                    case Cancel:\n                        if (parent &amp;gt; 0) {\n                            *(parents[parent-1].menu[parents[parent-1].cur].value.value.menu) = *this;\n                            *this = parents[--parent];\n                        }\n                        break;\n\n                    case    Left:\n                    case   Right:\n                    case Invalid:\n                        break;\n                }\n\n            } // !editing\n\n        } while (true);\n\n    } // run\n\n};\n\n#endif // MENU_H_INC\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "5bfb5318-a03e-11ee-adc5-42b05cf4a7d6",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#8242ff",
  "id": "196lzvc",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/196lzvc/lightweight_hierarchical_menu_system_the_code/",
  "stickied": false,
  "url": "https://www.reddit.com/r/ripred/comments/196lzvc/lightweight_hierarchical_menu_system_the_code/",
  "subreddit_subscribers": 43,
  "created_utc": 1705255617.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}