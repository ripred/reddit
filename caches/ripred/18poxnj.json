{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "project repository: [https://github.com/ripred/ArduinoCLI](https://github.com/ripred/ArduinoCLI)\n\nI have refactored the Python code that runs on the host machine to be more modular and use functions for everything instead of running as one big script. The Python code has also been refactored to require the use of a single byte command prefix:\n\n* use the '!' exclamation point (bang) character for lines of text to be executed such as '`!echo \"hello, arduino\"`'\n* use the '@' character to invoke the macro management keywords and macro invocation. The macros have the following reserved keywords:\n\n1. `@list_macros`\n2. `@add_macro:key:command`\n3. `@delete_macro:key`\n\n* use the '&amp;' character to invoke the compiling and uploading of new code to replace the current contents on the Arduino such as `&amp;blink1`. This is still a work in progress.\n\n&amp;#x200B;\n\n* The Arduino side has been rewritten to use a class definition and object to issue commands macros, and compile/uploads through. This hasn't been uploaded to the project repository yet.\n* I need to update all of the other code examples to make use of the new class object or to at least use the proper prefix byte!\n\nThe current Python Agent in `arduino_exec.py`:\n\n    \"\"\"\n    arduino_exec.py\n    \n    @brief Python Agent for the ArduinoCLI platform. This script allows\n    communication with Arduino boards, enabling the execution of built-in\n    commands, macros, and compilation/upload of Arduino code.\n    \n    see the project repository for full details, installation, and use:\n    https://github.com/ripred/ArduinoCLI\n    \n    \n    @author Trent M. Wyatt\n    @date 2023-12-10\n    @version 1.2\n    \n    Release Notes:\n    1.2 - added support for compiling, uploading and replacing the\n          functionality in the current Arduino program flash memory.\n    \n    1.1 - added support for macro functionality.\n    \n    1.0 - implemented the basic 'execute and capture output' functionality.\n    \n    IMPORTANT NOTE:\n    The '&amp;' (compile and upload) operations require the Arduino CLI tool to\n    be installed on your system. Arduino CLI is a command-line interface that\n    simplifies interactions with Arduino boards. If you don't have Arduino CLI\n    installed, you can download it from the official Arduino website:\n    https://arduino.cc/en/software\n    \n    Follow the installation instructions for your operating system provided\n    on the Arduino website. Once installed, make sure the 'arduino-cli'\n    executable is in your system's PATH. The '&amp;' operations use\n    'arduino-cli compile' and 'arduino-cli upload' commands to compile and\n    upload Arduino code. Ensure the Arduino CLI commands are accessible\n    before using the compile and upload functionality.\n    \"\"\"\n    \n    import subprocess\n    import logging\n    import signal\n    import serial\n    # import time\n    import json\n    import sys\n    import os\n    \n    # A list of abbreviated commands that the Arduino\n    # can send to run a pre-registered command:\n    macros = {}\n    \n    # The logger\n    logger = None\n    \n    # The name of the port\n    port_name = \"\"\n    \n    # The serial port\n    cmd_serial = None\n    \n    \n    def setup_logger():\n        \"\"\"\n        @brief Set up the logger for error logging.\n    \n        Configures a logger to log errors to both the console and a file.\n    \n        @return None\n        \"\"\"\n        global logger\n    \n        # Set up logging configuration\n        logging.basicConfig(level=logging.ERROR)  # Set the logging level to ERROR\n    \n        file_handler = logging.FileHandler(\n                os.path.join(os.path.abspath(os.path.dirname(__file__)),\n                             'arduino_exec.log'))\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n        file_handler.setFormatter(formatter)\n    \n        logger = logging.getLogger(__name__)\n        logger.setLevel(logging.ERROR)  # Set the logging level to ERROR\n        logger.addHandler(file_handler)\n    \n    \n    def get_args():\n        \"\"\"\n        @brief Get the serial port from the command line.\n    \n        Checks if a serial port argument is provided in the command line.\n        Also, handles --help or -h options to display usage information.\n    \n        @return str: The serial port obtained from the command line.\n        \"\"\"\n        global port_name\n    \n        if \"--help\" in sys.argv or \"-h\" in sys.argv:\n            print(\"Usage: python arduino_exec.py &lt;COM_port&gt;\")\n            print(\"\\nOptions:\")\n            print(\"  --help, -h   : Show this help message and exit.\")\n            print(\"  ! &lt;command&gt;  : Execute a command on the \"\n                  + \"host machine and get back any output.\")\n            print(\"  @ &lt;macro&gt;    : Execute a pre-registered command \"\n                  + \"on the host machine using a macro name.\")\n            print(\"  &amp; &lt;folder&gt;   : Compile and upload the Arduino \"\n                  + \"code in the specified folder.\")\n            print(\"\\nMacro Management Commands:\")\n            print(\"  @list_macros  : List all registered macros.\")\n            print(\"  @add_macro    : Add a new macro (Usage: \"\n                  + \"@add_macro:&lt;name&gt;:&lt;command&gt;).\")\n            print(\"  @delete_macro : Delete a macro (Usage: \"\n                  + \"@delete_macro:&lt;name&gt;).\")\n            exit(0)\n    \n        if len(sys.argv) &lt;= 1:\n            print(\"Usage: python arduino_exec.py &lt;COM_port&gt;\")\n            exit(-1)\n    \n        port_name = sys.argv[1]\n        return port_name\n    \n    \n    def sigint_handler(signum, frame):\n        \"\"\"\n        @brief Signal handler for SIGINT (Ctrl+C).\n    \n        Handles the SIGINT signal (Ctrl+C) to save macros and exit gracefully.\n    \n        @param signum: Signal number\n        @param frame: Current stack frame\n    \n        @return None\n        \"\"\"\n        print(\" User hit ctrl-c, exiting.\")\n        save_macros(macros)\n        sys.exit(0)\n    \n    \n    def set_signal_handler():\n        \"\"\"\n        @brief Set the signal handler for SIGINT.\n    \n        Sets the signal handler for SIGINT (Ctrl+C) to sigint_handler.\n    \n        @return None\n        \"\"\"\n        signal.signal(signal.SIGINT, sigint_handler)\n    \n    \n    def open_serial_port(port):\n        \"\"\"\n        @brief Open the specified serial port.\n    \n        Attempts to open the specified serial port with a timeout of 1 second.\n    \n        @param port: The serial port to open.\n    \n        @return serial.Serial: The opened serial port.\n    \n        @exit If the serial port cannot be opened,\n              the program exits with an error message.\n        \"\"\"\n        global cmd_serial\n    \n        cmd_serial = serial.Serial(port, 9600, timeout=0.03)\n    \n        if not cmd_serial:\n            print(f\"Could not open the serial port: '{port}'\")\n            exit(-1)\n    \n        print(f\"Successfully opened serial port: '{port}'\")\n        return cmd_serial\n    \n    \n    def execute_command(command):\n        \"\"\"\n        @brief Execute a command and capture the output.\n    \n        Executes a command using subprocess and captures the output.\n        If an error occurs, logs the error and returns an error message.\n    \n        @param command: The command to execute.\n    \n        @return str: The output of the command or an error message.\n        \"\"\"\n        print(f\"Executing: {command}\")  # Output for the user\n    \n        try:\n            result = subprocess.check_output(command, shell=True,\n                                             stderr=subprocess.STDOUT)\n            return result.decode('utf-8')\n        except subprocess.CalledProcessError as e:\n            errtxt = f\"Error executing command: {e}\"\n            logger.error(errtxt)\n            return errtxt\n        except Exception as e:\n            errtxt = f\"An unexpected error occurred: {e}\"\n            logger.error(errtxt)\n            return errtxt\n    \n    \n    def load_macros(filename='macros.txt'):\n        \"\"\"\n        @brief Load macros from a file.\n    \n        Attempts to load macros from a specified file.\n        If the file is not found, returns an empty dictionary.\n    \n        @param filename: The name of the file containing\n                         macros (default: 'macros.txt').\n    \n        @return dict: The loaded macros.\n        \"\"\"\n        try:\n            with open(filename, 'r') as file:\n                return json.load(file)\n        except FileNotFoundError:\n            return {}\n    \n    \n    def save_macros(macros, filename='macros.txt'):\n        \"\"\"\n        @brief Save macros to a file.\n    \n        Saves the provided macros to a specified file.\n    \n        @param macros: The macros to save.\n        @param filename: The name of the file to save macros\n                         to (default: 'macros.txt').\n    \n        @return None\n        \"\"\"\n        with open(filename, 'w') as file:\n            json.dump(macros, file, indent=4, sort_keys=True)\n    \n    \n    def create_macro(name, command, macros):\n        \"\"\"\n        @brief Create a new macro.\n    \n        Creates a new macro with the given name and command, and saves it.\n    \n        @param name: The name of the new macro.\n        @param command: The command associated with the new macro.\n        @param macros: The dictionary of existing macros.\n    \n        @return None\n        \"\"\"\n        macros[name] = command\n        save_macros(macros)\n    \n    \n    def read_macro(name, macros):\n        \"\"\"\n        @brief Read the command associated with a macro.\n    \n        Retrieves the command associated with a given macro name.\n    \n        @param name: The name of the macro.\n        @param macros: The dictionary of existing macros.\n    \n        @return str: The command associated with the macro or an error message.\n        \"\"\"\n        return macros.get(name, \"Macro not found\")\n    \n    \n    def execute_macro(name, macros):\n        \"\"\"\n        @brief Execute a macro.\n    \n        Executes the command associated with a given macro name.\n    \n        @param name: The name of the macro.\n        @param macros: The dictionary of existing macros.\n    \n        @return str: The output of the macro command or an error message.\n        \"\"\"\n        if name in macros:\n            return execute_command(macros[name])\n        else:\n            return f\"Macro '{name}' not found\"\n    \n    \n    def delete_macro(name, macros):\n        \"\"\"\n        @brief Delete a macro.\n    \n        Deletes the specified macro and saves the updated macro list.\n    \n        @param name: The name of the macro to delete.\n        @param macros: The dictionary of existing macros.\n    \n        @return str: Confirmation message or an error message if the\n                     macro is not found.\n        \"\"\"\n        if name in macros:\n            del macros[name]\n            save_macros(macros)\n            return f\"Macro '{name}' deleted\"\n        else:\n            return f\"Macro '{name}' not found\"\n    \n    \n    def compile_and_upload(folder):\n        \"\"\"\n        @brief Compile and upload Arduino code.\n    \n        Compiles and uploads Arduino code from the specified folder.\n    \n        @param folder: The folder containing the Arduino project.\n    \n        @return str: Result of compilation and upload process.\n        \"\"\"\n        global cmd_serial\n    \n        # Check if the specified folder exists\n        if not os.path.exists(folder):\n            return f\"Error: Folder '{folder}' does not exist.\"\n    \n        # Check if the folder contains a matching .ino file\n        ino_file = os.path.join(folder, f\"{os.path.basename(folder)}.ino\")\n        if not os.path.isfile(ino_file):\n            return f\"Error: Folder '{folder}' does not contain a matching .ino file.\"\n    \n        # Define constant part of the compile and upload commands\n        PORT_NAME = '/dev/cu.usbserial-41430'\n        COMPILE_COMMAND_BASE = 'arduino-cli compile --fqbn arduino:avr:nano'\n        UPLOAD_COMMAND_BASE = 'arduino-cli upload -p ' + PORT_NAME + ' --fqbn arduino:avr:nano:cpu=atmega328old'\n    \n        compile_command = f'{COMPILE_COMMAND_BASE} {folder}'\n        upload_command = f'{UPLOAD_COMMAND_BASE} {folder}'\n    \n        compile_result = execute_command(compile_command)\n        print(f\"executed: {compile_command}\\nresult: {compile_result}\")\n    \n        upload_result = execute_command(upload_command)\n        print(f\"executed: {upload_command}\\nresult: {upload_result}\")\n    \n        result = f\"Compile Result:\\n{compile_result}\\nUpload Result:\\n{upload_result}\"\n    \n        return result\n    \n    \n    def run():\n        \"\"\"\n        @brief Main execution function.\n    \n        Handles communication with Arduino, waits for commands, and executes them.\n    \n        @return None\n        \"\"\"\n        global macros\n        global cmd_serial\n    \n        port = get_args()\n        open_serial_port(port)\n        set_signal_handler()\n        macros = load_macros()\n        setup_logger()\n    \n        prompted = False\n        while True:\n            if not prompted:\n                print(\"Waiting for a command from the Arduino...\")\n                prompted = True\n    \n            arduino_command = cmd_serial.readline().decode('utf-8').strip()\n            arduino_command = arduino_command.strip()\n    \n            if not arduino_command:\n                continue\n    \n            logtext = f\"Received command from Arduino: '{arduino_command}'\"\n    #       print(logtext)\n            logger.info(logtext)\n    \n            cmd_id = arduino_command[0]     # Extract the first character\n            command = arduino_command[1:]   # Extract the remainder of the command\n            result = \"\"\n    \n            # Check if the command is an execute command:\n            if cmd_id == '!':\n                # Dispatch the command to handle built-in commands\n                result = execute_command(command)\n            # Check if the command is a macro related command:\n            elif cmd_id == '@':\n                if command in macros:\n                    result = execute_command(macros[command])\n                elif command == \"list_macros\":\n                    macro_list = [f'    \"{macro}\": \"{macros[macro]}\"'\n                                  for macro in macros]\n                    result = \"Registered Macros:\\n\" + \"\\n\".join(macro_list)\n                elif command.startswith(\"add_macro:\"):\n                    _, name, command = command.split(\":\")\n                    create_macro(name, command, macros)\n                    result = f\"Macro '{name}' created with command '{command}'\"\n                elif command.startswith(\"delete_macro:\"):\n                    _, name = command.split(\":\")\n                    result = delete_macro(name, macros)\n                else:\n                    result = f\"unrecognized macro command: @{command}\"\n            # Check if the command is a build and upload command:\n            elif cmd_id == '&amp;':\n                # Dispatch the compile and avrdude upload\n                result = compile_and_upload(command)\n            else:\n                result = f\"unrecognized cmd_id: {cmd_id}\"\n    \n            for line in result.split('\\n'):\n                print(line + '\\n')\n                cmd_serial.write(line.encode('utf-8') + b'\\n')\n    \n            prompted = False\n    \n    \n    if __name__ == '__main__':\n        run()\n\nThe Arduino `bang.h` header file:\n\n    /*\n     * bang.h\n     * \n     * class declaration file for the ArduinoCLI project\n     * https://github.com/ripred/ArduinoCLI\n     * \n     */\n    #ifndef  BANG_H_INCL\n    #define  BANG_H_INCL\n    \n    #include &lt;Arduino.h&gt;\n    #include &lt;Stream.h&gt;\n    #include &lt;SoftwareSerial.h&gt;\n    \n    class Bang {\n    private:\n        Stream *dbgstrm {nullptr};\n        Stream *cmdstrm {nullptr};\n    \n    public:\n        Bang();\n    \n        Bang(Stream &amp;cmd_strm);\n        Bang(Stream &amp;cmd_strm, Stream &amp;dbg_strm);\n    \n        String send_and_recv(char const cmd_id, char const *pcmd);\n    \n        String exec(char const *pcmd);\n        String macro(char const *pcmd);\n        String compile_and_upload(char const *pcmd);\n    \n        long write_file(char const *filename, char const * const lines[], int const num);\n    \n        void push_me_pull_you(Stream &amp;str1, Stream &amp;str2);\n    \n        void sync();\n    \n    }; // class Bang\n    \n    #endif // BANG_H_INCL\n\nThe Arduino `bang.cpp` implementation file:\n\n    /*\n     * bang.cpp\n     * \n     * class implementation file for the ArduinoCLI project\n     * https://github.com/ripred/ArduinoCLI\n     * \n     */\n    #include \"Bang.h\"\n    \n    Bang::Bang() {\n        dbgstrm = nullptr;\n        cmdstrm = nullptr;\n    }\n    \n    Bang::Bang(Stream &amp;cmd_strm) :\n        dbgstrm{nullptr},\n        cmdstrm{&amp;cmd_strm}\n    {\n    }\n    \n    Bang::Bang(Stream &amp;cmd_strm, Stream &amp;dbg_strm) {\n        dbgstrm = &amp;dbg_strm;\n        cmdstrm = &amp;cmd_strm;\n    }\n    \n    String Bang::send_and_recv(char const cmd_id, char const *pcmd) {\n        if (!cmdstrm) { return \"\"; }\n    \n        String output = \"\";\n        String cmd(String(cmd_id) + pcmd);\n        Stream &amp;stream = *cmdstrm;\n        stream.println(cmd);\n        delay(10);\n        while (stream.available()) {\n            output += stream.readString();\n        }\n    \n        return output;\n    }\n    \n    String Bang::exec(char const *pcmd) {\n        return send_and_recv('!', pcmd);\n    }\n    \n    String Bang::macro(char const *pcmd) {\n        return send_and_recv('@', pcmd);\n    }\n    \n    String Bang::compile_and_upload(char const *pcmd) {\n        return send_and_recv('&amp;', pcmd);\n    }\n    \n    long Bang::write_file(char const *filename, char const * const lines[], int const num) {\n        if (num &lt;= 0) { return 0; }\n        long len = 0;\n    \n        String cmd = String(\"echo \\\"\") + lines[0] + \"\\\" &gt; \" + filename;\n        len += cmd.length();\n        exec(cmd.c_str());\n    \n        for (int i=1; i &lt; num; i++) {\n            cmd = String(\"echo \\\"\") + lines[i] + \"\\\" &gt;&gt; \" + filename;\n            len += cmd.length();\n            exec(cmd.c_str());\n        }\n    \n        return len;\n    }\n    \n    void Bang::push_me_pull_you(Stream &amp;str1, Stream &amp;str2) {\n        if (str1.available() &gt;= 2) {\n            uint32_t const period = 20;\n            uint32_t start = millis();\n            while (millis() - start &lt; period) {\n                while (str1.available()) {\n                    str2.println(str1.readString());\n                }\n            }\n        }\n    }\n    \n    void Bang::sync() {\n        if (!cmdstrm || !dbgstrm) { return; }\n        push_me_pull_you(*cmdstrm, *dbgstrm);\n        push_me_pull_you(*dbgstrm, *cmdstrm);\n    }\n\nThe Arduino `bang.ino` example sketch file:\n\n    /*\n     * bang.ino\n     * \n     * testing the macro feature that was just added to the Python Agent\n     * \n     */\n    \n    #include &lt;Arduino.h&gt;\n    #include &lt;SoftwareSerial.h&gt;\n    #include &lt;Stream.h&gt;\n    #include \"Bang.h\"\n    \n    #define  RX_PIN     7\n    #define  TX_PIN     8\n    \n    // Software Serial object to send the\n    // commands to the Python Agent\n    SoftwareSerial command_serial(RX_PIN, TX_PIN);  // RX, TX\n    \n    // class wrapper for the ArduinoCLI api so far:\n    Bang bang(command_serial, Serial);\n    \n    // flag indicating whether we have run the main compile and upload commmand\n    bool executed = false;\n    \n    #define  ARRSIZE(A)   int(sizeof(A) / sizeof(*(A)))\n    \n    void write_test_file(char const *filename) {\n        String const name = filename;\n        String const folder = name;\n        String const sketch = name + \"/\" + name + \".ino\";\n    \n        String const cmd = String(\"mkdir \") + folder;\n        bang.exec(cmd.c_str());\n    \n        char const * const blink1[] = {\n            \"#include &lt;Arduino.h&gt;\",\n            \"\",\n            \"void setup() {\",\n            \"    Serial.begin(115200);\",\n            \"\",\n            \"    pinMode(LED_BUILTIN, OUTPUT);\",\n            \"}\",\n            \"\",\n            \"void loop() {\",\n            \"    digitalWrite(LED_BUILTIN, HIGH);\",\n            \"    delay(1000);\",\n            \"    digitalWrite(LED_BUILTIN, LOW);\",\n            \"    delay(1000);\",\n            \"}\"\n        };\n    \n        bang.write_file(sketch.c_str(), blink1, ARRSIZE(blink1));\n    }\n    \n    void compile_and_upload() {\n        long const cmd_empty_size = command_serial.availableForWrite();\n        long const dbg_empty_size = Serial.availableForWrite();\n    \n        if (!executed) {\n            executed = true;\n    \n            char const *filename = \"blink1\";\n            write_test_file(filename);\n            bang.compile_and_upload(filename);\n    \n            while ((command_serial.availableForWrite() != cmd_empty_size)\n                   || (Serial.availableForWrite() != dbg_empty_size)) {\n            }\n            Serial.end();\n            command_serial.end();\n            exit(0);\n        }\n    }\n    \n    void execute(char const *pcmd) {\n        bang.exec(pcmd);\n    }\n    \n    void macros(char const *pcmd) {\n        bang.macro(pcmd);\n    }\n    \n    void setup() {\n        Serial.begin(115200);\n        command_serial.begin(9600);\n        command_serial.setTimeout(100);\n    \n        // test compilation and upload\n        // compile_and_upload();\n    \n        // test execution\n        execute(\"echo 'hello, arduino'\");\n        for (uint32_t const start = millis(); millis() - start &lt; 700;) {\n            bang.sync();\n        }\n    \n        execute(\"printf \\\"this is a test of the command line printf %d, %d, %d\\\" 1 2 3\");\n        for (uint32_t const start = millis(); millis() - start &lt; 700;) {\n            bang.sync();\n        }\n    \n        // test macros\n        macros(\"list_macros\");\n        for (uint32_t const start = millis(); millis() - start &lt; 700;) {\n            bang.sync();\n        }\n    }\n    \n    void loop() {\n        bang.sync();\n    }\n\n&amp;#x200B;",
  "author_fullname": "t2_adfkq",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "ArduinoCLI Update Notes #4",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Project Update:"
    }
  ],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_18poxnj",
  "quarantine": false,
  "link_flair_text_color": "light",
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Project Update:",
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": 1703400267.0,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "post_hint": "self",
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1703397578.0,
  "link_flair_type": "richtext",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.ripred",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;project repository: &lt;a href=\"https://github.com/ripred/ArduinoCLI\"&gt;https://github.com/ripred/ArduinoCLI&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;I have refactored the Python code that runs on the host machine to be more modular and use functions for everything instead of running as one big script. The Python code has also been refactored to require the use of a single byte command prefix:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;use the &amp;#39;!&amp;#39; exclamation point (bang) character for lines of text to be executed such as &amp;#39;&lt;code&gt;!echo &amp;quot;hello, arduino&amp;quot;&lt;/code&gt;&amp;#39;&lt;/li&gt;\n&lt;li&gt;use the &amp;#39;@&amp;#39; character to invoke the macro management keywords and macro invocation. The macros have the following reserved keywords:&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;@list_macros&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;@add_macro:key:command&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;@delete_macro:key&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;ul&gt;\n&lt;li&gt;use the &amp;#39;&amp;amp;&amp;#39; character to invoke the compiling and uploading of new code to replace the current contents on the Arduino such as &lt;code&gt;&amp;amp;blink1&lt;/code&gt;. This is still a work in progress.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;The Arduino side has been rewritten to use a class definition and object to issue commands macros, and compile/uploads through. This hasn&amp;#39;t been uploaded to the project repository yet.&lt;/li&gt;\n&lt;li&gt;I need to update all of the other code examples to make use of the new class object or to at least use the proper prefix byte!&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The current Python Agent in &lt;code&gt;arduino_exec.py&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;\narduino_exec.py\n\n@brief Python Agent for the ArduinoCLI platform. This script allows\ncommunication with Arduino boards, enabling the execution of built-in\ncommands, macros, and compilation/upload of Arduino code.\n\nsee the project repository for full details, installation, and use:\nhttps://github.com/ripred/ArduinoCLI\n\n\n@author Trent M. Wyatt\n@date 2023-12-10\n@version 1.2\n\nRelease Notes:\n1.2 - added support for compiling, uploading and replacing the\n      functionality in the current Arduino program flash memory.\n\n1.1 - added support for macro functionality.\n\n1.0 - implemented the basic &amp;#39;execute and capture output&amp;#39; functionality.\n\nIMPORTANT NOTE:\nThe &amp;#39;&amp;amp;&amp;#39; (compile and upload) operations require the Arduino CLI tool to\nbe installed on your system. Arduino CLI is a command-line interface that\nsimplifies interactions with Arduino boards. If you don&amp;#39;t have Arduino CLI\ninstalled, you can download it from the official Arduino website:\nhttps://arduino.cc/en/software\n\nFollow the installation instructions for your operating system provided\non the Arduino website. Once installed, make sure the &amp;#39;arduino-cli&amp;#39;\nexecutable is in your system&amp;#39;s PATH. The &amp;#39;&amp;amp;&amp;#39; operations use\n&amp;#39;arduino-cli compile&amp;#39; and &amp;#39;arduino-cli upload&amp;#39; commands to compile and\nupload Arduino code. Ensure the Arduino CLI commands are accessible\nbefore using the compile and upload functionality.\n&amp;quot;&amp;quot;&amp;quot;\n\nimport subprocess\nimport logging\nimport signal\nimport serial\n# import time\nimport json\nimport sys\nimport os\n\n# A list of abbreviated commands that the Arduino\n# can send to run a pre-registered command:\nmacros = {}\n\n# The logger\nlogger = None\n\n# The name of the port\nport_name = &amp;quot;&amp;quot;\n\n# The serial port\ncmd_serial = None\n\n\ndef setup_logger():\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Set up the logger for error logging.\n\n    Configures a logger to log errors to both the console and a file.\n\n    @return None\n    &amp;quot;&amp;quot;&amp;quot;\n    global logger\n\n    # Set up logging configuration\n    logging.basicConfig(level=logging.ERROR)  # Set the logging level to ERROR\n\n    file_handler = logging.FileHandler(\n            os.path.join(os.path.abspath(os.path.dirname(__file__)),\n                         &amp;#39;arduino_exec.log&amp;#39;))\n    formatter = logging.Formatter(&amp;#39;%(asctime)s - %(levelname)s - %(message)s&amp;#39;)\n    file_handler.setFormatter(formatter)\n\n    logger = logging.getLogger(__name__)\n    logger.setLevel(logging.ERROR)  # Set the logging level to ERROR\n    logger.addHandler(file_handler)\n\n\ndef get_args():\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Get the serial port from the command line.\n\n    Checks if a serial port argument is provided in the command line.\n    Also, handles --help or -h options to display usage information.\n\n    @return str: The serial port obtained from the command line.\n    &amp;quot;&amp;quot;&amp;quot;\n    global port_name\n\n    if &amp;quot;--help&amp;quot; in sys.argv or &amp;quot;-h&amp;quot; in sys.argv:\n        print(&amp;quot;Usage: python arduino_exec.py &amp;lt;COM_port&amp;gt;&amp;quot;)\n        print(&amp;quot;\\nOptions:&amp;quot;)\n        print(&amp;quot;  --help, -h   : Show this help message and exit.&amp;quot;)\n        print(&amp;quot;  ! &amp;lt;command&amp;gt;  : Execute a command on the &amp;quot;\n              + &amp;quot;host machine and get back any output.&amp;quot;)\n        print(&amp;quot;  @ &amp;lt;macro&amp;gt;    : Execute a pre-registered command &amp;quot;\n              + &amp;quot;on the host machine using a macro name.&amp;quot;)\n        print(&amp;quot;  &amp;amp; &amp;lt;folder&amp;gt;   : Compile and upload the Arduino &amp;quot;\n              + &amp;quot;code in the specified folder.&amp;quot;)\n        print(&amp;quot;\\nMacro Management Commands:&amp;quot;)\n        print(&amp;quot;  @list_macros  : List all registered macros.&amp;quot;)\n        print(&amp;quot;  @add_macro    : Add a new macro (Usage: &amp;quot;\n              + &amp;quot;@add_macro:&amp;lt;name&amp;gt;:&amp;lt;command&amp;gt;).&amp;quot;)\n        print(&amp;quot;  @delete_macro : Delete a macro (Usage: &amp;quot;\n              + &amp;quot;@delete_macro:&amp;lt;name&amp;gt;).&amp;quot;)\n        exit(0)\n\n    if len(sys.argv) &amp;lt;= 1:\n        print(&amp;quot;Usage: python arduino_exec.py &amp;lt;COM_port&amp;gt;&amp;quot;)\n        exit(-1)\n\n    port_name = sys.argv[1]\n    return port_name\n\n\ndef sigint_handler(signum, frame):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Signal handler for SIGINT (Ctrl+C).\n\n    Handles the SIGINT signal (Ctrl+C) to save macros and exit gracefully.\n\n    @param signum: Signal number\n    @param frame: Current stack frame\n\n    @return None\n    &amp;quot;&amp;quot;&amp;quot;\n    print(&amp;quot; User hit ctrl-c, exiting.&amp;quot;)\n    save_macros(macros)\n    sys.exit(0)\n\n\ndef set_signal_handler():\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Set the signal handler for SIGINT.\n\n    Sets the signal handler for SIGINT (Ctrl+C) to sigint_handler.\n\n    @return None\n    &amp;quot;&amp;quot;&amp;quot;\n    signal.signal(signal.SIGINT, sigint_handler)\n\n\ndef open_serial_port(port):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Open the specified serial port.\n\n    Attempts to open the specified serial port with a timeout of 1 second.\n\n    @param port: The serial port to open.\n\n    @return serial.Serial: The opened serial port.\n\n    @exit If the serial port cannot be opened,\n          the program exits with an error message.\n    &amp;quot;&amp;quot;&amp;quot;\n    global cmd_serial\n\n    cmd_serial = serial.Serial(port, 9600, timeout=0.03)\n\n    if not cmd_serial:\n        print(f&amp;quot;Could not open the serial port: &amp;#39;{port}&amp;#39;&amp;quot;)\n        exit(-1)\n\n    print(f&amp;quot;Successfully opened serial port: &amp;#39;{port}&amp;#39;&amp;quot;)\n    return cmd_serial\n\n\ndef execute_command(command):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Execute a command and capture the output.\n\n    Executes a command using subprocess and captures the output.\n    If an error occurs, logs the error and returns an error message.\n\n    @param command: The command to execute.\n\n    @return str: The output of the command or an error message.\n    &amp;quot;&amp;quot;&amp;quot;\n    print(f&amp;quot;Executing: {command}&amp;quot;)  # Output for the user\n\n    try:\n        result = subprocess.check_output(command, shell=True,\n                                         stderr=subprocess.STDOUT)\n        return result.decode(&amp;#39;utf-8&amp;#39;)\n    except subprocess.CalledProcessError as e:\n        errtxt = f&amp;quot;Error executing command: {e}&amp;quot;\n        logger.error(errtxt)\n        return errtxt\n    except Exception as e:\n        errtxt = f&amp;quot;An unexpected error occurred: {e}&amp;quot;\n        logger.error(errtxt)\n        return errtxt\n\n\ndef load_macros(filename=&amp;#39;macros.txt&amp;#39;):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Load macros from a file.\n\n    Attempts to load macros from a specified file.\n    If the file is not found, returns an empty dictionary.\n\n    @param filename: The name of the file containing\n                     macros (default: &amp;#39;macros.txt&amp;#39;).\n\n    @return dict: The loaded macros.\n    &amp;quot;&amp;quot;&amp;quot;\n    try:\n        with open(filename, &amp;#39;r&amp;#39;) as file:\n            return json.load(file)\n    except FileNotFoundError:\n        return {}\n\n\ndef save_macros(macros, filename=&amp;#39;macros.txt&amp;#39;):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Save macros to a file.\n\n    Saves the provided macros to a specified file.\n\n    @param macros: The macros to save.\n    @param filename: The name of the file to save macros\n                     to (default: &amp;#39;macros.txt&amp;#39;).\n\n    @return None\n    &amp;quot;&amp;quot;&amp;quot;\n    with open(filename, &amp;#39;w&amp;#39;) as file:\n        json.dump(macros, file, indent=4, sort_keys=True)\n\n\ndef create_macro(name, command, macros):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Create a new macro.\n\n    Creates a new macro with the given name and command, and saves it.\n\n    @param name: The name of the new macro.\n    @param command: The command associated with the new macro.\n    @param macros: The dictionary of existing macros.\n\n    @return None\n    &amp;quot;&amp;quot;&amp;quot;\n    macros[name] = command\n    save_macros(macros)\n\n\ndef read_macro(name, macros):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Read the command associated with a macro.\n\n    Retrieves the command associated with a given macro name.\n\n    @param name: The name of the macro.\n    @param macros: The dictionary of existing macros.\n\n    @return str: The command associated with the macro or an error message.\n    &amp;quot;&amp;quot;&amp;quot;\n    return macros.get(name, &amp;quot;Macro not found&amp;quot;)\n\n\ndef execute_macro(name, macros):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Execute a macro.\n\n    Executes the command associated with a given macro name.\n\n    @param name: The name of the macro.\n    @param macros: The dictionary of existing macros.\n\n    @return str: The output of the macro command or an error message.\n    &amp;quot;&amp;quot;&amp;quot;\n    if name in macros:\n        return execute_command(macros[name])\n    else:\n        return f&amp;quot;Macro &amp;#39;{name}&amp;#39; not found&amp;quot;\n\n\ndef delete_macro(name, macros):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Delete a macro.\n\n    Deletes the specified macro and saves the updated macro list.\n\n    @param name: The name of the macro to delete.\n    @param macros: The dictionary of existing macros.\n\n    @return str: Confirmation message or an error message if the\n                 macro is not found.\n    &amp;quot;&amp;quot;&amp;quot;\n    if name in macros:\n        del macros[name]\n        save_macros(macros)\n        return f&amp;quot;Macro &amp;#39;{name}&amp;#39; deleted&amp;quot;\n    else:\n        return f&amp;quot;Macro &amp;#39;{name}&amp;#39; not found&amp;quot;\n\n\ndef compile_and_upload(folder):\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Compile and upload Arduino code.\n\n    Compiles and uploads Arduino code from the specified folder.\n\n    @param folder: The folder containing the Arduino project.\n\n    @return str: Result of compilation and upload process.\n    &amp;quot;&amp;quot;&amp;quot;\n    global cmd_serial\n\n    # Check if the specified folder exists\n    if not os.path.exists(folder):\n        return f&amp;quot;Error: Folder &amp;#39;{folder}&amp;#39; does not exist.&amp;quot;\n\n    # Check if the folder contains a matching .ino file\n    ino_file = os.path.join(folder, f&amp;quot;{os.path.basename(folder)}.ino&amp;quot;)\n    if not os.path.isfile(ino_file):\n        return f&amp;quot;Error: Folder &amp;#39;{folder}&amp;#39; does not contain a matching .ino file.&amp;quot;\n\n    # Define constant part of the compile and upload commands\n    PORT_NAME = &amp;#39;/dev/cu.usbserial-41430&amp;#39;\n    COMPILE_COMMAND_BASE = &amp;#39;arduino-cli compile --fqbn arduino:avr:nano&amp;#39;\n    UPLOAD_COMMAND_BASE = &amp;#39;arduino-cli upload -p &amp;#39; + PORT_NAME + &amp;#39; --fqbn arduino:avr:nano:cpu=atmega328old&amp;#39;\n\n    compile_command = f&amp;#39;{COMPILE_COMMAND_BASE} {folder}&amp;#39;\n    upload_command = f&amp;#39;{UPLOAD_COMMAND_BASE} {folder}&amp;#39;\n\n    compile_result = execute_command(compile_command)\n    print(f&amp;quot;executed: {compile_command}\\nresult: {compile_result}&amp;quot;)\n\n    upload_result = execute_command(upload_command)\n    print(f&amp;quot;executed: {upload_command}\\nresult: {upload_result}&amp;quot;)\n\n    result = f&amp;quot;Compile Result:\\n{compile_result}\\nUpload Result:\\n{upload_result}&amp;quot;\n\n    return result\n\n\ndef run():\n    &amp;quot;&amp;quot;&amp;quot;\n    @brief Main execution function.\n\n    Handles communication with Arduino, waits for commands, and executes them.\n\n    @return None\n    &amp;quot;&amp;quot;&amp;quot;\n    global macros\n    global cmd_serial\n\n    port = get_args()\n    open_serial_port(port)\n    set_signal_handler()\n    macros = load_macros()\n    setup_logger()\n\n    prompted = False\n    while True:\n        if not prompted:\n            print(&amp;quot;Waiting for a command from the Arduino...&amp;quot;)\n            prompted = True\n\n        arduino_command = cmd_serial.readline().decode(&amp;#39;utf-8&amp;#39;).strip()\n        arduino_command = arduino_command.strip()\n\n        if not arduino_command:\n            continue\n\n        logtext = f&amp;quot;Received command from Arduino: &amp;#39;{arduino_command}&amp;#39;&amp;quot;\n#       print(logtext)\n        logger.info(logtext)\n\n        cmd_id = arduino_command[0]     # Extract the first character\n        command = arduino_command[1:]   # Extract the remainder of the command\n        result = &amp;quot;&amp;quot;\n\n        # Check if the command is an execute command:\n        if cmd_id == &amp;#39;!&amp;#39;:\n            # Dispatch the command to handle built-in commands\n            result = execute_command(command)\n        # Check if the command is a macro related command:\n        elif cmd_id == &amp;#39;@&amp;#39;:\n            if command in macros:\n                result = execute_command(macros[command])\n            elif command == &amp;quot;list_macros&amp;quot;:\n                macro_list = [f&amp;#39;    &amp;quot;{macro}&amp;quot;: &amp;quot;{macros[macro]}&amp;quot;&amp;#39;\n                              for macro in macros]\n                result = &amp;quot;Registered Macros:\\n&amp;quot; + &amp;quot;\\n&amp;quot;.join(macro_list)\n            elif command.startswith(&amp;quot;add_macro:&amp;quot;):\n                _, name, command = command.split(&amp;quot;:&amp;quot;)\n                create_macro(name, command, macros)\n                result = f&amp;quot;Macro &amp;#39;{name}&amp;#39; created with command &amp;#39;{command}&amp;#39;&amp;quot;\n            elif command.startswith(&amp;quot;delete_macro:&amp;quot;):\n                _, name = command.split(&amp;quot;:&amp;quot;)\n                result = delete_macro(name, macros)\n            else:\n                result = f&amp;quot;unrecognized macro command: @{command}&amp;quot;\n        # Check if the command is a build and upload command:\n        elif cmd_id == &amp;#39;&amp;amp;&amp;#39;:\n            # Dispatch the compile and avrdude upload\n            result = compile_and_upload(command)\n        else:\n            result = f&amp;quot;unrecognized cmd_id: {cmd_id}&amp;quot;\n\n        for line in result.split(&amp;#39;\\n&amp;#39;):\n            print(line + &amp;#39;\\n&amp;#39;)\n            cmd_serial.write(line.encode(&amp;#39;utf-8&amp;#39;) + b&amp;#39;\\n&amp;#39;)\n\n        prompted = False\n\n\nif __name__ == &amp;#39;__main__&amp;#39;:\n    run()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The Arduino &lt;code&gt;bang.h&lt;/code&gt; header file:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * bang.h\n * \n * class declaration file for the ArduinoCLI project\n * https://github.com/ripred/ArduinoCLI\n * \n */\n#ifndef  BANG_H_INCL\n#define  BANG_H_INCL\n\n#include &amp;lt;Arduino.h&amp;gt;\n#include &amp;lt;Stream.h&amp;gt;\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\nclass Bang {\nprivate:\n    Stream *dbgstrm {nullptr};\n    Stream *cmdstrm {nullptr};\n\npublic:\n    Bang();\n\n    Bang(Stream &amp;amp;cmd_strm);\n    Bang(Stream &amp;amp;cmd_strm, Stream &amp;amp;dbg_strm);\n\n    String send_and_recv(char const cmd_id, char const *pcmd);\n\n    String exec(char const *pcmd);\n    String macro(char const *pcmd);\n    String compile_and_upload(char const *pcmd);\n\n    long write_file(char const *filename, char const * const lines[], int const num);\n\n    void push_me_pull_you(Stream &amp;amp;str1, Stream &amp;amp;str2);\n\n    void sync();\n\n}; // class Bang\n\n#endif // BANG_H_INCL\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The Arduino &lt;code&gt;bang.cpp&lt;/code&gt; implementation file:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * bang.cpp\n * \n * class implementation file for the ArduinoCLI project\n * https://github.com/ripred/ArduinoCLI\n * \n */\n#include &amp;quot;Bang.h&amp;quot;\n\nBang::Bang() {\n    dbgstrm = nullptr;\n    cmdstrm = nullptr;\n}\n\nBang::Bang(Stream &amp;amp;cmd_strm) :\n    dbgstrm{nullptr},\n    cmdstrm{&amp;amp;cmd_strm}\n{\n}\n\nBang::Bang(Stream &amp;amp;cmd_strm, Stream &amp;amp;dbg_strm) {\n    dbgstrm = &amp;amp;dbg_strm;\n    cmdstrm = &amp;amp;cmd_strm;\n}\n\nString Bang::send_and_recv(char const cmd_id, char const *pcmd) {\n    if (!cmdstrm) { return &amp;quot;&amp;quot;; }\n\n    String output = &amp;quot;&amp;quot;;\n    String cmd(String(cmd_id) + pcmd);\n    Stream &amp;amp;stream = *cmdstrm;\n    stream.println(cmd);\n    delay(10);\n    while (stream.available()) {\n        output += stream.readString();\n    }\n\n    return output;\n}\n\nString Bang::exec(char const *pcmd) {\n    return send_and_recv(&amp;#39;!&amp;#39;, pcmd);\n}\n\nString Bang::macro(char const *pcmd) {\n    return send_and_recv(&amp;#39;@&amp;#39;, pcmd);\n}\n\nString Bang::compile_and_upload(char const *pcmd) {\n    return send_and_recv(&amp;#39;&amp;amp;&amp;#39;, pcmd);\n}\n\nlong Bang::write_file(char const *filename, char const * const lines[], int const num) {\n    if (num &amp;lt;= 0) { return 0; }\n    long len = 0;\n\n    String cmd = String(&amp;quot;echo \\&amp;quot;&amp;quot;) + lines[0] + &amp;quot;\\&amp;quot; &amp;gt; &amp;quot; + filename;\n    len += cmd.length();\n    exec(cmd.c_str());\n\n    for (int i=1; i &amp;lt; num; i++) {\n        cmd = String(&amp;quot;echo \\&amp;quot;&amp;quot;) + lines[i] + &amp;quot;\\&amp;quot; &amp;gt;&amp;gt; &amp;quot; + filename;\n        len += cmd.length();\n        exec(cmd.c_str());\n    }\n\n    return len;\n}\n\nvoid Bang::push_me_pull_you(Stream &amp;amp;str1, Stream &amp;amp;str2) {\n    if (str1.available() &amp;gt;= 2) {\n        uint32_t const period = 20;\n        uint32_t start = millis();\n        while (millis() - start &amp;lt; period) {\n            while (str1.available()) {\n                str2.println(str1.readString());\n            }\n        }\n    }\n}\n\nvoid Bang::sync() {\n    if (!cmdstrm || !dbgstrm) { return; }\n    push_me_pull_you(*cmdstrm, *dbgstrm);\n    push_me_pull_you(*dbgstrm, *cmdstrm);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The Arduino &lt;code&gt;bang.ino&lt;/code&gt; example sketch file:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * bang.ino\n * \n * testing the macro feature that was just added to the Python Agent\n * \n */\n\n#include &amp;lt;Arduino.h&amp;gt;\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n#include &amp;lt;Stream.h&amp;gt;\n#include &amp;quot;Bang.h&amp;quot;\n\n#define  RX_PIN     7\n#define  TX_PIN     8\n\n// Software Serial object to send the\n// commands to the Python Agent\nSoftwareSerial command_serial(RX_PIN, TX_PIN);  // RX, TX\n\n// class wrapper for the ArduinoCLI api so far:\nBang bang(command_serial, Serial);\n\n// flag indicating whether we have run the main compile and upload commmand\nbool executed = false;\n\n#define  ARRSIZE(A)   int(sizeof(A) / sizeof(*(A)))\n\nvoid write_test_file(char const *filename) {\n    String const name = filename;\n    String const folder = name;\n    String const sketch = name + &amp;quot;/&amp;quot; + name + &amp;quot;.ino&amp;quot;;\n\n    String const cmd = String(&amp;quot;mkdir &amp;quot;) + folder;\n    bang.exec(cmd.c_str());\n\n    char const * const blink1[] = {\n        &amp;quot;#include &amp;lt;Arduino.h&amp;gt;&amp;quot;,\n        &amp;quot;&amp;quot;,\n        &amp;quot;void setup() {&amp;quot;,\n        &amp;quot;    Serial.begin(115200);&amp;quot;,\n        &amp;quot;&amp;quot;,\n        &amp;quot;    pinMode(LED_BUILTIN, OUTPUT);&amp;quot;,\n        &amp;quot;}&amp;quot;,\n        &amp;quot;&amp;quot;,\n        &amp;quot;void loop() {&amp;quot;,\n        &amp;quot;    digitalWrite(LED_BUILTIN, HIGH);&amp;quot;,\n        &amp;quot;    delay(1000);&amp;quot;,\n        &amp;quot;    digitalWrite(LED_BUILTIN, LOW);&amp;quot;,\n        &amp;quot;    delay(1000);&amp;quot;,\n        &amp;quot;}&amp;quot;\n    };\n\n    bang.write_file(sketch.c_str(), blink1, ARRSIZE(blink1));\n}\n\nvoid compile_and_upload() {\n    long const cmd_empty_size = command_serial.availableForWrite();\n    long const dbg_empty_size = Serial.availableForWrite();\n\n    if (!executed) {\n        executed = true;\n\n        char const *filename = &amp;quot;blink1&amp;quot;;\n        write_test_file(filename);\n        bang.compile_and_upload(filename);\n\n        while ((command_serial.availableForWrite() != cmd_empty_size)\n               || (Serial.availableForWrite() != dbg_empty_size)) {\n        }\n        Serial.end();\n        command_serial.end();\n        exit(0);\n    }\n}\n\nvoid execute(char const *pcmd) {\n    bang.exec(pcmd);\n}\n\nvoid macros(char const *pcmd) {\n    bang.macro(pcmd);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    command_serial.begin(9600);\n    command_serial.setTimeout(100);\n\n    // test compilation and upload\n    // compile_and_upload();\n\n    // test execution\n    execute(&amp;quot;echo &amp;#39;hello, arduino&amp;#39;&amp;quot;);\n    for (uint32_t const start = millis(); millis() - start &amp;lt; 700;) {\n        bang.sync();\n    }\n\n    execute(&amp;quot;printf \\&amp;quot;this is a test of the command line printf %d, %d, %d\\&amp;quot; 1 2 3&amp;quot;);\n    for (uint32_t const start = millis(); millis() - start &amp;lt; 700;) {\n        bang.sync();\n    }\n\n    // test macros\n    macros(&amp;quot;list_macros&amp;quot;);\n    for (uint32_t const start = millis(); millis() - start &amp;lt; 700;) {\n        bang.sync();\n    }\n}\n\nvoid loop() {\n    bang.sync();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "preview": {
    "images": [
      {
        "source": {
          "url": "https://external-preview.redd.it/S1WQ7EvZhOTcpQNYzhhoUxQ5f0jnkdW_c1IDkpfCT90.jpg?auto=webp&amp;s=1d974c4af5b637872bf8b5d088e335bd14cd7ea7",
          "width": 1200,
          "height": 600
        },
        "resolutions": [
          {
            "url": "https://external-preview.redd.it/S1WQ7EvZhOTcpQNYzhhoUxQ5f0jnkdW_c1IDkpfCT90.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=2c6e451fd1fc6e65ced12a1b02a01363ba70dad9",
            "width": 108,
            "height": 54
          },
          {
            "url": "https://external-preview.redd.it/S1WQ7EvZhOTcpQNYzhhoUxQ5f0jnkdW_c1IDkpfCT90.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=e3caa00e23d596ea1976ec93a80b39a3dcc73908",
            "width": 216,
            "height": 108
          },
          {
            "url": "https://external-preview.redd.it/S1WQ7EvZhOTcpQNYzhhoUxQ5f0jnkdW_c1IDkpfCT90.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=856f4a3b2bed2b4df6d7cf9c7af09e67e60b692d",
            "width": 320,
            "height": 160
          },
          {
            "url": "https://external-preview.redd.it/S1WQ7EvZhOTcpQNYzhhoUxQ5f0jnkdW_c1IDkpfCT90.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=5a0a6dcc0b294bc9f7327a456a8f5e4daa016edf",
            "width": 640,
            "height": 320
          },
          {
            "url": "https://external-preview.redd.it/S1WQ7EvZhOTcpQNYzhhoUxQ5f0jnkdW_c1IDkpfCT90.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=d955791112b7f1a99e297a4c2c03ada764e514ee",
            "width": 960,
            "height": 480
          },
          {
            "url": "https://external-preview.redd.it/S1WQ7EvZhOTcpQNYzhhoUxQ5f0jnkdW_c1IDkpfCT90.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=89e2d89138ba2f68ef790809abfd3756627ef8f9",
            "width": 1080,
            "height": 540
          }
        ],
        "variants": {},
        "id": "2KJr3rgx_7b9d49Hk6793YM4lhZ77X9Ndyi3rWkRB9E"
      }
    ],
    "enabled": false
  },
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "5bfb5318-a03e-11ee-adc5-42b05cf4a7d6",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#8242ff",
  "id": "18poxnj",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/18poxnj/arduinocli_update_notes_4/",
  "stickied": false,
  "url": "https://www.reddit.com/r/ripred/comments/18poxnj/arduinocli_update_notes_4/",
  "subreddit_subscribers": 43,
  "created_utc": 1703397578.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}