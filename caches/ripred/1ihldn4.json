{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "# Designing a Memory-Efficient Minimax (Alpha-Beta) Library for Arduino Uno\n\nDeveloping a turn-based game AI on an Arduino Uno (ATmega328P) requires careful consideration of **memory constraints** and **performance optimizations**. The goal is to implement a robust minimax algorithm with alpha-beta pruning as a reusable library, flexible enough for games like tic-tac-toe, checkers, or even chess, while working within \\~2KB of SRAM and 32KB of flash. Below we present the design, implementation strategy, and example code for such a library, balancing theoretical rigor with practical, memory-conscious techniques.\n\n# Constraints and Challenges\n\n# 1.1 Hardware Limitations (Memory and CPU)\n\n* **Limited RAM (2KB) and Flash (32KB):** The ATmega328P has *very* little RAM available. We cannot afford to allocate large data structures or full game trees in memory. Dynamic memory allocation (`malloc/new`) is avoided entirely due to fragmentation risks and tight memory ([DO NOT EVER EVER USE DYNAMIC MEMORY ON AVR \u00b7 Issue #2367 \u00b7 MarlinFirmware/Marlin \u00b7 GitHub](https://github.com/MarlinFirmware/Marlin/issues/2367#:~:text=There%20are%20three%20issues%20with,the%20use%20of%20malloc)) Instead, we use static or stack-allocated structures with fixed sizes known at compile time. The C++ STL is also off-limits \u2013 it\u2019s not included in the Arduino core, and its overhead doesn\u2019t fit comfortably in such limited space ([Is the C++ STL fully supported on Arduino? - Arduino Stack Exchange](https://arduino.stackexchange.com/questions/24790/is-the-c-stl-fully-supported-on-arduino#:~:text=The%20STL%20is%20not%20a,part%20of%20Arduino%20IDE))\n* **16MHz 8-bit CPU:** The processor is modest, so algorithms must be efficient. However, with good pruning and small search depths, the Arduino can still evaluate thousands of moves per second ([Writing an Embedded Chess Engine - Part 5 - Showcase - Arduino Forum](https://forum.arduino.cc/t/writing-an-embedded-chess-engine-part-5/1130748#:~:text=no%20output%20until%20the%20end,to%203%2C200%20moves%20per%20second)) We must optimize to reduce unnecessary computations (via pruning and move ordering) and avoid heavy C++ abstractions that add runtime cost (like virtual calls in tight loops, if possible).\n\n# 1.2 Performance Considerations\n\n* **Static Allocation &amp; Stack Use:** We\u2019ll allocate all needed memory up front. For example, move lists and any auxiliary data will be fixed-size arrays. Using the stack for recursion and local variables is preferred for temporary data, as it\u2019s reclaimed automatically and avoids fragmentation ([DO NOT EVER EVER USE DYNAMIC MEMORY ON AVR \u00b7 Issue #2367 \u00b7 MarlinFirmware/Marlin \u00b7 GitHub](https://github.com/MarlinFirmware/Marlin/issues/2367#:~:text=There%20are%20three%20issues%20with,the%20use%20of%20malloc)) We ensure the stack usage per recursive call is minimal. (In a chess engine example, about 142 bytes were used per recursion level, allowing \\~7 levels deep under 2KB RAM ([Writing an Embedded Chess Engine - Part 5 - Showcase - Arduino Forum](https://forum.arduino.cc/t/writing-an-embedded-chess-engine-part-5/1130748#:~:text=Extensive%20effort%20has%20gone%20into,running%20under%202K%20of%20RAM)) )\n* **No Dynamic Memory or STL:** Dynamic allocation on AVR can lead to fragmented memory and unpredictable failures, so we **never use** `new`/`delete` or heap containers ([DO NOT EVER EVER USE DYNAMIC MEMORY ON AVR \u00b7 Issue #2367 \u00b7 MarlinFirmware/Marlin \u00b7 GitHub](https://github.com/MarlinFirmware/Marlin/issues/2367#:~:text=There%20are%20three%20issues%20with,the%20use%20of%20malloc)) All data structures (boards, move buffers, etc.) are static or global. The C++ STL (e.g. `&lt;vector&gt;`, `&lt;string&gt;`) is avoided both because it can internally allocate memory and because it increases code size and RAM usage ([Is the C++ STL fully supported on Arduino? - Arduino Stack Exchange](https://arduino.stackexchange.com/questions/24790/is-the-c-stl-fully-supported-on-arduino#:~:text=The%20STL%20is%20not%20a,part%20of%20Arduino%20IDE)) Instead, we use simple C-style arrays and pointers.\n* **Controlled Recursion Depth:** Deep recursion can overflow the limited stack. Fortunately, many games have manageable search depths. Tic-tac-toe, for instance, has at most 9 moves to search. For more complex games, we impose a depth limit. Even chess on Arduino has been demonstrated to \\~6-ply depth by carefully managing memory ([GitHub - ripred/MicroChess: A full featured chess engine designed to fit in an embedded environment, using less than 2K of RAM!](https://github.com/ripred/MicroChess#:~:text=Keeping%20under%202K%20of%20memory%2C,base%20for%20many%20creative%20projects)) We will allow specifying a maximum search depth to prevent running out of stack or time. In the worst case, exploring one path at a time via recursion is far more memory-efficient than building an entire game tree in RAM ([Tic-Tac-Toe on Arduino (MiniMax)](http://pcarduino.blogspot.com/2014/10/tic-tac-toe-on-arduino-minimax.html#:~:text=It%27s%20still%20possible%20to%20build,a%20lot%20more%20than%20enough))\n* **Alpha-Beta Pruning:** Alpha-beta will significantly cut down the number of nodes evaluated compared to naive minimax, which is crucial on a slow CPU. By pruning \u201cunpromising\u201d branches, we can effectively double or triple the search depth for the same cost ([Alpha Beta Pruning in Artificial Intelligence](https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:~:text=Impact%20of%20Alpha,Search%20Depth)) ([Alpha Beta Pruning in Artificial Intelligence](https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:~:text=%2A%20Pruning%20Saves%20Time%3A%20Alpha,the%20algorithm%20even%20more%20efficient)) This optimization is a must for anything beyond trivial games.\n* **Move Ordering Heuristics:** The effectiveness of alpha-beta depends on checking the best moves first ([Alpha Beta Pruning in Artificial Intelligence](https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:~:text=%2A%20Pruning%20Saves%20Time%3A%20Alpha,the%20algorithm%20even%20more%20efficient)) ([Alpha Beta Pruning in Artificial Intelligence](https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:~:text=Move%20Ordering%20in%20Alpha)) We plan to incorporate simple move-ordering heuristics to improve pruning:For example, in tic-tac-toe or Connect-4, moves that win or block a win are tried first. In checkers/chess, capture moves or central moves might be given priority.We could also perform a **shallow search or evaluation for move ordering**: e.g. quickly score each possible move and sort them before deeper search ([Alpha Beta Pruning in Artificial Intelligence](https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:~:text=idea%20is%20to%20perform%20a,pruning%20of%20less%20promising%20moves)) Even a 1-ply lookahead (evaluate the resulting position without further recursion) can identify strong moves to explore first ([Alpha Beta Pruning in Artificial Intelligence](https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:~:text=idea%20is%20to%20perform%20a,pruning%20of%20less%20promising%20moves))These heuristics will be kept simple (to avoid heavy computation), but even basic ordering can lead to earlier alpha-beta cutoffs ([Alpha Beta Pruning in Artificial Intelligence](https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:~:text=%2A%20Pruning%20Saves%20Time%3A%20Alpha,the%20algorithm%20even%20more%20efficient))\n* **Iterative Deepening (Optional):** If time management is needed, the library could implement iterative deepening search \u2013 progressively increase depth and use the earlier results to guide move ordering for the next iteration ([What else can boost iterative deepening with alpha-beta pruning?](https://ai.stackexchange.com/questions/5174/what-else-can-boost-iterative-deepening-with-alpha-beta-pruning#:~:text=What%20else%20can%20boost%20iterative,go%20for%20depth%20d%2B1)) This ensures the best found move is available if we run out of time. On an Arduino, time-based limits are tricky but doable (e.g., using `millis()` to cut off search). By default, our design uses a fixed depth for simplicity, but it can be extended to iterative deepening if needed for more complex games.",
  "author_fullname": "t2_adfkq",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "The Amazing Minimax Algorithm (and Why You Should Use It in Your Games!) Pt 1",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Algorithms"
    }
  ],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_1ihldn4",
  "quarantine": false,
  "link_flair_text_color": "light",
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 2,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Algorithms",
  "can_mod_post": false,
  "score": 2,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": false,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1738685849.0,
  "link_flair_type": "richtext",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.ripred",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;h1&gt;Designing a Memory-Efficient Minimax (Alpha-Beta) Library for Arduino Uno&lt;/h1&gt;\n\n&lt;p&gt;Developing a turn-based game AI on an Arduino Uno (ATmega328P) requires careful consideration of &lt;strong&gt;memory constraints&lt;/strong&gt; and &lt;strong&gt;performance optimizations&lt;/strong&gt;. The goal is to implement a robust minimax algorithm with alpha-beta pruning as a reusable library, flexible enough for games like tic-tac-toe, checkers, or even chess, while working within ~2KB of SRAM and 32KB of flash. Below we present the design, implementation strategy, and example code for such a library, balancing theoretical rigor with practical, memory-conscious techniques.&lt;/p&gt;\n\n&lt;h1&gt;Constraints and Challenges&lt;/h1&gt;\n\n&lt;h1&gt;1.1 Hardware Limitations (Memory and CPU)&lt;/h1&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Limited RAM (2KB) and Flash (32KB):&lt;/strong&gt; The ATmega328P has &lt;em&gt;very&lt;/em&gt; little RAM available. We cannot afford to allocate large data structures or full game trees in memory. Dynamic memory allocation (&lt;code&gt;malloc/new&lt;/code&gt;) is avoided entirely due to fragmentation risks and tight memory (&lt;a href=\"https://github.com/MarlinFirmware/Marlin/issues/2367#:%7E:text=There%20are%20three%20issues%20with,the%20use%20of%20malloc\"&gt;DO NOT EVER EVER USE DYNAMIC MEMORY ON AVR \u00b7 Issue #2367 \u00b7 MarlinFirmware/Marlin \u00b7 GitHub&lt;/a&gt;) Instead, we use static or stack-allocated structures with fixed sizes known at compile time. The C++ STL is also off-limits \u2013 it\u2019s not included in the Arduino core, and its overhead doesn\u2019t fit comfortably in such limited space (&lt;a href=\"https://arduino.stackexchange.com/questions/24790/is-the-c-stl-fully-supported-on-arduino#:%7E:text=The%20STL%20is%20not%20a,part%20of%20Arduino%20IDE\"&gt;Is the C++ STL fully supported on Arduino? - Arduino Stack Exchange&lt;/a&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;16MHz 8-bit CPU:&lt;/strong&gt; The processor is modest, so algorithms must be efficient. However, with good pruning and small search depths, the Arduino can still evaluate thousands of moves per second (&lt;a href=\"https://forum.arduino.cc/t/writing-an-embedded-chess-engine-part-5/1130748#:%7E:text=no%20output%20until%20the%20end,to%203%2C200%20moves%20per%20second\"&gt;Writing an Embedded Chess Engine - Part 5 - Showcase - Arduino Forum&lt;/a&gt;) We must optimize to reduce unnecessary computations (via pruning and move ordering) and avoid heavy C++ abstractions that add runtime cost (like virtual calls in tight loops, if possible).&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h1&gt;1.2 Performance Considerations&lt;/h1&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Static Allocation &amp;amp; Stack Use:&lt;/strong&gt; We\u2019ll allocate all needed memory up front. For example, move lists and any auxiliary data will be fixed-size arrays. Using the stack for recursion and local variables is preferred for temporary data, as it\u2019s reclaimed automatically and avoids fragmentation (&lt;a href=\"https://github.com/MarlinFirmware/Marlin/issues/2367#:%7E:text=There%20are%20three%20issues%20with,the%20use%20of%20malloc\"&gt;DO NOT EVER EVER USE DYNAMIC MEMORY ON AVR \u00b7 Issue #2367 \u00b7 MarlinFirmware/Marlin \u00b7 GitHub&lt;/a&gt;) We ensure the stack usage per recursive call is minimal. (In a chess engine example, about 142 bytes were used per recursion level, allowing ~7 levels deep under 2KB RAM (&lt;a href=\"https://forum.arduino.cc/t/writing-an-embedded-chess-engine-part-5/1130748#:%7E:text=Extensive%20effort%20has%20gone%20into,running%20under%202K%20of%20RAM\"&gt;Writing an Embedded Chess Engine - Part 5 - Showcase - Arduino Forum&lt;/a&gt;) )&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;No Dynamic Memory or STL:&lt;/strong&gt; Dynamic allocation on AVR can lead to fragmented memory and unpredictable failures, so we &lt;strong&gt;never use&lt;/strong&gt; &lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt; or heap containers (&lt;a href=\"https://github.com/MarlinFirmware/Marlin/issues/2367#:%7E:text=There%20are%20three%20issues%20with,the%20use%20of%20malloc\"&gt;DO NOT EVER EVER USE DYNAMIC MEMORY ON AVR \u00b7 Issue #2367 \u00b7 MarlinFirmware/Marlin \u00b7 GitHub&lt;/a&gt;) All data structures (boards, move buffers, etc.) are static or global. The C++ STL (e.g. &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;) is avoided both because it can internally allocate memory and because it increases code size and RAM usage (&lt;a href=\"https://arduino.stackexchange.com/questions/24790/is-the-c-stl-fully-supported-on-arduino#:%7E:text=The%20STL%20is%20not%20a,part%20of%20Arduino%20IDE\"&gt;Is the C++ STL fully supported on Arduino? - Arduino Stack Exchange&lt;/a&gt;) Instead, we use simple C-style arrays and pointers.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Controlled Recursion Depth:&lt;/strong&gt; Deep recursion can overflow the limited stack. Fortunately, many games have manageable search depths. Tic-tac-toe, for instance, has at most 9 moves to search. For more complex games, we impose a depth limit. Even chess on Arduino has been demonstrated to ~6-ply depth by carefully managing memory (&lt;a href=\"https://github.com/ripred/MicroChess#:%7E:text=Keeping%20under%202K%20of%20memory%2C,base%20for%20many%20creative%20projects\"&gt;GitHub - ripred/MicroChess: A full featured chess engine designed to fit in an embedded environment, using less than 2K of RAM!&lt;/a&gt;) We will allow specifying a maximum search depth to prevent running out of stack or time. In the worst case, exploring one path at a time via recursion is far more memory-efficient than building an entire game tree in RAM (&lt;a href=\"http://pcarduino.blogspot.com/2014/10/tic-tac-toe-on-arduino-minimax.html#:%7E:text=It%27s%20still%20possible%20to%20build,a%20lot%20more%20than%20enough\"&gt;Tic-Tac-Toe on Arduino (MiniMax)&lt;/a&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Alpha-Beta Pruning:&lt;/strong&gt; Alpha-beta will significantly cut down the number of nodes evaluated compared to naive minimax, which is crucial on a slow CPU. By pruning \u201cunpromising\u201d branches, we can effectively double or triple the search depth for the same cost (&lt;a href=\"https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:%7E:text=Impact%20of%20Alpha,Search%20Depth\"&gt;Alpha Beta Pruning in Artificial Intelligence&lt;/a&gt;) (&lt;a href=\"https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:%7E:text=%2A%20Pruning%20Saves%20Time%3A%20Alpha,the%20algorithm%20even%20more%20efficient\"&gt;Alpha Beta Pruning in Artificial Intelligence&lt;/a&gt;) This optimization is a must for anything beyond trivial games.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Move Ordering Heuristics:&lt;/strong&gt; The effectiveness of alpha-beta depends on checking the best moves first (&lt;a href=\"https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:%7E:text=%2A%20Pruning%20Saves%20Time%3A%20Alpha,the%20algorithm%20even%20more%20efficient\"&gt;Alpha Beta Pruning in Artificial Intelligence&lt;/a&gt;) (&lt;a href=\"https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:%7E:text=Move%20Ordering%20in%20Alpha\"&gt;Alpha Beta Pruning in Artificial Intelligence&lt;/a&gt;) We plan to incorporate simple move-ordering heuristics to improve pruning:For example, in tic-tac-toe or Connect-4, moves that win or block a win are tried first. In checkers/chess, capture moves or central moves might be given priority.We could also perform a &lt;strong&gt;shallow search or evaluation for move ordering&lt;/strong&gt;: e.g. quickly score each possible move and sort them before deeper search (&lt;a href=\"https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:%7E:text=idea%20is%20to%20perform%20a,pruning%20of%20less%20promising%20moves\"&gt;Alpha Beta Pruning in Artificial Intelligence&lt;/a&gt;) Even a 1-ply lookahead (evaluate the resulting position without further recursion) can identify strong moves to explore first (&lt;a href=\"https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:%7E:text=idea%20is%20to%20perform%20a,pruning%20of%20less%20promising%20moves\"&gt;Alpha Beta Pruning in Artificial Intelligence&lt;/a&gt;)These heuristics will be kept simple (to avoid heavy computation), but even basic ordering can lead to earlier alpha-beta cutoffs (&lt;a href=\"https://www.appliedaicourse.com/blog/alpha-beta-pruning-in-artificial-intelligence/#:%7E:text=%2A%20Pruning%20Saves%20Time%3A%20Alpha,the%20algorithm%20even%20more%20efficient\"&gt;Alpha Beta Pruning in Artificial Intelligence&lt;/a&gt;)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Iterative Deepening (Optional):&lt;/strong&gt; If time management is needed, the library could implement iterative deepening search \u2013 progressively increase depth and use the earlier results to guide move ordering for the next iteration (&lt;a href=\"https://ai.stackexchange.com/questions/5174/what-else-can-boost-iterative-deepening-with-alpha-beta-pruning#:%7E:text=What%20else%20can%20boost%20iterative,go%20for%20depth%20d%2B1\"&gt;What else can boost iterative deepening with alpha-beta pruning?&lt;/a&gt;) This ensures the best found move is available if we run out of time. On an Arduino, time-based limits are tricky but doable (e.g., using &lt;code&gt;millis()&lt;/code&gt; to cut off search). By default, our design uses a fixed depth for simplicity, but it can be extended to iterative deepening if needed for more complex games.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": false,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "fe7a45c6-163e-11ed-bf29-7e0b698a7bb7",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#7193ff",
  "id": "1ihldn4",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/1ihldn4/the_amazing_minimax_algorithm_and_why_you_should/",
  "stickied": false,
  "url": "https://www.reddit.com/r/ripred/comments/1ihldn4/the_amazing_minimax_algorithm_and_why_you_should/",
  "subreddit_subscribers": 43,
  "created_utc": 1738685849.0,
  "num_crossposts": 1,
  "media": null,
  "is_video": false
}