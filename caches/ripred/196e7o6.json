{
  "approved_at_utc": null,
  "subreddit": "ripred",
  "selftext": "Adding an OLED or LCD display to a project is great. It adds portability to a project, you can use it for debugging, all kinds of great stuff.\n\nAnd like most people once I add a display to a project I usually end up eventually wanting to extend the flexibility of the project by adding a menu system for the display.\n\nAdding a menu system enhances a project in a lot of ways:\n\n* Instead of using hard-coded values in your program for things like thresholds etc. you can hand control over to the user at runtime and let them decide which values work best in practice. You can have a configuration subsystem in your projects that saves to eeprom etc.\n* Instead of your project just running one specific set of code when it is powered up, you can hand control over to the user at runtime to decide. That allows your project to grow it's features over time and makes the actual use of the finished project more enjoyable and flexible.\n\nMenus extend the practical value of projects by letting the final end user actually interact with and \"use\" your finished creation instead of it just \"doing a thing\" when you turn it on. I could go on and on about designing for the end user experience and giving yourself the developer, the gift of future flexibility, yada yada but the point is that for embedded programming, I like menus.\n\nAnd like most people I've searched for and used many menu libraries and approaches. But none of them fit all of my needs:\n\n* It should be device and project independent. Any inputs and any type of display output should be able to be used. It should work as easily with an LCD or OLED as the **output** display as it does with the Serial monitor as the display. The **inputs** should be virtual so that any actual inputs can be used on various projects. Using push buttons to make selections and choices in the menu for one project should work the same easy way as using a serial interface to drive it in another project.\n* It should be extremely lightweight and memory conscious.\n* It should be \\*extremely\\* flexible. Menus should be able to be nested to any depth. The system should support any one of the following interchangeably for any menu entry anywhere in the hierarchy:\n\n1. Every entry has a displayable title, string, or value\n2. Display and/or configure integer config values\n3. Call any associated callback function when the menu entry is selected\n4. Contain another titled sub menu\n\n* It should be designed to be kind to the future programmer users of the api. When things in the menu change they should all be done in a declarative style in one place without needing to make other changes as the menu content changes. This is hugely important.\n\nSo eventually I wrote my own menu architecture that checks all of those boxes.\n\nIn this series of posts I'll talk about what I have so far, the design approach and the implementation. [The code is on pastebin right now](https://pastebin.com/eun7HWW1) and eventually I will create a github repo for it.\n\nAs a tease, here is an example of a multi-level menu system that it might be used in. Note the single, declarative, easy to maintain design approach:\n\n    #include \"menu.h\"\n    #include &lt;LiquidCrystal.h&gt;\n    \n    // LCD Configuration\n    LiquidCrystal lcd(8, 9, 4, 5, 6, 7);\n    \n    // Function to update the LCD display\n    void updateDisplay(const char *line1, const char *line2) {\n        lcd.clear();\n        lcd.setCursor(0, 0);\n        lcd.print(line1);\n        lcd.setCursor(0, 1);\n        lcd.print(line2);\n    }\n    \n    // Function to get user input from Serial Monitor\n    choice_t getUserInput(const char *prompt) {\n        Serial.print(prompt);\n        while (!Serial.available()) {\n            // Wait for input\n        }\n    \n        char inputChar = Serial.read();\n        switch (inputChar) {\n            case 'U': return Up;\n            case 'D': return Down;\n            case 'S': return Select;\n            case 'C': return Cancel;\n            default: return Invalid;\n        }\n    }\n    \n    // Declare the entire menu structure in place\n    static menu_t printerMenu(\n        \"3D Printer Menu\",\n        menu_t(\"Print\",\n            menu_t(\"Select File\",\n                menu_t(\"File 1\", []() { Serial.println(\"Printing File 1...\"); }),\n                menu_t(\"File 2\", []() { Serial.println(\"Printing File 2...\"); })\n            ),\n            menu_t(\"Print Settings\",\n                menu_t(\"Layer Height\", []() { Serial.println(\"Adjusting Layer Height...\"); }),\n                menu_t(\"Temperature\", []() { Serial.println(\"Adjusting Temperature...\"); })\n            )\n        ),\n        menu_t(\"Maintenance\",\n            menu_t(\"Calibration\",\n                menu_t(\"Bed Leveling\", []() { Serial.println(\"Performing Bed Leveling...\"); }),\n                menu_t(\"Nozzle Alignment\", []() { Serial.println(\"Aligning Nozzle...\"); })\n            ),\n            menu_t(\"Clean Nozzle\", []() { Serial.println(\"Cleaning Nozzle...\"); })\n        ),\n        menu_t(\"Utilities\",\n            menu_t(\"Firmware Update\", []() { Serial.println(\"Updating Firmware...\"); }),\n            menu_t(\"Power Off\", []() { Serial.println(\"Powering Off...\"); })\n        )\n    );\n    \n    void setup() {\n        Serial.begin(115200);\n        lcd.begin(16, 2);\n    }\n    \n    void loop() {\n        // Running the printer menu in the loop\n        printerMenu.run(getUserInput, updateDisplay).exec();\n    }\n\n&amp;#x200B;",
  "author_fullname": "t2_adfkq",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "The Ultimate Lightweight Embedded Menu System",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Project"
    }
  ],
  "subreddit_name_prefixed": "r/ripred",
  "hidden": false,
  "pwls": null,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_196e7o6",
  "quarantine": false,
  "link_flair_text_color": "light",
  "upvote_ratio": 1.0,
  "author_flair_background_color": "transparent",
  "subreddit_type": "public",
  "ups": 1,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "9fa2ceaa-053c-11ed-bb97-124dff5ea4b4",
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Project",
  "can_mod_post": false,
  "score": 1,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": 1705233838.0,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":snoo_facepalm:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/wzxf63qpaezz_t5_3nqvj/snoo_facepalm"
    }
  ],
  "gildings": {},
  "post_hint": "self",
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1705233060.0,
  "link_flair_type": "richtext",
  "wls": null,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.ripred",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Adding an OLED or LCD display to a project is great. It adds portability to a project, you can use it for debugging, all kinds of great stuff.&lt;/p&gt;\n\n&lt;p&gt;And like most people once I add a display to a project I usually end up eventually wanting to extend the flexibility of the project by adding a menu system for the display.&lt;/p&gt;\n\n&lt;p&gt;Adding a menu system enhances a project in a lot of ways:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Instead of using hard-coded values in your program for things like thresholds etc. you can hand control over to the user at runtime and let them decide which values work best in practice. You can have a configuration subsystem in your projects that saves to eeprom etc.&lt;/li&gt;\n&lt;li&gt;Instead of your project just running one specific set of code when it is powered up, you can hand control over to the user at runtime to decide. That allows your project to grow it&amp;#39;s features over time and makes the actual use of the finished project more enjoyable and flexible.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Menus extend the practical value of projects by letting the final end user actually interact with and &amp;quot;use&amp;quot; your finished creation instead of it just &amp;quot;doing a thing&amp;quot; when you turn it on. I could go on and on about designing for the end user experience and giving yourself the developer, the gift of future flexibility, yada yada but the point is that for embedded programming, I like menus.&lt;/p&gt;\n\n&lt;p&gt;And like most people I&amp;#39;ve searched for and used many menu libraries and approaches. But none of them fit all of my needs:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;It should be device and project independent. Any inputs and any type of display output should be able to be used. It should work as easily with an LCD or OLED as the &lt;strong&gt;output&lt;/strong&gt; display as it does with the Serial monitor as the display. The &lt;strong&gt;inputs&lt;/strong&gt; should be virtual so that any actual inputs can be used on various projects. Using push buttons to make selections and choices in the menu for one project should work the same easy way as using a serial interface to drive it in another project.&lt;/li&gt;\n&lt;li&gt;It should be extremely lightweight and memory conscious.&lt;/li&gt;\n&lt;li&gt;It should be *extremely* flexible. Menus should be able to be nested to any depth. The system should support any one of the following interchangeably for any menu entry anywhere in the hierarchy:&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Every entry has a displayable title, string, or value&lt;/li&gt;\n&lt;li&gt;Display and/or configure integer config values&lt;/li&gt;\n&lt;li&gt;Call any associated callback function when the menu entry is selected&lt;/li&gt;\n&lt;li&gt;Contain another titled sub menu&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;ul&gt;\n&lt;li&gt;It should be designed to be kind to the future programmer users of the api. When things in the menu change they should all be done in a declarative style in one place without needing to make other changes as the menu content changes. This is hugely important.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;So eventually I wrote my own menu architecture that checks all of those boxes.&lt;/p&gt;\n\n&lt;p&gt;In this series of posts I&amp;#39;ll talk about what I have so far, the design approach and the implementation. &lt;a href=\"https://pastebin.com/eun7HWW1\"&gt;The code is on pastebin right now&lt;/a&gt; and eventually I will create a github repo for it.&lt;/p&gt;\n\n&lt;p&gt;As a tease, here is an example of a multi-level menu system that it might be used in. Note the single, declarative, easy to maintain design approach:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;quot;menu.h&amp;quot;\n#include &amp;lt;LiquidCrystal.h&amp;gt;\n\n// LCD Configuration\nLiquidCrystal lcd(8, 9, 4, 5, 6, 7);\n\n// Function to update the LCD display\nvoid updateDisplay(const char *line1, const char *line2) {\n    lcd.clear();\n    lcd.setCursor(0, 0);\n    lcd.print(line1);\n    lcd.setCursor(0, 1);\n    lcd.print(line2);\n}\n\n// Function to get user input from Serial Monitor\nchoice_t getUserInput(const char *prompt) {\n    Serial.print(prompt);\n    while (!Serial.available()) {\n        // Wait for input\n    }\n\n    char inputChar = Serial.read();\n    switch (inputChar) {\n        case &amp;#39;U&amp;#39;: return Up;\n        case &amp;#39;D&amp;#39;: return Down;\n        case &amp;#39;S&amp;#39;: return Select;\n        case &amp;#39;C&amp;#39;: return Cancel;\n        default: return Invalid;\n    }\n}\n\n// Declare the entire menu structure in place\nstatic menu_t printerMenu(\n    &amp;quot;3D Printer Menu&amp;quot;,\n    menu_t(&amp;quot;Print&amp;quot;,\n        menu_t(&amp;quot;Select File&amp;quot;,\n            menu_t(&amp;quot;File 1&amp;quot;, []() { Serial.println(&amp;quot;Printing File 1...&amp;quot;); }),\n            menu_t(&amp;quot;File 2&amp;quot;, []() { Serial.println(&amp;quot;Printing File 2...&amp;quot;); })\n        ),\n        menu_t(&amp;quot;Print Settings&amp;quot;,\n            menu_t(&amp;quot;Layer Height&amp;quot;, []() { Serial.println(&amp;quot;Adjusting Layer Height...&amp;quot;); }),\n            menu_t(&amp;quot;Temperature&amp;quot;, []() { Serial.println(&amp;quot;Adjusting Temperature...&amp;quot;); })\n        )\n    ),\n    menu_t(&amp;quot;Maintenance&amp;quot;,\n        menu_t(&amp;quot;Calibration&amp;quot;,\n            menu_t(&amp;quot;Bed Leveling&amp;quot;, []() { Serial.println(&amp;quot;Performing Bed Leveling...&amp;quot;); }),\n            menu_t(&amp;quot;Nozzle Alignment&amp;quot;, []() { Serial.println(&amp;quot;Aligning Nozzle...&amp;quot;); })\n        ),\n        menu_t(&amp;quot;Clean Nozzle&amp;quot;, []() { Serial.println(&amp;quot;Cleaning Nozzle...&amp;quot;); })\n    ),\n    menu_t(&amp;quot;Utilities&amp;quot;,\n        menu_t(&amp;quot;Firmware Update&amp;quot;, []() { Serial.println(&amp;quot;Updating Firmware...&amp;quot;); }),\n        menu_t(&amp;quot;Power Off&amp;quot;, []() { Serial.println(&amp;quot;Powering Off...&amp;quot;); })\n    )\n);\n\nvoid setup() {\n    Serial.begin(115200);\n    lcd.begin(16, 2);\n}\n\nvoid loop() {\n    // Running the printer menu in the loop\n    printerMenu.run(getUserInput, updateDisplay).exec();\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&amp;#x200B;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": null,
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": true,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "preview": {
    "images": [
      {
        "source": {
          "url": "https://external-preview.redd.it/P8lS0kk6BFe2IEo6TxCZd1LVwksc34IkzGTVx_SCc8w.jpg?auto=webp&amp;s=b9f5c4e4867fbffb2c1ff45dd70aa338d1e3f40c",
          "width": 150,
          "height": 150
        },
        "resolutions": [
          {
            "url": "https://external-preview.redd.it/P8lS0kk6BFe2IEo6TxCZd1LVwksc34IkzGTVx_SCc8w.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=3d74dbe4f1d67cc8b587db9aa01762f26e269bcf",
            "width": 108,
            "height": 108
          }
        ],
        "variants": {},
        "id": "OgFzGCIRw1ZxjMOSkfV1OiH-_nQiZl8rzSonmOAuhGs"
      }
    ],
    "enabled": false
  },
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "10e54cb2-a03e-11ee-82f2-8255c429eabf",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":snoo_facepalm:",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_6as6rv",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#6767f1",
  "id": "196e7o6",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 0,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": "dark",
  "permalink": "/r/ripred/comments/196e7o6/the_ultimate_lightweight_embedded_menu_system/",
  "stickied": false,
  "url": "https://www.reddit.com/r/ripred/comments/196e7o6/the_ultimate_lightweight_embedded_menu_system/",
  "subreddit_subscribers": 43,
  "created_utc": 1705233060.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}