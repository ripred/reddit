{
  "approved_at_utc": null,
  "subreddit": "arduino",
  "selftext": "# The Arduino Bang Library\n\n[The Bang Arduino library](https://github.com/ripred/Bang) enables an Arduino (or any microcontroller with a serial/USB interface) to execute commands on a host PC (Windows, Mac, or Linux) as if the PC were a service or co-processor. It works by having the Arduino send specially-formatted commands (prefixed with `!`) over serial to a **Python agent** running on the host. The agent receives these commands and executes them on the host\u2019s command-line, then returns any output back to the Arduino. In essence, **anything you can do in a terminal on the host can be triggered by the Arduino, with results sent back for the Arduino to use**. This vastly extends the Arduino\u2019s capabilities by leveraging the host\u2019s resources (computing power, storage, network, OS features). Full disclosure: I authored the library.\n\n**Arduino\u2019s Control via Python Agent:** The Arduino, through Bang, can **run arbitrary shell commands** on the host and read their outputs. This includes system commands, scripts, and even launching applications. The host can be made to **store and retrieve files** on behalf of the Arduino, acting as expanded storage or a data logger. The Arduino can play media on the host (music, text-to-speech), use the host\u2019s network connectivity to call web APIs, control hardware connected to the host (like sending keyboard strokes or using a webcam), and even perform system operations like shutting down or rebooting the host PC.\n\n**Notably**, the latest Bang features allow the Arduino to instruct the host to **compile and upload a new Arduino sketch**, effectively self-reprogramming the microcontroller using the host\u2019s installation of `arduino-cli`. This \u201cinfinite Arduino\u201d concept demonstrates how deep the integration can go \u2013 the Arduino can swap out its own firmware by commanding the host to act as a build server and programmer.\n\nAll of these new sketches are complete with example code for running the commands on Windows, macOS, or Linux. I haven't added them to the library's repository yet so these aren't included when you install the library through the IDE's Library Manager, or clone from github.\n\n# New Arduino Sketches Using Bang\n\n# 1. Alert Notification via Email/Webhook (Sensor Triggered)\n\n*Description:* This sketch turns your Arduino into a security or safety monitor that sends an **email or SMS notification** (through a web service) when a sensor is triggered. For example, a door sensor or motion sensor on the Arduino will cause the host PC to execute a web request (using `curl`) to a service like **IFTTT Webhooks**, which in turn can send an email or text message alert. This extends the Arduino\u2019s reach to instant notifications, without any network shield \u2013 the host handles the internet communication. (You would configure an IFTTT applet or similar with your own API key and event name; placeholders are in the code.)\n\n    /*\n     * AlertNotification.ino\n     * \n     * Uses the Bang library to send a web request via the host machine\n     * to trigger an email or SMS notification (e.g., via IFTTT webhooks) \n     * when a sensor or button is activated. The Arduino signals the host PC \n     * to execute a curl command to a web service, which can send an alert.\n     *\n     * Hardware:\n     * - Use a push button or digital sensor connected to pin 2 (active LOW).\n     *   Internal pull-up resistor is enabled, so wire one side of the button \n     *   to pin 2 and the other to ground.\n     * - (Optional) An LED connected to pin 13 will blink when an alert is sent.\n     * \n     * Prerequisites on host:\n     * - The host must have internet access and `curl` installed (available by default on Mac/Linux, and on Windows 10+ or via Git for Windows).\n     * - An IFTTT account with a Webhooks service set up (or any similar webhook URL for notifications).\n     * - Replace the IFTTT_KEY and EVENT_NAME with your own Webhooks key and event name.\n     *   Alternatively, adjust the curl command to any service or script that handles notifications.\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7    // SoftwareSerial RX (to host TX)\n    #define TX_PIN 8    // SoftwareSerial TX (to host RX)\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const char* IFTTT_KEY = \"REPLACE_WITH_YOUR_IFTTT_KEY\";     // &lt;-- Your IFTTT Webhooks key\n    const char* EVENT_NAME = \"REPLACE_WITH_YOUR_EVENT_NAME\";   // &lt;-- Your IFTTT event name\n    \n    const int SENSOR_PIN = 2;\n    const int LED_PIN = 13;\n    \n    bool alertSent = false;  // flag to prevent multiple triggers while button/sensor is held\n    \n    void setup() {\n      // Initialize serial communications\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(SENSOR_PIN, INPUT_PULLUP);  // using internal pull-up, so active low\n      pinMode(LED_PIN, OUTPUT);\n      digitalWrite(LED_PIN, LOW);\n      \n      // Wait a moment for Serial (if connected) and print a start message\n      delay(100);\n      Serial.println(F(\"=== Alert Notification Sketch ===\"));\n      Serial.println(F(\"Waiting for sensor trigger...\"));\n      Serial.println(F(\"Ensure Python agent is running. Will send webhook on trigger.\"));\n    }\n    \n    void loop() {\n      // Check sensor/button state\n      int sensorState = digitalRead(SENSOR_PIN);\n      if (sensorState == LOW &amp;&amp; !alertSent) {\n        // Sensor is triggered (button pressed)\n        alertSent = true;\n        Serial.println(F(\"Sensor triggered! Sending alert...\"));\n        digitalWrite(LED_PIN, HIGH);  // Turn on LED to indicate alert is being sent\n        \n        // Construct the curl command to trigger the IFTTT webhook\n        // The webhook URL is: \n        pcSerial.print(F(\"!curl -X POST \\\"https://maker.ifttt.com/trigger/\"));\n        pcSerial.print(EVENT_NAME);\n        pcSerial.print(F(\"/with/key/\"));\n        pcSerial.print(IFTTT_KEY);\n        pcSerial.println(F(\"?value1=Alert%20Triggered\\\"\"));\n        \n        Serial.println(F(\"Alert command sent to host.\"));\n      }\n      if (sensorState == HIGH &amp;&amp; alertSent) {\n        // Sensor released (button unpressed), reset for next trigger\n        alertSent = false;\n        Serial.println(F(\"Sensor reset. Ready for next alert.\"));\n        digitalWrite(LED_PIN, LOW);\n        // (Optionally keep LED on for a fixed time or until acknowledged)\n      }\n    \n      // Check for any response from the host (e.g., confirmation or errors from curl)\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() &gt; 0) {\n          // Print the host response to the Serial Monitor for debugging\n          Serial.println(output);\n        }\n      }\n    \n      // Small delay to debounce sensor and avoid flooding\n      delay(50);\n    }\n\n# 2. Network Connectivity Ping Monitor\n\n*Description:* This sketch uses the host to periodically **ping** an external server (here, Google\u2019s DNS at 8.8.8.8) to check for internet connectivity. The Arduino triggers a ping command on the host every 5 seconds and reads the result. It then indicates network status by toggling the Arduino\u2019s onboard LED: if the ping fails (no response), the LED turns **ON** as a warning; if the ping succeeds, the LED stays **OFF**. This effectively makes the Arduino a network connectivity monitor or heartbeating device. The example shows parsing command output (looking for specific substrings in the ping reply) to determine success or failure. (By default, the code uses the Windows `ping -n 1` syntax. For Unix-based systems, you\u2019d use `ping -c 1`. The comments indicate where to change this.)\n\n    /*\n     * PingMonitor.ino\n     *\n     * Periodically pings a remote server (e.g., Google DNS at 8.8.8.8 or google.com) using \n     * the host machine's ping command to check internet connectivity. \n     * The Arduino uses the Bang library to send ping commands and interprets the results \n     * to indicate network status by blinking the onboard LED.\n     *\n     * - The host PC executes the ping command and returns the output to Arduino.\n     * - If the ping is successful, the Arduino turns OFF the onboard LED.\n     * - If the ping fails (no response), the Arduino turns ON the LED as an alert.\n     *\n     * Hardware:\n     * - Onboard LED (pin 13 on Arduino Uno) used to show network status (ON = no connectivity).\n     * \n     * Note: By default, this sketch uses the Windows ping syntax.\n     *       On Windows, ping is invoked with \"-n 1\" for a single ping.\n     *       If using Mac/Linux, change the ping command to use \"-c 1\" instead of \"-n 1\".\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const unsigned long PING_INTERVAL = 5000;  // ping every 5 seconds\n    unsigned long lastPingTime = 0;\n    bool pingSuccess = false;  // track result of last ping\n    \n    const int LED_PIN = 13;\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(LED_PIN, OUTPUT);\n      digitalWrite(LED_PIN, LOW);  // start with LED off (assuming network OK initially)\n      \n      Serial.println(F(\"=== Network Ping Monitor Sketch ===\"));\n      Serial.println(F(\"Pinging host every 5 seconds. LED ON = Ping failed, LED OFF = Ping successful.\"));\n      Serial.println(F(\"Ensure Python agent is running. Using Windows ping syntax by default.\"));\n    }\n    \n    void loop() {\n      // Periodically send ping command\n      if (millis() - lastPingTime &gt;= PING_INTERVAL) {\n        lastPingTime = millis();\n        pingSuccess = false;  // reset success flag for this round\n        \n        Serial.println(F(\"Sending ping...\"));\n        // Send a single ping; use appropriate flag for your OS ('-n 1' for Windows, '-c 1' for Unix)\n        pcSerial.println(F(\"!ping -n 1 8.8.8.8\"));  // ping Google's DNS (8.8.8.8)\n        // If on Mac/Linux, you would use: pcSerial.println(F(\"!ping -c 1 8.8.8.8\"));\n      }\n      \n      // Check for ping response output from host\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() == 0) {\n          continue;\n        }\n        // Echo the ping output to Serial monitor for debugging\n        Serial.println(output);\n        // Look for keywords indicating success or failure\n        if (output.indexOf(\"Reply from\") &gt;= 0 || output.indexOf(\"bytes from\") &gt;= 0) {\n          // Indicates at least one successful ping reply (Windows or Unix)\n          pingSuccess = true;\n        }\n        // We could also check for \"Request timed out\" or \"unreachable\" for failures, \n        // but pingSuccess will remain false if no success keywords are found.\n      }\n      \n      // Update LED based on ping result\n      if (pingSuccess) {\n        // Ping succeeded, ensure LED is off\n        digitalWrite(LED_PIN, LOW);\n      } else {\n        // Ping failed (no reply), turn LED on\n        digitalWrite(LED_PIN, HIGH);\n      }\n      \n      // (Optional) add a small delay to avoid busy-waiting, but not necessary since using millis timing\n      delay(10);\n    }\n\n# 3. Web Browser Launcher (Physical Button to Open URL)\n\n*Description:* This sketch makes a push-button on the Arduino act as a trigger to **open a website** on the host\u2019s default web browser. It\u2019s like a physical shortcut key \u2013 press the button and the host will launch a specified URL. In this example, pressing the button will open the Arduino official website. On Windows this uses the `start` command, on macOS the `open` command, and on Linux `xdg-open` (the code defaults to Windows, but alternatives are commented). This demonstrates the Arduino controlling desktop applications and GUI actions via command-line \u2013 no HID emulation needed, the host does the heavy lifting.\n\n    /*\n     * WebLauncher.ino\n     *\n     * Opens a website on the host computer's default web browser when a button on the Arduino is pressed.\n     * The Arduino uses the Bang library to send a command to the host to launch the URL.\n     *\n     * Hardware:\n     * - A push button connected to pin 2 (and ground) to trigger the action. \n     *   Pin 2 uses the internal pull-up resistor, so the button should connect pin 2 to GND when pressed.\n     *\n     * Host commands:\n     * - Windows: uses \"start\" to open the URL.\n     * - Mac: use \"open\" to open the URL.\n     * - Linux: use \"xdg-open\" to open the URL.\n     * (This example defaults to Windows; adjust the command for other OS as needed.)\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const int BUTTON_PIN = 2;\n    bool launchTriggered = false;  // to track button state\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(BUTTON_PIN, INPUT_PULLUP);\n      \n      Serial.println(F(\"=== Web Launcher Sketch ===\"));\n      Serial.println(F(\"Press the button to open a website on the host's browser.\"));\n      Serial.println(F(\"Ensure Python agent is running. Default command is for Windows (start).\"));\n    }\n    \n    void loop() {\n      int buttonState = digitalRead(BUTTON_PIN);\n      if (buttonState == LOW &amp;&amp; !launchTriggered) {\n        // Button pressed (active low) and not already triggered\n        launchTriggered = true;\n        Serial.println(F(\"Button pressed! Launching website...\"));\n        // Send command to open the URL on host\n        pcSerial.println(F(\"!start https://www.arduino.cc\"));\n        // For Mac: pcSerial.println(F(\"!open https://www.arduino.cc\"));\n        // For Linux: pcSerial.println(F(\"!xdg-open https://www.arduino.cc\"));\n      } \n      else if (buttonState == HIGH &amp;&amp; launchTriggered) {\n        // Button released, reset trigger\n        launchTriggered = false;\n        // Debounce delay (optional)\n        delay(50);\n      }\n      \n      // Print any output from the host (if any). Usually, opening a URL may not produce console output.\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() &gt; 0) {\n          Serial.println(output);\n        }\n      }\n    }\n\n# 4. CPU Usage Monitor and Alarm\n\n*Description:* This sketch offloads the task of checking CPU load to the host and uses the result to signal high usage on the Arduino. Every 2 seconds, the Arduino asks the host for the current CPU utilization (as a percentage). On Windows, it uses the `WMIC` command to get the CPU load; the code could be adapted for Mac/Linux using appropriate commands. The Arduino parses the returned percentage and prints it. If the CPU usage exceeds a defined threshold (80% in this example), the Arduino\u2019s LED will turn **ON** to indicate a high-load condition; otherwise it remains **OFF**. This can be used as a tiny hardware CPU monitor or to trigger further actions when the host is under heavy load.\n\n    /*\n     * CpuMonitor.ino\n     *\n     * Retrieves the host machine's CPU usage (in percent) and indicates high usage via an LED.\n     * The Arduino requests the CPU load from the host using a shell command, and parses the result.\n     *\n     * This example is tailored for Windows using the WMIC command to get CPU load.\n     * For other OS:\n     *   - On Linux, you might use `grep 'cpu ' /proc/stat` or `top -bn1` and parse the output.\n     *   - On Mac, you could use `ps -A -o %cpu` and calculate an average, or other system diagnostics.\n     *\n     * Hardware:\n     * - An LED on pin 13 indicates high CPU usage (ON if CPU &gt;= 80%, OFF if below).\n     *   (Using the built-in LED on Arduino Uno).\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const unsigned long CHECK_INTERVAL = 2000;  // check every 2 seconds\n    unsigned long lastCheckTime = 0;\n    const int LED_PIN = 13;\n    const int HIGH_USAGE_THRESHOLD = 80; // percent CPU usage to consider \"high\"\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(LED_PIN, OUTPUT);\n      digitalWrite(LED_PIN, LOW);\n      \n      Serial.println(F(\"=== CPU Usage Monitor Sketch ===\"));\n      Serial.println(F(\"Checking CPU load every 2 seconds. LED on if CPU &gt;= 80%.\"));\n      Serial.println(F(\"Ensure Python agent is running. Using WMIC on Windows for CPU load.\"));\n    }\n    \n    void loop() {\n      if (millis() - lastCheckTime &gt;= CHECK_INTERVAL) {\n        lastCheckTime = millis();\n        Serial.println(F(\"Querying CPU load...\"));\n        // Query CPU load percentage via Windows WMIC \n        pcSerial.println(F(\"!wmic cpu get LoadPercentage /value\"));\n        // (For Mac/Linux, replace with an appropriate command)\n      }\n    \n      // Read and parse any response from the host\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() == 0) continue;\n        Serial.println(output); // debug: print raw output\n        \n        int eqPos = output.indexOf('=');\n        if (eqPos &gt;= 0) {\n          String valueStr = output.substring(eqPos + 1);\n          valueStr.trim();\n          int cpuPercent = valueStr.toInt();\n          Serial.print(F(\"CPU Usage: \"));\n          Serial.print(cpuPercent);\n          Serial.println(F(\"%\"));\n          // Indicate high CPU usage on LED\n          if (cpuPercent &gt;= HIGH_USAGE_THRESHOLD) {\n            digitalWrite(LED_PIN, HIGH);  // turn LED on if usage is high\n          } else {\n            digitalWrite(LED_PIN, LOW);   // turn LED off if usage is normal\n          }\n        }\n      }\n    \n      delay(50); // small delay to avoid busy loop\n    }\n\n# 5. Clipboard Sharing (Copy/Paste Integration)\n\n*Description:* This sketch integrates the Arduino with the host\u2019s **clipboard** (copy-paste buffer). It sets up two buttons: one to **retrieve** whatever text is currently on the host\u2019s clipboard and send it to the Arduino, and another to **set** the host clipboard to a predefined text. Imagine using this with an LCD display: you could press a button to have the Arduino display whatever text you copied on your PC, or press another to inject a prepared text into the PC\u2019s clipboard (perhaps a canned message or sensor reading that you want to paste into a document). This example uses PowerShell commands on Windows (`Get-Clipboard` and `Set-Clipboard`); it notes alternatives for Mac (`pbpaste`/`pbcopy`) and Linux (`xclip`). It shows bi-directional use of `!command`: getting data from host to Arduino, and sending data from Arduino to host, both via the clipboard.\n\n    /*\n     * ClipboardBridge.ino\n     *\n     * Demonstrates two-way clipboard integration:\n     * - Read (retrieve) the host's clipboard content and send it to the Arduino.\n     * - Write (set) the host's clipboard content from the Arduino.\n     *\n     * The Arduino uses the Bang library to send the appropriate commands to the host:\n     * - On Windows: uses PowerShell Get-Clipboard and Set-Clipboard.\n     * - On Mac: use `pbpaste` to get and `pbcopy` to set (via echo piped).\n     * - On Linux: use `xclip` or `xsel` (if installed) to get/set the clipboard.\n     *\n     * Hardware:\n     * - Button on pin 2: When pressed, fetches the host's clipboard text.\n     * - Button on pin 3: When pressed, copies a preset message from Arduino to the host clipboard.\n     * Both buttons use internal pull-up resistors (active LOW when pressed).\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const int GET_BUTTON_PIN = 2;\n    const int SET_BUTTON_PIN = 3;\n    bool getPressed = false;\n    bool setPressed = false;\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(GET_BUTTON_PIN, INPUT_PULLUP);\n      pinMode(SET_BUTTON_PIN, INPUT_PULLUP);\n      \n      Serial.println(F(\"=== Clipboard Bridge Sketch ===\"));\n      Serial.println(F(\"Btn2 (pin 2) -&gt; Read host clipboard, Btn3 (pin 3) -&gt; Set host clipboard.\"));\n      Serial.println(F(\"Ensure Python agent is running. Using PowerShell commands on Windows.\"));\n    }\n    \n    void loop() {\n      // Read buttons (active low)\n      int getBtnState = digitalRead(GET_BUTTON_PIN);\n      int setBtnState = digitalRead(SET_BUTTON_PIN);\n      \n      if (getBtnState == LOW &amp;&amp; !getPressed) {\n        // Fetch clipboard button pressed\n        getPressed = true;\n        Serial.println(F(\"Fetching clipboard content from host...\"));\n        // Windows: Get-Clipboard\n        pcSerial.println(F(\"!powershell -Command \\\"Get-Clipboard\\\"\"));\n        // Mac alternative: pcSerial.println(F(\"!pbpaste\"));\n        // Linux alternative: pcSerial.println(F(\"!xclip -o -selection clipboard\"));\n      } else if (getBtnState == HIGH &amp;&amp; getPressed) {\n        getPressed = false;\n        delay(50); // debounce\n      }\n      \n      if (setBtnState == LOW &amp;&amp; !setPressed) {\n        // Set clipboard button pressed\n        setPressed = true;\n        Serial.println(F(\"Setting host clipboard from Arduino...\"));\n        // Windows: Set-Clipboard with a message\n        pcSerial.println(\"!powershell -Command \\\"Set-Clipboard -Value 'Hello from Arduino'\\\"\");\n        // Mac alternative: pcSerial.println(F(\"!echo 'Hello from Arduino' | pbcopy\"));\n        // Linux alternative: pcSerial.println(F(\"!echo 'Hello from Arduino' | xclip -selection clipboard\"));\n      } else if (setBtnState == HIGH &amp;&amp; setPressed) {\n        setPressed = false;\n        delay(50); // debounce\n      }\n      \n      // Read any response from host and display\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        // Note: Clipboard content could be multi-line; this will print it as it comes.\n        if (output.length() &gt; 0) {\n          Serial.print(F(\"[Host clipboard output] \"));\n          Serial.println(output);\n        }\n      }\n    }\n\n# 6. Automated Keystrokes (Typing a Message on Host)\n\n*Description:* This sketch enables the Arduino to **type a text string on the host** as if it were typed on the keyboard. When a button is pressed, the Arduino commands the host to simulate keystrokes for a specific message (here, \u201cHello from Arduino\u201d). On Windows, it uses PowerShell to create a WScript Shell COM object and send keystrokes; on a Mac, an AppleScript `osascript` command could be used (example in comments). This is useful for automation or accessibility: for instance, a single hardware button could enter a password or often-used phrase on the PC, or perform a series of shortcut keys. (It\u2019s akin to the Arduino acting like a USB HID keyboard, but here we do it entirely through software on the host side.)\n\n    /*\n     * KeyboardAutomation.ino\n     *\n     * Simulates keyboard input on the host machine from the Arduino.\n     * When the button is pressed, the Arduino instructs the host to send keystrokes (typing a text string).\n     *\n     * Note: For the keystrokes to be visible, an application window or text field on the host must be focused.\n     *\n     * This example uses:\n     * - Windows: PowerShell with a WScript Shell COM object to send keys.\n     * - Mac: AppleScript via `osascript` to send keystrokes.\n     * - Linux: Requires a tool like `xdotool` to simulate key presses.\n     *\n     * Hardware:\n     * - Push button on pin 2 (to ground, using internal pull-up).\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const int BUTTON_PIN = 2;\n    bool keyPressed = false;\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(BUTTON_PIN, INPUT_PULLUP);\n      \n      Serial.println(F(\"=== Keyboard Automation Sketch ===\"));\n      Serial.println(F(\"Press the button to type a message on the host machine.\"));\n      Serial.println(F(\"Ensure Python agent is running. Default command is for Windows PowerShell.\"));\n    }\n    \n    void loop() {\n      int btnState = digitalRead(BUTTON_PIN);\n      if (btnState == LOW &amp;&amp; !keyPressed) {\n        keyPressed = true;\n        Serial.println(F(\"Button pressed! Sending keystrokes...\"));\n        // Windows: use PowerShell to send keystrokes via \n        pcSerial.println(\"!powershell -Command \\\"$wshell = New-Object -ComObject ; $wshell.SendKeys('Hello from Arduino')\\\"\");\n        // Mac alternative: pcSerial.println(F(\"!osascript -e 'tell application \\\"System Events\\\" to keystroke \\\"Hello from Arduino\\\"'\"));\n        // Linux alternative (with xdotool installed): pcSerial.println(F(\"!xdotool type 'Hello from Arduino'\"));\n      } else if (btnState == HIGH &amp;&amp; keyPressed) {\n        keyPressed = false;\n        delay(50);\n      }\n    \n      // Display any output or error from host (if any)\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() &gt; 0) {\n          Serial.println(output);\n        }\n      }\n    }WScript.Shellwscript.shell\n\n# 7. Host PC Lock (Security Lock Button)\n\n*Description:* This sketch provides a physical \u201clock computer\u201d button. When pressed, the Arduino will command the host to **lock the current user session** \u2013 equivalent to pressing Win+L on Windows or Ctrl+Command+Q on a Mac. This is handy as a security measure (for example, a wireless remote to lock your PC when you walk away). The example uses the Windows `rundll32.exe user32.dll,LockWorkStation` command to immediately lock the workstation. For other OS, appropriate commands are given in comments (e.g., an AppleScript to invoke the screen saver or lock command on Mac, or `loginctl lock-session` on Linux). After sending the command, the host will lock \u2013 the Arduino won\u2019t get a response (and you\u2019ll need to log back in to resume, as normal). This shows Arduino controlling OS security features.\n\n    /*\n     * HostLock.ino\n     *\n     * Allows the Arduino to lock the host machine (useful for security, e.g., a panic button that locks your PC).\n     * When the button is pressed, the host OS will be instructed to lock the current user session.\n     *\n     * Host commands:\n     * - Windows: uses rundll32 to lock the workstation.\n     * - Mac: could use AppleScript to simulate the Ctrl+Cmd+Q shortcut (lock screen).\n     * - Linux: could use `loginctl lock-session` or `xdg-screensaver lock`.\n     *\n     * Hardware:\n     * - Push button on pin 2 (to ground, with internal pull-up).\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const int BUTTON_PIN = 2;\n    bool lockTriggered = false;\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(BUTTON_PIN, INPUT_PULLUP);\n      \n      Serial.println(F(\"=== Host Lock Sketch ===\"));\n      Serial.println(F(\"Press the button to lock the host computer.\"));\n      Serial.println(F(\"Ensure Python agent is running. Default uses Windows lock command.\"));\n    }\n    \n    void loop() {\n      int btnState = digitalRead(BUTTON_PIN);\n      if (btnState == LOW &amp;&amp; !lockTriggered) {\n        lockTriggered = true;\n        Serial.println(F(\"Button pressed! Locking host...\"));\n        // Windows: lock workstation\n        pcSerial.println(F(\"!rundll32.exe user32.dll,LockWorkStation\"));\n        // Mac alternative: pcSerial.println(F(\"!osascript -e 'tell application \\\"System Events\\\" to keystroke \\\"q\\\" using {control down, command down}'\"));\n        // Linux alternative: pcSerial.println(F(\"!loginctl lock-session\"));\n        // (Note: Locking will occur immediately; ensure you have access to unlock!)\n      } else if (btnState == HIGH &amp;&amp; lockTriggered) {\n        lockTriggered = false;\n        delay(50);\n      }\n      \n      // There may not be any output from the lock command, but handle any just in case\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() &gt; 0) {\n          Serial.println(output);\n        }\n      }\n    }\n\n# 8. Laptop Battery Level Monitor\n\n*Description:* This sketch checks the host\u2019s battery level (for laptops) and alerts if the battery is low. The Arduino periodically asks the host for the current battery charge percentage. On Windows, it uses a WMI query via `wmic` to get `EstimatedChargeRemaining`. If the battery percentage is below a defined threshold (20% here), the Arduino will blink its LED rapidly to warn of low battery; it also prints the percentage and a low-battery warning to the serial output. If no battery is present (desktop PC), the host will report no instance and the sketch will simply indicate \u201cno battery\u201d. This example is useful as a custom battery alarm or to trigger power-saving measures via Arduino outputs when the host battery is low.\n\n    /*\n     * BatteryMonitor.ino\n     *\n     * Monitors the host machine's battery level and alerts when it falls below a certain threshold.\n     * The Arduino queries the host for battery charge percentage and turns on/blinks an LED if the battery is low.\n     *\n     * This example uses Windows WMI via `wmic` to get the battery level.\n     * On a desktop with no battery, the query will indicate no battery available.\n     * For Mac/Linux, appropriate commands (e.g., `pmset -g batt` on Mac or `acpi -b` on Linux with ACPI installed) could be used instead.\n     *\n     * Hardware:\n     * - LED on pin 13 used to indicate low battery (blinks when battery is below threshold).\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const unsigned long CHECK_INTERVAL = 10000; // check every 10 seconds\n    unsigned long lastCheck = 0;\n    const int LED_PIN = 13;\n    const int LOW_BATT_THRESHOLD = 20; // 20% battery remaining threshold\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(LED_PIN, OUTPUT);\n      digitalWrite(LED_PIN, LOW);\n      \n      Serial.println(F(\"=== Battery Monitor Sketch ===\"));\n      Serial.println(F(\"Checking battery level every 10 seconds. LED will blink if battery is low (&lt;20%).\"));\n      Serial.println(F(\"Ensure Python agent is running. Using WMIC on Windows to get battery level.\"));\n    }\n    \n    void loop() {\n      if (millis() - lastCheck &gt;= CHECK_INTERVAL) {\n        lastCheck = millis();\n        Serial.println(F(\"Querying battery level...\"));\n        pcSerial.println(F(\"!wmic path Win32_Battery get EstimatedChargeRemaining /value\"));\n      }\n      \n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() == 0) continue;\n        Serial.println(output); // debug output from host\n        \n        if (output.indexOf(\"No Instance\") &gt;= 0) {\n          Serial.println(F(\"No battery detected on host.\"));\n          // If no battery, turn off LED (no alert)\n          digitalWrite(LED_PIN, LOW);\n        }\n        int eqPos = output.indexOf('=');\n        if (eqPos &gt;= 0) {\n          String percStr = output.substring(eqPos + 1);\n          percStr.trim();\n          int batteryPercent = percStr.toInt();\n          Serial.print(F(\"Battery: \"));\n          Serial.print(batteryPercent);\n          Serial.println(F(\"%\"));\n          if (batteryPercent &gt; 0 &amp;&amp; batteryPercent &lt;= LOW_BATT_THRESHOLD) {\n            // Battery is low, blink LED a few times as warning\n            Serial.println(F(\"Battery low! Blinking LED...\"));\n            for (int i = 0; i &lt; 3; ++i) {\n              digitalWrite(LED_PIN, HIGH);\n              delay(150);\n              digitalWrite(LED_PIN, LOW);\n              delay(150);\n            }\n          } else {\n            // Battery okay, ensure LED is off\n            digitalWrite(LED_PIN, LOW);\n          }\n        }\n      }\n      \n      delay(50);\n    }\n\n# 9. Random Joke Fetcher (Internet API Example)\n\n*Description:* This playful sketch fetches a **random joke from an online API** and prints it, demonstrating how an Arduino can leverage web APIs through the host. Pressing the button makes the Arduino tell the host to `curl` a joke from the internet (using the free [icanhazdadjoke.com](http://icanhazdadjoke.com) API, which returns a random joke in plain text). The host\u2019s response (the joke text) is then read and displayed by the Arduino (e.g., you could attach an LCD or just read it in the Serial Monitor). This is similar to the weather example in concept but uses a different API and returns a single line of text. It shows how easily one can integrate internet services for fun or informative data.\n\n    /*\n     * JokeFetcher.ino\n     *\n     * Fetches a random joke from an online API and displays it via the Arduino.\n     * When the button is pressed, the Arduino asks the host to retrieve a joke from the internet.\n     *\n     * This example uses the  API which returns a random joke in plain text (no API key required).\n     * It uses curl to fetch the joke.\n     *\n     * Hardware:\n     * - Push button on pin 2 (to ground, with internal pull-up) to trigger fetching a new joke.\n     * - (Optional) You can connect an LCD or serial monitor to display the joke text.\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const int BUTTON_PIN = 2;\n    bool fetchTriggered = false;\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(BUTTON_PIN, INPUT_PULLUP);\n      \n      Serial.println(F(\"=== Random Joke Fetcher Sketch ===\"));\n      Serial.println(F(\"Press the button to fetch a random joke from the internet.\"));\n      Serial.println(F(\"Ensure Python agent is running and host has internet connectivity.\"));\n    }\n    \n    void loop() {\n      int btnState = digitalRead(BUTTON_PIN);\n      if (btnState == LOW &amp;&amp; !fetchTriggered) {\n        fetchTriggered = true;\n        Serial.println(F(\"Button pressed! Fetching a joke...\"));\n        // Use curl to get a random joke in plain text\n        pcSerial.println(F(\"!curl -s -H \\\"Accept: text/plain\\\" https://icanhazdadjoke.com/\"));\n      } else if (btnState == HIGH &amp;&amp; fetchTriggered) {\n        fetchTriggered = false;\n        delay(50);\n      }\n      \n      // Read the joke or any output from host\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        if (output.length() &gt; 0) {\n          // Print the joke to Serial Monitor\n          Serial.print(F(\"Joke: \"));\n          Serial.println(output);\n        }\n      }\n    }icanhazdadjoke.com\n\n# 10. CD/DVD Tray Ejector (Optical Drive Control)\n\n*Description:* This final sketch lets the Arduino open (eject) and potentially close the host computer\u2019s CD/DVD drive tray. With a press of the button, the Arduino issues a command to the host to toggle the optical drive tray. On Windows, it uses a Windows Media Player COM interface via PowerShell to control the first CD-ROM drive \u2013 this will **open the tray** if it\u2019s closed, or **close it if it\u2019s open** (acting like the eject button on the drive). On Mac, a `drutil eject` command could be used (for Macs with optical drives), and on Linux the `eject` command (with `-t` to close). This is a fun hardware control example, effectively giving the Arduino a way to press the PC\u2019s eject button via software.\n\n    /*\n     * CDEject.ino\n     *\n     * Controls the host computer's CD/DVD drive tray (optical drive) via the Arduino.\n     * Pressing the button will eject (open) the drive tray. Pressing it again may close the tray (depending on host command support).\n     *\n     * Host commands:\n     * - Windows: uses Windows Media Player COM interface via PowerShell to toggle the CD tray.\n     * - Mac: use `drutil eject` to open and `drutil tray close` to close (for built-in DVD drive or external Apple SuperDrive).\n     * - Linux: use `eject` to open and `eject -t` to close (if appropriate privileges).\n     *\n     * Hardware:\n     * - Push button on pin 2 (to ground, with internal pull-up).\n     * - (Requires the host to have a CD/DVD drive capable of opening/closing.)\n     */\n    #include &lt;SoftwareSerial.h&gt;\n    \n    #define RX_PIN 7\n    #define TX_PIN 8\n    SoftwareSerial pcSerial(RX_PIN, TX_PIN);\n    \n    const int BUTTON_PIN = 2;\n    bool ejectTriggered = false;\n    \n    void setup() {\n      Serial.begin(115200);\n      pcSerial.begin(38400);\n      pinMode(BUTTON_PIN, INPUT_PULLUP);\n      \n      Serial.println(F(\"=== CD Tray Ejector Sketch ===\"));\n      Serial.println(F(\"Press the button to toggle the CD/DVD drive tray (open/close) on the host.\"));\n      Serial.println(F(\"Ensure Python agent is running. Default command is for Windows via WMP COM interface.\"));\n    }\n    \n    void loop() {\n      int btnState = digitalRead(BUTTON_PIN);\n      if (btnState == LOW &amp;&amp; !ejectTriggered) {\n        ejectTriggered = true;\n        Serial.println(F(\"Button pressed! Toggling CD tray...\"));\n        // Windows: Toggle CD tray via Windows Media Player COM (opens if closed, closes if open)\n        pcSerial.println(F(\"!powershell -Command \\\"(New-Object -ComObject WMPlayer.OCX.7).cdromCollection.Item(0).Eject()\\\"\"));\n        // Mac alternative: pcSerial.println(F(\"!drutil eject\"));\n        // Linux alternative: pcSerial.println(F(\"!eject\"));\n      } else if (btnState == HIGH &amp;&amp; ejectTriggered) {\n        ejectTriggered = false;\n        delay(100);\n      }\n      \n      // Read any output from host (likely none on success, maybe error if no drive)\n      while (pcSerial.available() &gt; 0) {\n        String output = pcSerial.readString();\n        output.trim();\n        if (output.length() &gt; 0) {\n          Serial.println(output);\n        }\n      }\n    }\n\nAll the Best!\n\n`ripred`",
  "author_fullname": "t2_adfkq",
  "saved": false,
  "mod_reason_title": null,
  "gilded": 0,
  "clicked": false,
  "title": "New Arduino Bang Library Examples",
  "link_flair_richtext": [
    {
      "e": "text",
      "t": "Look what I made!"
    }
  ],
  "subreddit_name_prefixed": "r/arduino",
  "hidden": false,
  "pwls": 6,
  "link_flair_css_class": "",
  "downs": 0,
  "thumbnail_height": null,
  "top_awarded_type": null,
  "hide_score": false,
  "name": "t3_1ijj32t",
  "quarantine": false,
  "link_flair_text_color": null,
  "upvote_ratio": 0.79,
  "author_flair_background_color": "#00a6a5",
  "subreddit_type": "public",
  "ups": 8,
  "total_awards_received": 0,
  "media_embed": {},
  "thumbnail_width": null,
  "author_flair_template_id": "5cb3c302-0ef5-11ed-b9fd-aab9a872a9c2",
  "is_original_content": false,
  "user_reports": [],
  "secure_media": null,
  "is_reddit_media_domain": false,
  "is_meta": false,
  "category": null,
  "secure_media_embed": {},
  "link_flair_text": "Look what I made!",
  "can_mod_post": false,
  "score": 8,
  "approved_by": null,
  "is_created_from_ads_ui": false,
  "author_premium": false,
  "thumbnail": "self",
  "edited": 1738901274.0,
  "author_flair_css_class": null,
  "author_flair_richtext": [
    {
      "a": ":400K:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/apsbyvbwmfe91_t5_2qknj/400K"
    },
    {
      "a": ":Arduino_500k:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/o5qzzwwkvk5a1_t5_2qknj/Arduino_500k"
    },
    {
      "a": ":600K:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/z23hxjk4hpeb1_t5_2qknj/600K"
    },
    {
      "a": ":640K:",
      "e": "emoji",
      "u": "https://emoji.redditmedia.com/g9r24xjaydqc1_t5_2qknj/640K"
    },
    {
      "e": "text",
      "t": " My other dev board is a Porsche"
    }
  ],
  "gildings": {},
  "post_hint": "self",
  "content_categories": null,
  "is_self": true,
  "mod_note": null,
  "created": 1738891011.0,
  "link_flair_type": "richtext",
  "wls": 6,
  "removed_by_category": null,
  "banned_by": null,
  "author_flair_type": "richtext",
  "domain": "self.arduino",
  "allow_live_comments": false,
  "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;h1&gt;The Arduino Bang Library&lt;/h1&gt;\n\n&lt;p&gt;&lt;a href=\"https://github.com/ripred/Bang\"&gt;The Bang Arduino library&lt;/a&gt; enables an Arduino (or any microcontroller with a serial/USB interface) to execute commands on a host PC (Windows, Mac, or Linux) as if the PC were a service or co-processor. It works by having the Arduino send specially-formatted commands (prefixed with &lt;code&gt;!&lt;/code&gt;) over serial to a &lt;strong&gt;Python agent&lt;/strong&gt; running on the host. The agent receives these commands and executes them on the host\u2019s command-line, then returns any output back to the Arduino. In essence, &lt;strong&gt;anything you can do in a terminal on the host can be triggered by the Arduino, with results sent back for the Arduino to use&lt;/strong&gt;. This vastly extends the Arduino\u2019s capabilities by leveraging the host\u2019s resources (computing power, storage, network, OS features). Full disclosure: I authored the library.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Arduino\u2019s Control via Python Agent:&lt;/strong&gt; The Arduino, through Bang, can &lt;strong&gt;run arbitrary shell commands&lt;/strong&gt; on the host and read their outputs. This includes system commands, scripts, and even launching applications. The host can be made to &lt;strong&gt;store and retrieve files&lt;/strong&gt; on behalf of the Arduino, acting as expanded storage or a data logger. The Arduino can play media on the host (music, text-to-speech), use the host\u2019s network connectivity to call web APIs, control hardware connected to the host (like sending keyboard strokes or using a webcam), and even perform system operations like shutting down or rebooting the host PC.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Notably&lt;/strong&gt;, the latest Bang features allow the Arduino to instruct the host to &lt;strong&gt;compile and upload a new Arduino sketch&lt;/strong&gt;, effectively self-reprogramming the microcontroller using the host\u2019s installation of &lt;code&gt;arduino-cli&lt;/code&gt;. This \u201cinfinite Arduino\u201d concept demonstrates how deep the integration can go \u2013 the Arduino can swap out its own firmware by commanding the host to act as a build server and programmer.&lt;/p&gt;\n\n&lt;p&gt;All of these new sketches are complete with example code for running the commands on Windows, macOS, or Linux. I haven&amp;#39;t added them to the library&amp;#39;s repository yet so these aren&amp;#39;t included when you install the library through the IDE&amp;#39;s Library Manager, or clone from github.&lt;/p&gt;\n\n&lt;h1&gt;New Arduino Sketches Using Bang&lt;/h1&gt;\n\n&lt;h1&gt;1. Alert Notification via Email/Webhook (Sensor Triggered)&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch turns your Arduino into a security or safety monitor that sends an &lt;strong&gt;email or SMS notification&lt;/strong&gt; (through a web service) when a sensor is triggered. For example, a door sensor or motion sensor on the Arduino will cause the host PC to execute a web request (using &lt;code&gt;curl&lt;/code&gt;) to a service like &lt;strong&gt;IFTTT Webhooks&lt;/strong&gt;, which in turn can send an email or text message alert. This extends the Arduino\u2019s reach to instant notifications, without any network shield \u2013 the host handles the internet communication. (You would configure an IFTTT applet or similar with your own API key and event name; placeholders are in the code.)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * AlertNotification.ino\n * \n * Uses the Bang library to send a web request via the host machine\n * to trigger an email or SMS notification (e.g., via IFTTT webhooks) \n * when a sensor or button is activated. The Arduino signals the host PC \n * to execute a curl command to a web service, which can send an alert.\n *\n * Hardware:\n * - Use a push button or digital sensor connected to pin 2 (active LOW).\n *   Internal pull-up resistor is enabled, so wire one side of the button \n *   to pin 2 and the other to ground.\n * - (Optional) An LED connected to pin 13 will blink when an alert is sent.\n * \n * Prerequisites on host:\n * - The host must have internet access and `curl` installed (available by default on Mac/Linux, and on Windows 10+ or via Git for Windows).\n * - An IFTTT account with a Webhooks service set up (or any similar webhook URL for notifications).\n * - Replace the IFTTT_KEY and EVENT_NAME with your own Webhooks key and event name.\n *   Alternatively, adjust the curl command to any service or script that handles notifications.\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7    // SoftwareSerial RX (to host TX)\n#define TX_PIN 8    // SoftwareSerial TX (to host RX)\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst char* IFTTT_KEY = &amp;quot;REPLACE_WITH_YOUR_IFTTT_KEY&amp;quot;;     // &amp;lt;-- Your IFTTT Webhooks key\nconst char* EVENT_NAME = &amp;quot;REPLACE_WITH_YOUR_EVENT_NAME&amp;quot;;   // &amp;lt;-- Your IFTTT event name\n\nconst int SENSOR_PIN = 2;\nconst int LED_PIN = 13;\n\nbool alertSent = false;  // flag to prevent multiple triggers while button/sensor is held\n\nvoid setup() {\n  // Initialize serial communications\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(SENSOR_PIN, INPUT_PULLUP);  // using internal pull-up, so active low\n  pinMode(LED_PIN, OUTPUT);\n  digitalWrite(LED_PIN, LOW);\n\n  // Wait a moment for Serial (if connected) and print a start message\n  delay(100);\n  Serial.println(F(&amp;quot;=== Alert Notification Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Waiting for sensor trigger...&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Will send webhook on trigger.&amp;quot;));\n}\n\nvoid loop() {\n  // Check sensor/button state\n  int sensorState = digitalRead(SENSOR_PIN);\n  if (sensorState == LOW &amp;amp;&amp;amp; !alertSent) {\n    // Sensor is triggered (button pressed)\n    alertSent = true;\n    Serial.println(F(&amp;quot;Sensor triggered! Sending alert...&amp;quot;));\n    digitalWrite(LED_PIN, HIGH);  // Turn on LED to indicate alert is being sent\n\n    // Construct the curl command to trigger the IFTTT webhook\n    // The webhook URL is: \n    pcSerial.print(F(&amp;quot;!curl -X POST \\&amp;quot;https://maker.ifttt.com/trigger/&amp;quot;));\n    pcSerial.print(EVENT_NAME);\n    pcSerial.print(F(&amp;quot;/with/key/&amp;quot;));\n    pcSerial.print(IFTTT_KEY);\n    pcSerial.println(F(&amp;quot;?value1=Alert%20Triggered\\&amp;quot;&amp;quot;));\n\n    Serial.println(F(&amp;quot;Alert command sent to host.&amp;quot;));\n  }\n  if (sensorState == HIGH &amp;amp;&amp;amp; alertSent) {\n    // Sensor released (button unpressed), reset for next trigger\n    alertSent = false;\n    Serial.println(F(&amp;quot;Sensor reset. Ready for next alert.&amp;quot;));\n    digitalWrite(LED_PIN, LOW);\n    // (Optionally keep LED on for a fixed time or until acknowledged)\n  }\n\n  // Check for any response from the host (e.g., confirmation or errors from curl)\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() &amp;gt; 0) {\n      // Print the host response to the Serial Monitor for debugging\n      Serial.println(output);\n    }\n  }\n\n  // Small delay to debounce sensor and avoid flooding\n  delay(50);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;2. Network Connectivity Ping Monitor&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch uses the host to periodically &lt;strong&gt;ping&lt;/strong&gt; an external server (here, Google\u2019s DNS at 8.8.8.8) to check for internet connectivity. The Arduino triggers a ping command on the host every 5 seconds and reads the result. It then indicates network status by toggling the Arduino\u2019s onboard LED: if the ping fails (no response), the LED turns &lt;strong&gt;ON&lt;/strong&gt; as a warning; if the ping succeeds, the LED stays &lt;strong&gt;OFF&lt;/strong&gt;. This effectively makes the Arduino a network connectivity monitor or heartbeating device. The example shows parsing command output (looking for specific substrings in the ping reply) to determine success or failure. (By default, the code uses the Windows &lt;code&gt;ping -n 1&lt;/code&gt; syntax. For Unix-based systems, you\u2019d use &lt;code&gt;ping -c 1&lt;/code&gt;. The comments indicate where to change this.)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * PingMonitor.ino\n *\n * Periodically pings a remote server (e.g., Google DNS at 8.8.8.8 or google.com) using \n * the host machine&amp;#39;s ping command to check internet connectivity. \n * The Arduino uses the Bang library to send ping commands and interprets the results \n * to indicate network status by blinking the onboard LED.\n *\n * - The host PC executes the ping command and returns the output to Arduino.\n * - If the ping is successful, the Arduino turns OFF the onboard LED.\n * - If the ping fails (no response), the Arduino turns ON the LED as an alert.\n *\n * Hardware:\n * - Onboard LED (pin 13 on Arduino Uno) used to show network status (ON = no connectivity).\n * \n * Note: By default, this sketch uses the Windows ping syntax.\n *       On Windows, ping is invoked with &amp;quot;-n 1&amp;quot; for a single ping.\n *       If using Mac/Linux, change the ping command to use &amp;quot;-c 1&amp;quot; instead of &amp;quot;-n 1&amp;quot;.\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst unsigned long PING_INTERVAL = 5000;  // ping every 5 seconds\nunsigned long lastPingTime = 0;\nbool pingSuccess = false;  // track result of last ping\n\nconst int LED_PIN = 13;\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(LED_PIN, OUTPUT);\n  digitalWrite(LED_PIN, LOW);  // start with LED off (assuming network OK initially)\n\n  Serial.println(F(&amp;quot;=== Network Ping Monitor Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Pinging host every 5 seconds. LED ON = Ping failed, LED OFF = Ping successful.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Using Windows ping syntax by default.&amp;quot;));\n}\n\nvoid loop() {\n  // Periodically send ping command\n  if (millis() - lastPingTime &amp;gt;= PING_INTERVAL) {\n    lastPingTime = millis();\n    pingSuccess = false;  // reset success flag for this round\n\n    Serial.println(F(&amp;quot;Sending ping...&amp;quot;));\n    // Send a single ping; use appropriate flag for your OS (&amp;#39;-n 1&amp;#39; for Windows, &amp;#39;-c 1&amp;#39; for Unix)\n    pcSerial.println(F(&amp;quot;!ping -n 1 8.8.8.8&amp;quot;));  // ping Google&amp;#39;s DNS (8.8.8.8)\n    // If on Mac/Linux, you would use: pcSerial.println(F(&amp;quot;!ping -c 1 8.8.8.8&amp;quot;));\n  }\n\n  // Check for ping response output from host\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() == 0) {\n      continue;\n    }\n    // Echo the ping output to Serial monitor for debugging\n    Serial.println(output);\n    // Look for keywords indicating success or failure\n    if (output.indexOf(&amp;quot;Reply from&amp;quot;) &amp;gt;= 0 || output.indexOf(&amp;quot;bytes from&amp;quot;) &amp;gt;= 0) {\n      // Indicates at least one successful ping reply (Windows or Unix)\n      pingSuccess = true;\n    }\n    // We could also check for &amp;quot;Request timed out&amp;quot; or &amp;quot;unreachable&amp;quot; for failures, \n    // but pingSuccess will remain false if no success keywords are found.\n  }\n\n  // Update LED based on ping result\n  if (pingSuccess) {\n    // Ping succeeded, ensure LED is off\n    digitalWrite(LED_PIN, LOW);\n  } else {\n    // Ping failed (no reply), turn LED on\n    digitalWrite(LED_PIN, HIGH);\n  }\n\n  // (Optional) add a small delay to avoid busy-waiting, but not necessary since using millis timing\n  delay(10);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;3. Web Browser Launcher (Physical Button to Open URL)&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch makes a push-button on the Arduino act as a trigger to &lt;strong&gt;open a website&lt;/strong&gt; on the host\u2019s default web browser. It\u2019s like a physical shortcut key \u2013 press the button and the host will launch a specified URL. In this example, pressing the button will open the Arduino official website. On Windows this uses the &lt;code&gt;start&lt;/code&gt; command, on macOS the &lt;code&gt;open&lt;/code&gt; command, and on Linux &lt;code&gt;xdg-open&lt;/code&gt; (the code defaults to Windows, but alternatives are commented). This demonstrates the Arduino controlling desktop applications and GUI actions via command-line \u2013 no HID emulation needed, the host does the heavy lifting.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * WebLauncher.ino\n *\n * Opens a website on the host computer&amp;#39;s default web browser when a button on the Arduino is pressed.\n * The Arduino uses the Bang library to send a command to the host to launch the URL.\n *\n * Hardware:\n * - A push button connected to pin 2 (and ground) to trigger the action. \n *   Pin 2 uses the internal pull-up resistor, so the button should connect pin 2 to GND when pressed.\n *\n * Host commands:\n * - Windows: uses &amp;quot;start&amp;quot; to open the URL.\n * - Mac: use &amp;quot;open&amp;quot; to open the URL.\n * - Linux: use &amp;quot;xdg-open&amp;quot; to open the URL.\n * (This example defaults to Windows; adjust the command for other OS as needed.)\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst int BUTTON_PIN = 2;\nbool launchTriggered = false;  // to track button state\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  Serial.println(F(&amp;quot;=== Web Launcher Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Press the button to open a website on the host&amp;#39;s browser.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Default command is for Windows (start).&amp;quot;));\n}\n\nvoid loop() {\n  int buttonState = digitalRead(BUTTON_PIN);\n  if (buttonState == LOW &amp;amp;&amp;amp; !launchTriggered) {\n    // Button pressed (active low) and not already triggered\n    launchTriggered = true;\n    Serial.println(F(&amp;quot;Button pressed! Launching website...&amp;quot;));\n    // Send command to open the URL on host\n    pcSerial.println(F(&amp;quot;!start https://www.arduino.cc&amp;quot;));\n    // For Mac: pcSerial.println(F(&amp;quot;!open https://www.arduino.cc&amp;quot;));\n    // For Linux: pcSerial.println(F(&amp;quot;!xdg-open https://www.arduino.cc&amp;quot;));\n  } \n  else if (buttonState == HIGH &amp;amp;&amp;amp; launchTriggered) {\n    // Button released, reset trigger\n    launchTriggered = false;\n    // Debounce delay (optional)\n    delay(50);\n  }\n\n  // Print any output from the host (if any). Usually, opening a URL may not produce console output.\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() &amp;gt; 0) {\n      Serial.println(output);\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;4. CPU Usage Monitor and Alarm&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch offloads the task of checking CPU load to the host and uses the result to signal high usage on the Arduino. Every 2 seconds, the Arduino asks the host for the current CPU utilization (as a percentage). On Windows, it uses the &lt;code&gt;WMIC&lt;/code&gt; command to get the CPU load; the code could be adapted for Mac/Linux using appropriate commands. The Arduino parses the returned percentage and prints it. If the CPU usage exceeds a defined threshold (80% in this example), the Arduino\u2019s LED will turn &lt;strong&gt;ON&lt;/strong&gt; to indicate a high-load condition; otherwise it remains &lt;strong&gt;OFF&lt;/strong&gt;. This can be used as a tiny hardware CPU monitor or to trigger further actions when the host is under heavy load.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * CpuMonitor.ino\n *\n * Retrieves the host machine&amp;#39;s CPU usage (in percent) and indicates high usage via an LED.\n * The Arduino requests the CPU load from the host using a shell command, and parses the result.\n *\n * This example is tailored for Windows using the WMIC command to get CPU load.\n * For other OS:\n *   - On Linux, you might use `grep &amp;#39;cpu &amp;#39; /proc/stat` or `top -bn1` and parse the output.\n *   - On Mac, you could use `ps -A -o %cpu` and calculate an average, or other system diagnostics.\n *\n * Hardware:\n * - An LED on pin 13 indicates high CPU usage (ON if CPU &amp;gt;= 80%, OFF if below).\n *   (Using the built-in LED on Arduino Uno).\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst unsigned long CHECK_INTERVAL = 2000;  // check every 2 seconds\nunsigned long lastCheckTime = 0;\nconst int LED_PIN = 13;\nconst int HIGH_USAGE_THRESHOLD = 80; // percent CPU usage to consider &amp;quot;high&amp;quot;\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(LED_PIN, OUTPUT);\n  digitalWrite(LED_PIN, LOW);\n\n  Serial.println(F(&amp;quot;=== CPU Usage Monitor Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Checking CPU load every 2 seconds. LED on if CPU &amp;gt;= 80%.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Using WMIC on Windows for CPU load.&amp;quot;));\n}\n\nvoid loop() {\n  if (millis() - lastCheckTime &amp;gt;= CHECK_INTERVAL) {\n    lastCheckTime = millis();\n    Serial.println(F(&amp;quot;Querying CPU load...&amp;quot;));\n    // Query CPU load percentage via Windows WMIC \n    pcSerial.println(F(&amp;quot;!wmic cpu get LoadPercentage /value&amp;quot;));\n    // (For Mac/Linux, replace with an appropriate command)\n  }\n\n  // Read and parse any response from the host\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() == 0) continue;\n    Serial.println(output); // debug: print raw output\n\n    int eqPos = output.indexOf(&amp;#39;=&amp;#39;);\n    if (eqPos &amp;gt;= 0) {\n      String valueStr = output.substring(eqPos + 1);\n      valueStr.trim();\n      int cpuPercent = valueStr.toInt();\n      Serial.print(F(&amp;quot;CPU Usage: &amp;quot;));\n      Serial.print(cpuPercent);\n      Serial.println(F(&amp;quot;%&amp;quot;));\n      // Indicate high CPU usage on LED\n      if (cpuPercent &amp;gt;= HIGH_USAGE_THRESHOLD) {\n        digitalWrite(LED_PIN, HIGH);  // turn LED on if usage is high\n      } else {\n        digitalWrite(LED_PIN, LOW);   // turn LED off if usage is normal\n      }\n    }\n  }\n\n  delay(50); // small delay to avoid busy loop\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;5. Clipboard Sharing (Copy/Paste Integration)&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch integrates the Arduino with the host\u2019s &lt;strong&gt;clipboard&lt;/strong&gt; (copy-paste buffer). It sets up two buttons: one to &lt;strong&gt;retrieve&lt;/strong&gt; whatever text is currently on the host\u2019s clipboard and send it to the Arduino, and another to &lt;strong&gt;set&lt;/strong&gt; the host clipboard to a predefined text. Imagine using this with an LCD display: you could press a button to have the Arduino display whatever text you copied on your PC, or press another to inject a prepared text into the PC\u2019s clipboard (perhaps a canned message or sensor reading that you want to paste into a document). This example uses PowerShell commands on Windows (&lt;code&gt;Get-Clipboard&lt;/code&gt; and &lt;code&gt;Set-Clipboard&lt;/code&gt;); it notes alternatives for Mac (&lt;code&gt;pbpaste&lt;/code&gt;/&lt;code&gt;pbcopy&lt;/code&gt;) and Linux (&lt;code&gt;xclip&lt;/code&gt;). It shows bi-directional use of &lt;code&gt;!command&lt;/code&gt;: getting data from host to Arduino, and sending data from Arduino to host, both via the clipboard.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * ClipboardBridge.ino\n *\n * Demonstrates two-way clipboard integration:\n * - Read (retrieve) the host&amp;#39;s clipboard content and send it to the Arduino.\n * - Write (set) the host&amp;#39;s clipboard content from the Arduino.\n *\n * The Arduino uses the Bang library to send the appropriate commands to the host:\n * - On Windows: uses PowerShell Get-Clipboard and Set-Clipboard.\n * - On Mac: use `pbpaste` to get and `pbcopy` to set (via echo piped).\n * - On Linux: use `xclip` or `xsel` (if installed) to get/set the clipboard.\n *\n * Hardware:\n * - Button on pin 2: When pressed, fetches the host&amp;#39;s clipboard text.\n * - Button on pin 3: When pressed, copies a preset message from Arduino to the host clipboard.\n * Both buttons use internal pull-up resistors (active LOW when pressed).\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst int GET_BUTTON_PIN = 2;\nconst int SET_BUTTON_PIN = 3;\nbool getPressed = false;\nbool setPressed = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(GET_BUTTON_PIN, INPUT_PULLUP);\n  pinMode(SET_BUTTON_PIN, INPUT_PULLUP);\n\n  Serial.println(F(&amp;quot;=== Clipboard Bridge Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Btn2 (pin 2) -&amp;gt; Read host clipboard, Btn3 (pin 3) -&amp;gt; Set host clipboard.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Using PowerShell commands on Windows.&amp;quot;));\n}\n\nvoid loop() {\n  // Read buttons (active low)\n  int getBtnState = digitalRead(GET_BUTTON_PIN);\n  int setBtnState = digitalRead(SET_BUTTON_PIN);\n\n  if (getBtnState == LOW &amp;amp;&amp;amp; !getPressed) {\n    // Fetch clipboard button pressed\n    getPressed = true;\n    Serial.println(F(&amp;quot;Fetching clipboard content from host...&amp;quot;));\n    // Windows: Get-Clipboard\n    pcSerial.println(F(&amp;quot;!powershell -Command \\&amp;quot;Get-Clipboard\\&amp;quot;&amp;quot;));\n    // Mac alternative: pcSerial.println(F(&amp;quot;!pbpaste&amp;quot;));\n    // Linux alternative: pcSerial.println(F(&amp;quot;!xclip -o -selection clipboard&amp;quot;));\n  } else if (getBtnState == HIGH &amp;amp;&amp;amp; getPressed) {\n    getPressed = false;\n    delay(50); // debounce\n  }\n\n  if (setBtnState == LOW &amp;amp;&amp;amp; !setPressed) {\n    // Set clipboard button pressed\n    setPressed = true;\n    Serial.println(F(&amp;quot;Setting host clipboard from Arduino...&amp;quot;));\n    // Windows: Set-Clipboard with a message\n    pcSerial.println(&amp;quot;!powershell -Command \\&amp;quot;Set-Clipboard -Value &amp;#39;Hello from Arduino&amp;#39;\\&amp;quot;&amp;quot;);\n    // Mac alternative: pcSerial.println(F(&amp;quot;!echo &amp;#39;Hello from Arduino&amp;#39; | pbcopy&amp;quot;));\n    // Linux alternative: pcSerial.println(F(&amp;quot;!echo &amp;#39;Hello from Arduino&amp;#39; | xclip -selection clipboard&amp;quot;));\n  } else if (setBtnState == HIGH &amp;amp;&amp;amp; setPressed) {\n    setPressed = false;\n    delay(50); // debounce\n  }\n\n  // Read any response from host and display\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    // Note: Clipboard content could be multi-line; this will print it as it comes.\n    if (output.length() &amp;gt; 0) {\n      Serial.print(F(&amp;quot;[Host clipboard output] &amp;quot;));\n      Serial.println(output);\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;6. Automated Keystrokes (Typing a Message on Host)&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch enables the Arduino to &lt;strong&gt;type a text string on the host&lt;/strong&gt; as if it were typed on the keyboard. When a button is pressed, the Arduino commands the host to simulate keystrokes for a specific message (here, \u201cHello from Arduino\u201d). On Windows, it uses PowerShell to create a WScript Shell COM object and send keystrokes; on a Mac, an AppleScript &lt;code&gt;osascript&lt;/code&gt; command could be used (example in comments). This is useful for automation or accessibility: for instance, a single hardware button could enter a password or often-used phrase on the PC, or perform a series of shortcut keys. (It\u2019s akin to the Arduino acting like a USB HID keyboard, but here we do it entirely through software on the host side.)&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * KeyboardAutomation.ino\n *\n * Simulates keyboard input on the host machine from the Arduino.\n * When the button is pressed, the Arduino instructs the host to send keystrokes (typing a text string).\n *\n * Note: For the keystrokes to be visible, an application window or text field on the host must be focused.\n *\n * This example uses:\n * - Windows: PowerShell with a WScript Shell COM object to send keys.\n * - Mac: AppleScript via `osascript` to send keystrokes.\n * - Linux: Requires a tool like `xdotool` to simulate key presses.\n *\n * Hardware:\n * - Push button on pin 2 (to ground, using internal pull-up).\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst int BUTTON_PIN = 2;\nbool keyPressed = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  Serial.println(F(&amp;quot;=== Keyboard Automation Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Press the button to type a message on the host machine.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Default command is for Windows PowerShell.&amp;quot;));\n}\n\nvoid loop() {\n  int btnState = digitalRead(BUTTON_PIN);\n  if (btnState == LOW &amp;amp;&amp;amp; !keyPressed) {\n    keyPressed = true;\n    Serial.println(F(&amp;quot;Button pressed! Sending keystrokes...&amp;quot;));\n    // Windows: use PowerShell to send keystrokes via \n    pcSerial.println(&amp;quot;!powershell -Command \\&amp;quot;$wshell = New-Object -ComObject ; $wshell.SendKeys(&amp;#39;Hello from Arduino&amp;#39;)\\&amp;quot;&amp;quot;);\n    // Mac alternative: pcSerial.println(F(&amp;quot;!osascript -e &amp;#39;tell application \\&amp;quot;System Events\\&amp;quot; to keystroke \\&amp;quot;Hello from Arduino\\&amp;quot;&amp;#39;&amp;quot;));\n    // Linux alternative (with xdotool installed): pcSerial.println(F(&amp;quot;!xdotool type &amp;#39;Hello from Arduino&amp;#39;&amp;quot;));\n  } else if (btnState == HIGH &amp;amp;&amp;amp; keyPressed) {\n    keyPressed = false;\n    delay(50);\n  }\n\n  // Display any output or error from host (if any)\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() &amp;gt; 0) {\n      Serial.println(output);\n    }\n  }\n}WScript.Shellwscript.shell\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;7. Host PC Lock (Security Lock Button)&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch provides a physical \u201clock computer\u201d button. When pressed, the Arduino will command the host to &lt;strong&gt;lock the current user session&lt;/strong&gt; \u2013 equivalent to pressing Win+L on Windows or Ctrl+Command+Q on a Mac. This is handy as a security measure (for example, a wireless remote to lock your PC when you walk away). The example uses the Windows &lt;code&gt;rundll32.exe user32.dll,LockWorkStation&lt;/code&gt; command to immediately lock the workstation. For other OS, appropriate commands are given in comments (e.g., an AppleScript to invoke the screen saver or lock command on Mac, or &lt;code&gt;loginctl lock-session&lt;/code&gt; on Linux). After sending the command, the host will lock \u2013 the Arduino won\u2019t get a response (and you\u2019ll need to log back in to resume, as normal). This shows Arduino controlling OS security features.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * HostLock.ino\n *\n * Allows the Arduino to lock the host machine (useful for security, e.g., a panic button that locks your PC).\n * When the button is pressed, the host OS will be instructed to lock the current user session.\n *\n * Host commands:\n * - Windows: uses rundll32 to lock the workstation.\n * - Mac: could use AppleScript to simulate the Ctrl+Cmd+Q shortcut (lock screen).\n * - Linux: could use `loginctl lock-session` or `xdg-screensaver lock`.\n *\n * Hardware:\n * - Push button on pin 2 (to ground, with internal pull-up).\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst int BUTTON_PIN = 2;\nbool lockTriggered = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  Serial.println(F(&amp;quot;=== Host Lock Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Press the button to lock the host computer.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Default uses Windows lock command.&amp;quot;));\n}\n\nvoid loop() {\n  int btnState = digitalRead(BUTTON_PIN);\n  if (btnState == LOW &amp;amp;&amp;amp; !lockTriggered) {\n    lockTriggered = true;\n    Serial.println(F(&amp;quot;Button pressed! Locking host...&amp;quot;));\n    // Windows: lock workstation\n    pcSerial.println(F(&amp;quot;!rundll32.exe user32.dll,LockWorkStation&amp;quot;));\n    // Mac alternative: pcSerial.println(F(&amp;quot;!osascript -e &amp;#39;tell application \\&amp;quot;System Events\\&amp;quot; to keystroke \\&amp;quot;q\\&amp;quot; using {control down, command down}&amp;#39;&amp;quot;));\n    // Linux alternative: pcSerial.println(F(&amp;quot;!loginctl lock-session&amp;quot;));\n    // (Note: Locking will occur immediately; ensure you have access to unlock!)\n  } else if (btnState == HIGH &amp;amp;&amp;amp; lockTriggered) {\n    lockTriggered = false;\n    delay(50);\n  }\n\n  // There may not be any output from the lock command, but handle any just in case\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() &amp;gt; 0) {\n      Serial.println(output);\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;8. Laptop Battery Level Monitor&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This sketch checks the host\u2019s battery level (for laptops) and alerts if the battery is low. The Arduino periodically asks the host for the current battery charge percentage. On Windows, it uses a WMI query via &lt;code&gt;wmic&lt;/code&gt; to get &lt;code&gt;EstimatedChargeRemaining&lt;/code&gt;. If the battery percentage is below a defined threshold (20% here), the Arduino will blink its LED rapidly to warn of low battery; it also prints the percentage and a low-battery warning to the serial output. If no battery is present (desktop PC), the host will report no instance and the sketch will simply indicate \u201cno battery\u201d. This example is useful as a custom battery alarm or to trigger power-saving measures via Arduino outputs when the host battery is low.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * BatteryMonitor.ino\n *\n * Monitors the host machine&amp;#39;s battery level and alerts when it falls below a certain threshold.\n * The Arduino queries the host for battery charge percentage and turns on/blinks an LED if the battery is low.\n *\n * This example uses Windows WMI via `wmic` to get the battery level.\n * On a desktop with no battery, the query will indicate no battery available.\n * For Mac/Linux, appropriate commands (e.g., `pmset -g batt` on Mac or `acpi -b` on Linux with ACPI installed) could be used instead.\n *\n * Hardware:\n * - LED on pin 13 used to indicate low battery (blinks when battery is below threshold).\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst unsigned long CHECK_INTERVAL = 10000; // check every 10 seconds\nunsigned long lastCheck = 0;\nconst int LED_PIN = 13;\nconst int LOW_BATT_THRESHOLD = 20; // 20% battery remaining threshold\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(LED_PIN, OUTPUT);\n  digitalWrite(LED_PIN, LOW);\n\n  Serial.println(F(&amp;quot;=== Battery Monitor Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Checking battery level every 10 seconds. LED will blink if battery is low (&amp;lt;20%).&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Using WMIC on Windows to get battery level.&amp;quot;));\n}\n\nvoid loop() {\n  if (millis() - lastCheck &amp;gt;= CHECK_INTERVAL) {\n    lastCheck = millis();\n    Serial.println(F(&amp;quot;Querying battery level...&amp;quot;));\n    pcSerial.println(F(&amp;quot;!wmic path Win32_Battery get EstimatedChargeRemaining /value&amp;quot;));\n  }\n\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() == 0) continue;\n    Serial.println(output); // debug output from host\n\n    if (output.indexOf(&amp;quot;No Instance&amp;quot;) &amp;gt;= 0) {\n      Serial.println(F(&amp;quot;No battery detected on host.&amp;quot;));\n      // If no battery, turn off LED (no alert)\n      digitalWrite(LED_PIN, LOW);\n    }\n    int eqPos = output.indexOf(&amp;#39;=&amp;#39;);\n    if (eqPos &amp;gt;= 0) {\n      String percStr = output.substring(eqPos + 1);\n      percStr.trim();\n      int batteryPercent = percStr.toInt();\n      Serial.print(F(&amp;quot;Battery: &amp;quot;));\n      Serial.print(batteryPercent);\n      Serial.println(F(&amp;quot;%&amp;quot;));\n      if (batteryPercent &amp;gt; 0 &amp;amp;&amp;amp; batteryPercent &amp;lt;= LOW_BATT_THRESHOLD) {\n        // Battery is low, blink LED a few times as warning\n        Serial.println(F(&amp;quot;Battery low! Blinking LED...&amp;quot;));\n        for (int i = 0; i &amp;lt; 3; ++i) {\n          digitalWrite(LED_PIN, HIGH);\n          delay(150);\n          digitalWrite(LED_PIN, LOW);\n          delay(150);\n        }\n      } else {\n        // Battery okay, ensure LED is off\n        digitalWrite(LED_PIN, LOW);\n      }\n    }\n  }\n\n  delay(50);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;9. Random Joke Fetcher (Internet API Example)&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This playful sketch fetches a &lt;strong&gt;random joke from an online API&lt;/strong&gt; and prints it, demonstrating how an Arduino can leverage web APIs through the host. Pressing the button makes the Arduino tell the host to &lt;code&gt;curl&lt;/code&gt; a joke from the internet (using the free &lt;a href=\"http://icanhazdadjoke.com\"&gt;icanhazdadjoke.com&lt;/a&gt; API, which returns a random joke in plain text). The host\u2019s response (the joke text) is then read and displayed by the Arduino (e.g., you could attach an LCD or just read it in the Serial Monitor). This is similar to the weather example in concept but uses a different API and returns a single line of text. It shows how easily one can integrate internet services for fun or informative data.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * JokeFetcher.ino\n *\n * Fetches a random joke from an online API and displays it via the Arduino.\n * When the button is pressed, the Arduino asks the host to retrieve a joke from the internet.\n *\n * This example uses the  API which returns a random joke in plain text (no API key required).\n * It uses curl to fetch the joke.\n *\n * Hardware:\n * - Push button on pin 2 (to ground, with internal pull-up) to trigger fetching a new joke.\n * - (Optional) You can connect an LCD or serial monitor to display the joke text.\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst int BUTTON_PIN = 2;\nbool fetchTriggered = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  Serial.println(F(&amp;quot;=== Random Joke Fetcher Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Press the button to fetch a random joke from the internet.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running and host has internet connectivity.&amp;quot;));\n}\n\nvoid loop() {\n  int btnState = digitalRead(BUTTON_PIN);\n  if (btnState == LOW &amp;amp;&amp;amp; !fetchTriggered) {\n    fetchTriggered = true;\n    Serial.println(F(&amp;quot;Button pressed! Fetching a joke...&amp;quot;));\n    // Use curl to get a random joke in plain text\n    pcSerial.println(F(&amp;quot;!curl -s -H \\&amp;quot;Accept: text/plain\\&amp;quot; https://icanhazdadjoke.com/&amp;quot;));\n  } else if (btnState == HIGH &amp;amp;&amp;amp; fetchTriggered) {\n    fetchTriggered = false;\n    delay(50);\n  }\n\n  // Read the joke or any output from host\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    if (output.length() &amp;gt; 0) {\n      // Print the joke to Serial Monitor\n      Serial.print(F(&amp;quot;Joke: &amp;quot;));\n      Serial.println(output);\n    }\n  }\n}icanhazdadjoke.com\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;10. CD/DVD Tray Ejector (Optical Drive Control)&lt;/h1&gt;\n\n&lt;p&gt;&lt;em&gt;Description:&lt;/em&gt; This final sketch lets the Arduino open (eject) and potentially close the host computer\u2019s CD/DVD drive tray. With a press of the button, the Arduino issues a command to the host to toggle the optical drive tray. On Windows, it uses a Windows Media Player COM interface via PowerShell to control the first CD-ROM drive \u2013 this will &lt;strong&gt;open the tray&lt;/strong&gt; if it\u2019s closed, or &lt;strong&gt;close it if it\u2019s open&lt;/strong&gt; (acting like the eject button on the drive). On Mac, a &lt;code&gt;drutil eject&lt;/code&gt; command could be used (for Macs with optical drives), and on Linux the &lt;code&gt;eject&lt;/code&gt; command (with &lt;code&gt;-t&lt;/code&gt; to close). This is a fun hardware control example, effectively giving the Arduino a way to press the PC\u2019s eject button via software.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;/*\n * CDEject.ino\n *\n * Controls the host computer&amp;#39;s CD/DVD drive tray (optical drive) via the Arduino.\n * Pressing the button will eject (open) the drive tray. Pressing it again may close the tray (depending on host command support).\n *\n * Host commands:\n * - Windows: uses Windows Media Player COM interface via PowerShell to toggle the CD tray.\n * - Mac: use `drutil eject` to open and `drutil tray close` to close (for built-in DVD drive or external Apple SuperDrive).\n * - Linux: use `eject` to open and `eject -t` to close (if appropriate privileges).\n *\n * Hardware:\n * - Push button on pin 2 (to ground, with internal pull-up).\n * - (Requires the host to have a CD/DVD drive capable of opening/closing.)\n */\n#include &amp;lt;SoftwareSerial.h&amp;gt;\n\n#define RX_PIN 7\n#define TX_PIN 8\nSoftwareSerial pcSerial(RX_PIN, TX_PIN);\n\nconst int BUTTON_PIN = 2;\nbool ejectTriggered = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  pcSerial.begin(38400);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  Serial.println(F(&amp;quot;=== CD Tray Ejector Sketch ===&amp;quot;));\n  Serial.println(F(&amp;quot;Press the button to toggle the CD/DVD drive tray (open/close) on the host.&amp;quot;));\n  Serial.println(F(&amp;quot;Ensure Python agent is running. Default command is for Windows via WMP COM interface.&amp;quot;));\n}\n\nvoid loop() {\n  int btnState = digitalRead(BUTTON_PIN);\n  if (btnState == LOW &amp;amp;&amp;amp; !ejectTriggered) {\n    ejectTriggered = true;\n    Serial.println(F(&amp;quot;Button pressed! Toggling CD tray...&amp;quot;));\n    // Windows: Toggle CD tray via Windows Media Player COM (opens if closed, closes if open)\n    pcSerial.println(F(&amp;quot;!powershell -Command \\&amp;quot;(New-Object -ComObject WMPlayer.OCX.7).cdromCollection.Item(0).Eject()\\&amp;quot;&amp;quot;));\n    // Mac alternative: pcSerial.println(F(&amp;quot;!drutil eject&amp;quot;));\n    // Linux alternative: pcSerial.println(F(&amp;quot;!eject&amp;quot;));\n  } else if (btnState == HIGH &amp;amp;&amp;amp; ejectTriggered) {\n    ejectTriggered = false;\n    delay(100);\n  }\n\n  // Read any output from host (likely none on success, maybe error if no drive)\n  while (pcSerial.available() &amp;gt; 0) {\n    String output = pcSerial.readString();\n    output.trim();\n    if (output.length() &amp;gt; 0) {\n      Serial.println(output);\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;All the Best!&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;ripred&lt;/code&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;",
  "likes": null,
  "suggested_sort": "confidence",
  "banned_at_utc": null,
  "view_count": null,
  "archived": false,
  "no_follow": false,
  "is_crosspostable": false,
  "pinned": false,
  "over_18": false,
  "preview": {
    "images": [
      {
        "source": {
          "url": "https://external-preview.redd.it/yF4mlUM7ByXdF-l5bS2PePQz3W5qQyksYRI4kwHJ5-A.jpg?auto=webp&amp;s=0b3fc9c3ae60613b434904603475e9ee8fdf50de",
          "width": 1200,
          "height": 600
        },
        "resolutions": [
          {
            "url": "https://external-preview.redd.it/yF4mlUM7ByXdF-l5bS2PePQz3W5qQyksYRI4kwHJ5-A.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=908b88a3ba3479ce17765b09dc6c4c0736c705f1",
            "width": 108,
            "height": 54
          },
          {
            "url": "https://external-preview.redd.it/yF4mlUM7ByXdF-l5bS2PePQz3W5qQyksYRI4kwHJ5-A.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=df4036c6e3b1ee19491c4546e08e1e791ff07c13",
            "width": 216,
            "height": 108
          },
          {
            "url": "https://external-preview.redd.it/yF4mlUM7ByXdF-l5bS2PePQz3W5qQyksYRI4kwHJ5-A.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=57dccb9452a600281b085cbb0c172e569029679a",
            "width": 320,
            "height": 160
          },
          {
            "url": "https://external-preview.redd.it/yF4mlUM7ByXdF-l5bS2PePQz3W5qQyksYRI4kwHJ5-A.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=e008ca321ed5c3d901bfdb9b45ac4c0a84cd01f5",
            "width": 640,
            "height": 320
          },
          {
            "url": "https://external-preview.redd.it/yF4mlUM7ByXdF-l5bS2PePQz3W5qQyksYRI4kwHJ5-A.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=27884d4c5641cfbeaa11d5d415ba9da957924728",
            "width": 960,
            "height": 480
          },
          {
            "url": "https://external-preview.redd.it/yF4mlUM7ByXdF-l5bS2PePQz3W5qQyksYRI4kwHJ5-A.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=0c999cc782a8136c252180da7cafaf10f48b23a5",
            "width": 1080,
            "height": 540
          }
        ],
        "variants": {},
        "id": "Nrwy9bk-2cYNx-9yjRAq57UsC-tWOeZzRRluLS8Bmz0"
      }
    ],
    "enabled": false
  },
  "all_awardings": [],
  "awarders": [],
  "media_only": false,
  "link_flair_template_id": "8a993096-51ce-11e9-84d9-0e29268ab306",
  "can_gild": false,
  "spoiler": false,
  "locked": false,
  "author_flair_text": ":400K::Arduino_500k::600K::640K: My other dev board is a Porsche",
  "treatment_tags": [],
  "visited": false,
  "removed_by": null,
  "num_reports": null,
  "distinguished": null,
  "subreddit_id": "t5_2qknj",
  "author_is_blocked": false,
  "mod_reason_by": null,
  "removal_reason": null,
  "link_flair_background_color": "#94e044",
  "id": "1ijj32t",
  "is_robot_indexable": true,
  "report_reasons": null,
  "author": "ripred3",
  "discussion_type": null,
  "num_comments": 7,
  "send_replies": true,
  "contest_mode": false,
  "mod_reports": [],
  "author_patreon_flair": false,
  "author_flair_text_color": "light",
  "permalink": "/r/arduino/comments/1ijj32t/new_arduino_bang_library_examples/",
  "stickied": false,
  "url": "https://www.reddit.com/r/arduino/comments/1ijj32t/new_arduino_bang_library_examples/",
  "subreddit_subscribers": 691380,
  "created_utc": 1738891011.0,
  "num_crossposts": 0,
  "media": null,
  "is_video": false
}